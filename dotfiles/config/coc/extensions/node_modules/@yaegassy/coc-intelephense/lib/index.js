var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target, mod));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/php-parser/src/lexer/attribute.js
var require_attribute = __commonJS({
  "node_modules/php-parser/src/lexer/attribute.js"(exports, module2) {
    "use strict";
    module2.exports = {
      attributeIndex: 0,
      attributeListDepth: {},
      matchST_ATTRIBUTE: function() {
        let ch = this.input();
        if (this.is_WHITESPACE()) {
          do {
            ch = this.input();
          } while (this.is_WHITESPACE());
          this.unput(1);
          return null;
        }
        switch (ch) {
          case "]":
            if (this.attributeListDepth[this.attributeIndex] === 0) {
              delete this.attributeListDepth[this.attributeIndex];
              this.attributeIndex--;
              this.popState();
            } else {
              this.attributeListDepth[this.attributeIndex]--;
            }
            return "]";
          case "(":
          case ")":
          case ":":
          case "=":
          case "|":
          case "&":
          case "^":
          case "-":
          case "+":
          case "*":
          case "%":
          case "~":
          case "<":
          case ">":
          case "!":
            return this.consume_TOKEN();
          case "[":
            this.attributeListDepth[this.attributeIndex]++;
            return "[";
          case ",":
            return ",";
          case '"':
            return this.ST_DOUBLE_QUOTES();
          case "'":
            return this.T_CONSTANT_ENCAPSED_STRING();
          case "/":
            if (this._input[this.offset] === "/") {
              return this.T_COMMENT();
            } else if (this._input[this.offset] === "*") {
              this.input();
              return this.T_DOC_COMMENT();
            } else {
              return this.consume_TOKEN();
            }
        }
        if (this.is_LABEL_START() || ch === "\\") {
          while (this.offset < this.size) {
            const ch2 = this.input();
            if (!(this.is_LABEL() || ch2 === "\\")) {
              if (ch2)
                this.unput(1);
              break;
            }
          }
          return this.T_STRING();
        } else if (this.is_NUM()) {
          return this.consume_NUM();
        }
        throw new Error(`Bad terminal sequence "${ch}" at line ${this.yylineno} (offset ${this.offset})`);
      }
    };
  }
});

// node_modules/php-parser/src/lexer/comments.js
var require_comments = __commonJS({
  "node_modules/php-parser/src/lexer/comments.js"(exports, module2) {
    "use strict";
    module2.exports = {
      T_COMMENT: function() {
        while (this.offset < this.size) {
          const ch = this.input();
          if (ch === "\n" || ch === "\r") {
            return this.tok.T_COMMENT;
          } else if (ch === "?" && !this.aspTagMode && this._input[this.offset] === ">") {
            this.unput(1);
            return this.tok.T_COMMENT;
          } else if (ch === "%" && this.aspTagMode && this._input[this.offset] === ">") {
            this.unput(1);
            return this.tok.T_COMMENT;
          }
        }
        return this.tok.T_COMMENT;
      },
      T_DOC_COMMENT: function() {
        let ch = this.input();
        let token = this.tok.T_COMMENT;
        if (ch === "*") {
          ch = this.input();
          if (this.is_WHITESPACE()) {
            token = this.tok.T_DOC_COMMENT;
          }
          if (ch === "/") {
            return token;
          } else {
            this.unput(1);
          }
        }
        while (this.offset < this.size) {
          ch = this.input();
          if (ch === "*" && this._input[this.offset] === "/") {
            this.input();
            break;
          }
        }
        return token;
      }
    };
  }
});

// node_modules/php-parser/src/lexer/initial.js
var require_initial = __commonJS({
  "node_modules/php-parser/src/lexer/initial.js"(exports, module2) {
    "use strict";
    module2.exports = {
      nextINITIAL: function() {
        if (this.conditionStack.length > 1 && this.conditionStack[this.conditionStack.length - 1] === "INITIAL") {
          this.popState();
        } else {
          this.begin("ST_IN_SCRIPTING");
        }
        return this;
      },
      matchINITIAL: function() {
        while (this.offset < this.size) {
          let ch = this.input();
          if (ch == "<") {
            ch = this.ahead(1);
            if (ch == "?") {
              if (this.tryMatch("?=")) {
                this.unput(1).appendToken(this.tok.T_OPEN_TAG_WITH_ECHO, 3).nextINITIAL();
                break;
              } else if (this.tryMatchCaseless("?php")) {
                ch = this._input[this.offset + 4];
                if (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
                  this.unput(1).appendToken(this.tok.T_OPEN_TAG, 6).nextINITIAL();
                  break;
                }
              }
              if (this.short_tags) {
                this.unput(1).appendToken(this.tok.T_OPEN_TAG, 2).nextINITIAL();
                break;
              }
            } else if (this.asp_tags && ch == "%") {
              if (this.tryMatch("%=")) {
                this.aspTagMode = true;
                this.unput(1).appendToken(this.tok.T_OPEN_TAG_WITH_ECHO, 3).nextINITIAL();
                break;
              } else {
                this.aspTagMode = true;
                this.unput(1).appendToken(this.tok.T_OPEN_TAG, 2).nextINITIAL();
                break;
              }
            }
          }
        }
        if (this.yytext.length > 0) {
          return this.tok.T_INLINE_HTML;
        } else {
          return false;
        }
      }
    };
  }
});

// node_modules/php-parser/src/lexer/numbers.js
var require_numbers = __commonJS({
  "node_modules/php-parser/src/lexer/numbers.js"(exports, module2) {
    "use strict";
    var MAX_LENGTH_OF_LONG = 10;
    var long_min_digits = "2147483648";
    if (process.arch == "x64") {
      MAX_LENGTH_OF_LONG = 19;
      long_min_digits = "9223372036854775808";
    }
    module2.exports = {
      consume_NUM: function() {
        let ch = this.yytext[0];
        let hasPoint = ch === ".";
        if (ch === "0") {
          ch = this.input();
          if (ch === "x" || ch === "X") {
            ch = this.input();
            if (ch !== "_" && this.is_HEX()) {
              return this.consume_HNUM();
            } else {
              this.unput(ch ? 2 : 1);
            }
          } else if (ch === "b" || ch === "B") {
            ch = this.input();
            if (ch !== "_" && ch === "0" || ch === "1") {
              return this.consume_BNUM();
            } else {
              this.unput(ch ? 2 : 1);
            }
          } else if (!this.is_NUM()) {
            if (ch)
              this.unput(1);
          }
        }
        while (this.offset < this.size) {
          const prev = ch;
          ch = this.input();
          if (ch === "_") {
            if (prev === "_") {
              this.unput(2);
              break;
            }
            if (prev === ".") {
              this.unput(1);
              break;
            }
            if (prev === "e" || prev === "E") {
              this.unput(2);
              break;
            }
          } else if (ch === ".") {
            if (hasPoint) {
              this.unput(1);
              break;
            }
            if (prev === "_") {
              this.unput(2);
              break;
            }
            hasPoint = true;
            continue;
          } else if (ch === "e" || ch === "E") {
            if (prev === "_") {
              this.unput(1);
              break;
            }
            let undo = 2;
            ch = this.input();
            if (ch === "+" || ch === "-") {
              undo = 3;
              ch = this.input();
            }
            if (this.is_NUM_START()) {
              this.consume_LNUM();
              return this.tok.T_DNUMBER;
            }
            this.unput(ch ? undo : undo - 1);
            break;
          }
          if (!this.is_NUM()) {
            if (ch)
              this.unput(1);
            break;
          }
        }
        if (hasPoint) {
          return this.tok.T_DNUMBER;
        } else if (this.yytext.length < MAX_LENGTH_OF_LONG - 1) {
          return this.tok.T_LNUMBER;
        } else {
          if (this.yytext.length < MAX_LENGTH_OF_LONG || this.yytext.length == MAX_LENGTH_OF_LONG && this.yytext < long_min_digits) {
            return this.tok.T_LNUMBER;
          }
          return this.tok.T_DNUMBER;
        }
      },
      consume_HNUM: function() {
        while (this.offset < this.size) {
          const ch = this.input();
          if (!this.is_HEX()) {
            if (ch)
              this.unput(1);
            break;
          }
        }
        return this.tok.T_LNUMBER;
      },
      consume_LNUM: function() {
        while (this.offset < this.size) {
          const ch = this.input();
          if (!this.is_NUM()) {
            if (ch)
              this.unput(1);
            break;
          }
        }
        return this.tok.T_LNUMBER;
      },
      consume_BNUM: function() {
        let ch;
        while (this.offset < this.size) {
          ch = this.input();
          if (ch !== "0" && ch !== "1" && ch !== "_") {
            if (ch)
              this.unput(1);
            break;
          }
        }
        return this.tok.T_LNUMBER;
      }
    };
  }
});

// node_modules/php-parser/src/lexer/property.js
var require_property = __commonJS({
  "node_modules/php-parser/src/lexer/property.js"(exports, module2) {
    "use strict";
    module2.exports = {
      matchST_LOOKING_FOR_PROPERTY: function() {
        let ch = this.input();
        if (ch === "-") {
          ch = this.input();
          if (ch === ">") {
            return this.tok.T_OBJECT_OPERATOR;
          }
          if (ch)
            this.unput(1);
        } else if (this.is_WHITESPACE()) {
          return this.tok.T_WHITESPACE;
        } else if (this.is_LABEL_START()) {
          this.consume_LABEL();
          this.popState();
          return this.tok.T_STRING;
        }
        this.popState();
        if (ch)
          this.unput(1);
        return false;
      },
      matchST_LOOKING_FOR_VARNAME: function() {
        let ch = this.input();
        this.popState();
        this.begin("ST_IN_SCRIPTING");
        if (this.is_LABEL_START()) {
          this.consume_LABEL();
          ch = this.input();
          if (ch === "[" || ch === "}") {
            this.unput(1);
            return this.tok.T_STRING_VARNAME;
          } else {
            this.unput(this.yytext.length);
          }
        } else {
          if (ch)
            this.unput(1);
        }
        return false;
      },
      matchST_VAR_OFFSET: function() {
        const ch = this.input();
        if (this.is_NUM_START()) {
          this.consume_NUM();
          return this.tok.T_NUM_STRING;
        } else if (ch === "]") {
          this.popState();
          return "]";
        } else if (ch === "$") {
          this.input();
          if (this.is_LABEL_START()) {
            this.consume_LABEL();
            return this.tok.T_VARIABLE;
          } else {
            throw new Error("Unexpected terminal");
          }
        } else if (this.is_LABEL_START()) {
          this.consume_LABEL();
          return this.tok.T_STRING;
        } else if (this.is_WHITESPACE() || ch === "\\" || ch === "'" || ch === "#") {
          return this.tok.T_ENCAPSED_AND_WHITESPACE;
        } else if (ch === "[" || ch === "{" || ch === "}" || ch === '"' || ch === "`" || this.is_TOKEN()) {
          return ch;
        } else {
          throw new Error("Unexpected terminal");
        }
      }
    };
  }
});

// node_modules/php-parser/src/lexer/scripting.js
var require_scripting = __commonJS({
  "node_modules/php-parser/src/lexer/scripting.js"(exports, module2) {
    "use strict";
    module2.exports = {
      matchST_IN_SCRIPTING: function() {
        let ch = this.input();
        switch (ch) {
          case " ":
          case "	":
          case "\n":
          case "\r":
          case "\r\n":
            return this.T_WHITESPACE();
          case "#":
            if (this.version >= 800 && this._input[this.offset] === "[") {
              this.input();
              this.attributeListDepth[++this.attributeIndex] = 0;
              this.begin("ST_ATTRIBUTE");
              return this.tok.T_ATTRIBUTE;
            }
            return this.T_COMMENT();
          case "/":
            if (this._input[this.offset] === "/") {
              return this.T_COMMENT();
            } else if (this._input[this.offset] === "*") {
              this.input();
              return this.T_DOC_COMMENT();
            }
            return this.consume_TOKEN();
          case "'":
            return this.T_CONSTANT_ENCAPSED_STRING();
          case '"':
            return this.ST_DOUBLE_QUOTES();
          case "`":
            this.begin("ST_BACKQUOTE");
            return "`";
          case "?":
            if (!this.aspTagMode && this.tryMatch(">")) {
              this.input();
              const nextCH = this._input[this.offset];
              if (nextCH === "\n" || nextCH === "\r")
                this.input();
              if (this.conditionStack.length > 1) {
                this.begin("INITIAL");
              }
              return this.tok.T_CLOSE_TAG;
            }
            return this.consume_TOKEN();
          case "%":
            if (this.aspTagMode && this._input[this.offset] === ">") {
              this.input();
              ch = this._input[this.offset];
              if (ch === "\n" || ch === "\r") {
                this.input();
              }
              this.aspTagMode = false;
              if (this.conditionStack.length > 1) {
                this.begin("INITIAL");
              }
              return this.tok.T_CLOSE_TAG;
            }
            return this.consume_TOKEN();
          case "{":
            this.begin("ST_IN_SCRIPTING");
            return "{";
          case "}":
            if (this.conditionStack.length > 2) {
              this.popState();
            }
            return "}";
          default:
            if (ch === ".") {
              ch = this.input();
              if (this.is_NUM_START()) {
                return this.consume_NUM();
              } else {
                if (ch)
                  this.unput(1);
              }
            }
            if (this.is_NUM_START()) {
              return this.consume_NUM();
            } else if (this.is_LABEL_START()) {
              return this.consume_LABEL().T_STRING();
            } else if (this.is_TOKEN()) {
              return this.consume_TOKEN();
            }
        }
        throw new Error('Bad terminal sequence "' + ch + '" at line ' + this.yylineno + " (offset " + this.offset + ")");
      },
      T_WHITESPACE: function() {
        while (this.offset < this.size) {
          const ch = this.input();
          if (ch === " " || ch === "	" || ch === "\n" || ch === "\r") {
            continue;
          }
          if (ch)
            this.unput(1);
          break;
        }
        return this.tok.T_WHITESPACE;
      }
    };
  }
});

// node_modules/php-parser/src/lexer/strings.js
var require_strings = __commonJS({
  "node_modules/php-parser/src/lexer/strings.js"(exports, module2) {
    "use strict";
    var newline = ["\n", "\r"];
    var valid_after_heredoc = ["\n", "\r", ";"];
    var valid_after_heredoc_73 = valid_after_heredoc.concat([
      "	",
      " ",
      ",",
      "]",
      ")",
      "/",
      "=",
      "!"
    ]);
    module2.exports = {
      T_CONSTANT_ENCAPSED_STRING: function() {
        let ch;
        while (this.offset < this.size) {
          ch = this.input();
          if (ch == "\\") {
            this.input();
          } else if (ch == "'") {
            break;
          }
        }
        return this.tok.T_CONSTANT_ENCAPSED_STRING;
      },
      is_HEREDOC: function() {
        const revert = this.offset;
        if (this._input[this.offset - 1] === "<" && this._input[this.offset] === "<" && this._input[this.offset + 1] === "<") {
          this.offset += 3;
          if (this.is_TABSPACE()) {
            while (this.offset < this.size) {
              this.offset++;
              if (!this.is_TABSPACE()) {
                break;
              }
            }
          }
          let tChar = this._input[this.offset - 1];
          if (tChar === "'" || tChar === '"') {
            this.offset++;
          } else {
            tChar = null;
          }
          if (this.is_LABEL_START()) {
            let yyoffset = this.offset - 1;
            while (this.offset < this.size) {
              this.offset++;
              if (!this.is_LABEL()) {
                break;
              }
            }
            const yylabel = this._input.substring(yyoffset, this.offset - 1);
            if (!tChar || tChar === this._input[this.offset - 1]) {
              if (tChar)
                this.offset++;
              if (newline.includes(this._input[this.offset - 1])) {
                this.heredoc_label.label = yylabel;
                this.heredoc_label.length = yylabel.length;
                this.heredoc_label.finished = false;
                yyoffset = this.offset - revert;
                this.offset = revert;
                this.consume(yyoffset);
                if (tChar === "'") {
                  this.begin("ST_NOWDOC");
                } else {
                  this.begin("ST_HEREDOC");
                }
                this.prematch_ENDOFDOC();
                return this.tok.T_START_HEREDOC;
              }
            }
          }
        }
        this.offset = revert;
        return false;
      },
      ST_DOUBLE_QUOTES: function() {
        let ch;
        while (this.offset < this.size) {
          ch = this.input();
          if (ch == "\\") {
            this.input();
          } else if (ch == '"') {
            break;
          } else if (ch == "$") {
            ch = this.input();
            if (ch == "{" || this.is_LABEL_START()) {
              this.unput(2);
              break;
            }
            if (ch)
              this.unput(1);
          } else if (ch == "{") {
            ch = this.input();
            if (ch == "$") {
              this.unput(2);
              break;
            }
            if (ch)
              this.unput(1);
          }
        }
        if (ch == '"') {
          return this.tok.T_CONSTANT_ENCAPSED_STRING;
        } else {
          let prefix = 1;
          if (this.yytext[0] === "b" || this.yytext[0] === "B") {
            prefix = 2;
          }
          if (this.yytext.length > 2) {
            this.appendToken(this.tok.T_ENCAPSED_AND_WHITESPACE, this.yytext.length - prefix);
          }
          this.unput(this.yytext.length - prefix);
          this.begin("ST_DOUBLE_QUOTES");
          return this.yytext;
        }
      },
      isDOC_MATCH: function(offset, consumeLeadingSpaces) {
        const prev_ch = this._input[offset - 2];
        if (!newline.includes(prev_ch)) {
          return false;
        }
        let indentation_uses_spaces = false;
        let indentation_uses_tabs = false;
        let indentation = 0;
        let leading_ch = this._input[offset - 1];
        if (this.version >= 703) {
          while (leading_ch === "	" || leading_ch === " ") {
            if (leading_ch === " ") {
              indentation_uses_spaces = true;
            } else if (leading_ch === "	") {
              indentation_uses_tabs = true;
            }
            leading_ch = this._input[offset + indentation];
            indentation++;
          }
          offset = offset + indentation;
          if (newline.includes(this._input[offset - 1])) {
            return false;
          }
        }
        if (this._input.substring(offset - 1, offset - 1 + this.heredoc_label.length) === this.heredoc_label.label) {
          const ch = this._input[offset - 1 + this.heredoc_label.length];
          if ((this.version >= 703 ? valid_after_heredoc_73 : valid_after_heredoc).includes(ch)) {
            if (consumeLeadingSpaces) {
              this.consume(indentation);
              if (indentation_uses_spaces && indentation_uses_tabs) {
                throw new Error("Parse error:  mixing spaces and tabs in ending marker at line " + this.yylineno + " (offset " + this.offset + ")");
              }
            } else {
              this.heredoc_label.indentation = indentation;
              this.heredoc_label.indentation_uses_spaces = indentation_uses_spaces;
              this.heredoc_label.first_encaps_node = true;
            }
            return true;
          }
        }
        return false;
      },
      prematch_ENDOFDOC: function() {
        this.heredoc_label.indentation_uses_spaces = false;
        this.heredoc_label.indentation = 0;
        this.heredoc_label.first_encaps_node = true;
        let offset = this.offset + 1;
        while (offset < this._input.length) {
          if (this.isDOC_MATCH(offset, false)) {
            return;
          }
          if (!newline.includes(this._input[offset - 1])) {
            while (!newline.includes(this._input[offset++]) && offset < this._input.length) {
            }
          }
          offset++;
        }
      },
      matchST_NOWDOC: function() {
        if (this.isDOC_MATCH(this.offset, true)) {
          this.consume(this.heredoc_label.length);
          this.popState();
          return this.tok.T_END_HEREDOC;
        }
        let ch = this._input[this.offset - 1];
        while (this.offset < this.size) {
          if (newline.includes(ch)) {
            ch = this.input();
            if (this.isDOC_MATCH(this.offset, true)) {
              this.unput(1).popState();
              this.appendToken(this.tok.T_END_HEREDOC, this.heredoc_label.length);
              return this.tok.T_ENCAPSED_AND_WHITESPACE;
            }
          } else {
            ch = this.input();
          }
        }
        return this.tok.T_ENCAPSED_AND_WHITESPACE;
      },
      matchST_HEREDOC: function() {
        let ch = this.input();
        if (this.isDOC_MATCH(this.offset, true)) {
          this.consume(this.heredoc_label.length - 1);
          this.popState();
          return this.tok.T_END_HEREDOC;
        }
        while (this.offset < this.size) {
          if (ch === "\\") {
            ch = this.input();
            if (!newline.includes(ch)) {
              ch = this.input();
            }
          }
          if (newline.includes(ch)) {
            ch = this.input();
            if (this.isDOC_MATCH(this.offset, true)) {
              this.unput(1).popState();
              this.appendToken(this.tok.T_END_HEREDOC, this.heredoc_label.length);
              return this.tok.T_ENCAPSED_AND_WHITESPACE;
            }
          } else if (ch === "$") {
            ch = this.input();
            if (ch === "{") {
              this.begin("ST_LOOKING_FOR_VARNAME");
              if (this.yytext.length > 2) {
                this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2);
                this.unput(2);
                return this.tok.T_ENCAPSED_AND_WHITESPACE;
              } else {
                return this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
              }
            } else if (this.is_LABEL_START()) {
              const yyoffset = this.offset;
              const next = this.consume_VARIABLE();
              if (this.yytext.length > this.offset - yyoffset + 2) {
                this.appendToken(next, this.offset - yyoffset + 2);
                this.unput(this.offset - yyoffset + 2);
                return this.tok.T_ENCAPSED_AND_WHITESPACE;
              } else {
                return next;
              }
            }
          } else if (ch === "{") {
            ch = this.input();
            if (ch === "$") {
              this.begin("ST_IN_SCRIPTING");
              if (this.yytext.length > 2) {
                this.appendToken(this.tok.T_CURLY_OPEN, 1);
                this.unput(2);
                return this.tok.T_ENCAPSED_AND_WHITESPACE;
              } else {
                this.unput(1);
                return this.tok.T_CURLY_OPEN;
              }
            }
          } else {
            ch = this.input();
          }
        }
        return this.tok.T_ENCAPSED_AND_WHITESPACE;
      },
      consume_VARIABLE: function() {
        this.consume_LABEL();
        const ch = this.input();
        if (ch == "[") {
          this.unput(1);
          this.begin("ST_VAR_OFFSET");
          return this.tok.T_VARIABLE;
        } else if (ch === "-") {
          if (this.input() === ">") {
            this.input();
            if (this.is_LABEL_START()) {
              this.begin("ST_LOOKING_FOR_PROPERTY");
            }
            this.unput(3);
            return this.tok.T_VARIABLE;
          } else {
            this.unput(2);
          }
        } else {
          if (ch)
            this.unput(1);
        }
        return this.tok.T_VARIABLE;
      },
      matchST_BACKQUOTE: function() {
        let ch = this.input();
        if (ch === "$") {
          ch = this.input();
          if (ch === "{") {
            this.begin("ST_LOOKING_FOR_VARNAME");
            return this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
          } else if (this.is_LABEL_START()) {
            const tok = this.consume_VARIABLE();
            return tok;
          }
        } else if (ch === "{") {
          if (this._input[this.offset] === "$") {
            this.begin("ST_IN_SCRIPTING");
            return this.tok.T_CURLY_OPEN;
          }
        } else if (ch === "`") {
          this.popState();
          return "`";
        }
        while (this.offset < this.size) {
          if (ch === "\\") {
            this.input();
          } else if (ch === "`") {
            this.unput(1);
            this.popState();
            this.appendToken("`", 1);
            break;
          } else if (ch === "$") {
            ch = this.input();
            if (ch === "{") {
              this.begin("ST_LOOKING_FOR_VARNAME");
              if (this.yytext.length > 2) {
                this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2);
                this.unput(2);
                return this.tok.T_ENCAPSED_AND_WHITESPACE;
              } else {
                return this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
              }
            } else if (this.is_LABEL_START()) {
              const yyoffset = this.offset;
              const next = this.consume_VARIABLE();
              if (this.yytext.length > this.offset - yyoffset + 2) {
                this.appendToken(next, this.offset - yyoffset + 2);
                this.unput(this.offset - yyoffset + 2);
                return this.tok.T_ENCAPSED_AND_WHITESPACE;
              } else {
                return next;
              }
            }
            continue;
          } else if (ch === "{") {
            ch = this.input();
            if (ch === "$") {
              this.begin("ST_IN_SCRIPTING");
              if (this.yytext.length > 2) {
                this.appendToken(this.tok.T_CURLY_OPEN, 1);
                this.unput(2);
                return this.tok.T_ENCAPSED_AND_WHITESPACE;
              } else {
                this.unput(1);
                return this.tok.T_CURLY_OPEN;
              }
            }
            continue;
          }
          ch = this.input();
        }
        return this.tok.T_ENCAPSED_AND_WHITESPACE;
      },
      matchST_DOUBLE_QUOTES: function() {
        let ch = this.input();
        if (ch === "$") {
          ch = this.input();
          if (ch === "{") {
            this.begin("ST_LOOKING_FOR_VARNAME");
            return this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
          } else if (this.is_LABEL_START()) {
            const tok = this.consume_VARIABLE();
            return tok;
          }
        } else if (ch === "{") {
          if (this._input[this.offset] === "$") {
            this.begin("ST_IN_SCRIPTING");
            return this.tok.T_CURLY_OPEN;
          }
        } else if (ch === '"') {
          this.popState();
          return '"';
        }
        while (this.offset < this.size) {
          if (ch === "\\") {
            this.input();
          } else if (ch === '"') {
            this.unput(1);
            this.popState();
            this.appendToken('"', 1);
            break;
          } else if (ch === "$") {
            ch = this.input();
            if (ch === "{") {
              this.begin("ST_LOOKING_FOR_VARNAME");
              if (this.yytext.length > 2) {
                this.appendToken(this.tok.T_DOLLAR_OPEN_CURLY_BRACES, 2);
                this.unput(2);
                return this.tok.T_ENCAPSED_AND_WHITESPACE;
              } else {
                return this.tok.T_DOLLAR_OPEN_CURLY_BRACES;
              }
            } else if (this.is_LABEL_START()) {
              const yyoffset = this.offset;
              const next = this.consume_VARIABLE();
              if (this.yytext.length > this.offset - yyoffset + 2) {
                this.appendToken(next, this.offset - yyoffset + 2);
                this.unput(this.offset - yyoffset + 2);
                return this.tok.T_ENCAPSED_AND_WHITESPACE;
              } else {
                return next;
              }
            }
            if (ch)
              this.unput(1);
          } else if (ch === "{") {
            ch = this.input();
            if (ch === "$") {
              this.begin("ST_IN_SCRIPTING");
              if (this.yytext.length > 2) {
                this.appendToken(this.tok.T_CURLY_OPEN, 1);
                this.unput(2);
                return this.tok.T_ENCAPSED_AND_WHITESPACE;
              } else {
                this.unput(1);
                return this.tok.T_CURLY_OPEN;
              }
            }
            if (ch)
              this.unput(1);
          }
          ch = this.input();
        }
        return this.tok.T_ENCAPSED_AND_WHITESPACE;
      }
    };
  }
});

// node_modules/php-parser/src/lexer/tokens.js
var require_tokens = __commonJS({
  "node_modules/php-parser/src/lexer/tokens.js"(exports, module2) {
    "use strict";
    module2.exports = {
      T_STRING: function() {
        const token = this.yytext.toLowerCase();
        let id = this.keywords[token];
        if (typeof id !== "number") {
          if (token === "yield") {
            if (this.version >= 700 && this.tryMatch(" from")) {
              this.consume(5);
              id = this.tok.T_YIELD_FROM;
            } else {
              id = this.tok.T_YIELD;
            }
          } else {
            id = this.tok.T_STRING;
            if (token === "b" || token === "B") {
              const ch = this.input();
              if (ch === '"') {
                return this.ST_DOUBLE_QUOTES();
              } else if (ch === "'") {
                return this.T_CONSTANT_ENCAPSED_STRING();
              } else if (ch) {
                this.unput(1);
              }
            }
          }
        }
        if (id === this.tok.T_ENUM) {
          if (this.version < 801) {
            return this.tok.T_STRING;
          }
          const initial = this.offset;
          let ch = this.input();
          while (ch == " ") {
            ch = this.input();
          }
          let isEnum = false;
          if (this.is_LABEL_START()) {
            while (this.is_LABEL()) {
              ch += this.input();
            }
            const label = ch.slice(0, -1).toLowerCase();
            isEnum = label !== "extends" && label !== "implements";
          }
          this.unput(this.offset - initial);
          return isEnum ? this.tok.T_ENUM : this.tok.T_STRING;
        }
        if (this.offset < this.size && id !== this.tok.T_YIELD_FROM) {
          let ch = this.input();
          if (ch === "\\") {
            id = token === "namespace" ? this.tok.T_NAME_RELATIVE : this.tok.T_NAME_QUALIFIED;
            do {
              if (this._input[this.offset] === "{") {
                this.input();
                break;
              }
              this.consume_LABEL();
              ch = this.input();
            } while (ch === "\\");
          }
          if (ch) {
            this.unput(1);
          }
        }
        return id;
      },
      consume_TOKEN: function() {
        const ch = this._input[this.offset - 1];
        const fn = this.tokenTerminals[ch];
        if (fn) {
          return fn.apply(this, []);
        } else {
          return this.yytext;
        }
      },
      tokenTerminals: {
        $: function() {
          this.offset++;
          if (this.is_LABEL_START()) {
            this.offset--;
            this.consume_LABEL();
            return this.tok.T_VARIABLE;
          } else {
            this.offset--;
            return "$";
          }
        },
        "-": function() {
          const nchar = this._input[this.offset];
          if (nchar === ">") {
            this.begin("ST_LOOKING_FOR_PROPERTY").input();
            return this.tok.T_OBJECT_OPERATOR;
          } else if (nchar === "-") {
            this.input();
            return this.tok.T_DEC;
          } else if (nchar === "=") {
            this.input();
            return this.tok.T_MINUS_EQUAL;
          }
          return "-";
        },
        "\\": function() {
          if (this.offset < this.size) {
            this.input();
            if (this.is_LABEL_START()) {
              let ch;
              do {
                if (this._input[this.offset] === "{") {
                  this.input();
                  break;
                }
                this.consume_LABEL();
                ch = this.input();
              } while (ch === "\\");
              this.unput(1);
              return this.tok.T_NAME_FULLY_QUALIFIED;
            } else {
              this.unput(1);
            }
          }
          return this.tok.T_NS_SEPARATOR;
        },
        "/": function() {
          if (this._input[this.offset] === "=") {
            this.input();
            return this.tok.T_DIV_EQUAL;
          }
          return "/";
        },
        ":": function() {
          if (this._input[this.offset] === ":") {
            this.input();
            return this.tok.T_DOUBLE_COLON;
          } else {
            return ":";
          }
        },
        "(": function() {
          const initial = this.offset;
          this.input();
          if (this.is_TABSPACE()) {
            this.consume_TABSPACE().input();
          }
          if (this.is_LABEL_START()) {
            const yylen = this.yytext.length;
            this.consume_LABEL();
            const castToken = this.yytext.substring(yylen - 1).toLowerCase();
            const castId = this.castKeywords[castToken];
            if (typeof castId === "number") {
              this.input();
              if (this.is_TABSPACE()) {
                this.consume_TABSPACE().input();
              }
              if (this._input[this.offset - 1] === ")") {
                return castId;
              }
            }
          }
          this.unput(this.offset - initial);
          return "(";
        },
        "=": function() {
          const nchar = this._input[this.offset];
          if (nchar === ">") {
            this.input();
            return this.tok.T_DOUBLE_ARROW;
          } else if (nchar === "=") {
            if (this._input[this.offset + 1] === "=") {
              this.consume(2);
              return this.tok.T_IS_IDENTICAL;
            } else {
              this.input();
              return this.tok.T_IS_EQUAL;
            }
          }
          return "=";
        },
        "+": function() {
          const nchar = this._input[this.offset];
          if (nchar === "+") {
            this.input();
            return this.tok.T_INC;
          } else if (nchar === "=") {
            this.input();
            return this.tok.T_PLUS_EQUAL;
          }
          return "+";
        },
        "!": function() {
          if (this._input[this.offset] === "=") {
            if (this._input[this.offset + 1] === "=") {
              this.consume(2);
              return this.tok.T_IS_NOT_IDENTICAL;
            } else {
              this.input();
              return this.tok.T_IS_NOT_EQUAL;
            }
          }
          return "!";
        },
        "?": function() {
          if (this.version >= 700 && this._input[this.offset] === "?") {
            if (this.version >= 704 && this._input[this.offset + 1] === "=") {
              this.consume(2);
              return this.tok.T_COALESCE_EQUAL;
            } else {
              this.input();
              return this.tok.T_COALESCE;
            }
          }
          if (this.version >= 800 && this._input[this.offset] === "-" && this._input[this.offset + 1] === ">") {
            this.consume(2);
            return this.tok.T_NULLSAFE_OBJECT_OPERATOR;
          }
          return "?";
        },
        "<": function() {
          let nchar = this._input[this.offset];
          if (nchar === "<") {
            nchar = this._input[this.offset + 1];
            if (nchar === "=") {
              this.consume(2);
              return this.tok.T_SL_EQUAL;
            } else if (nchar === "<") {
              if (this.is_HEREDOC()) {
                return this.tok.T_START_HEREDOC;
              }
            }
            this.input();
            return this.tok.T_SL;
          } else if (nchar === "=") {
            this.input();
            if (this.version >= 700 && this._input[this.offset] === ">") {
              this.input();
              return this.tok.T_SPACESHIP;
            } else {
              return this.tok.T_IS_SMALLER_OR_EQUAL;
            }
          } else if (nchar === ">") {
            this.input();
            return this.tok.T_IS_NOT_EQUAL;
          }
          return "<";
        },
        ">": function() {
          let nchar = this._input[this.offset];
          if (nchar === "=") {
            this.input();
            return this.tok.T_IS_GREATER_OR_EQUAL;
          } else if (nchar === ">") {
            nchar = this._input[this.offset + 1];
            if (nchar === "=") {
              this.consume(2);
              return this.tok.T_SR_EQUAL;
            } else {
              this.input();
              return this.tok.T_SR;
            }
          }
          return ">";
        },
        "*": function() {
          const nchar = this._input[this.offset];
          if (nchar === "=") {
            this.input();
            return this.tok.T_MUL_EQUAL;
          } else if (nchar === "*") {
            this.input();
            if (this._input[this.offset] === "=") {
              this.input();
              return this.tok.T_POW_EQUAL;
            } else {
              return this.tok.T_POW;
            }
          }
          return "*";
        },
        ".": function() {
          const nchar = this._input[this.offset];
          if (nchar === "=") {
            this.input();
            return this.tok.T_CONCAT_EQUAL;
          } else if (nchar === "." && this._input[this.offset + 1] === ".") {
            this.consume(2);
            return this.tok.T_ELLIPSIS;
          }
          return ".";
        },
        "%": function() {
          if (this._input[this.offset] === "=") {
            this.input();
            return this.tok.T_MOD_EQUAL;
          }
          return "%";
        },
        "&": function() {
          const nchar = this._input[this.offset];
          if (nchar === "=") {
            this.input();
            return this.tok.T_AND_EQUAL;
          } else if (nchar === "&") {
            this.input();
            return this.tok.T_BOOLEAN_AND;
          }
          return "&";
        },
        "|": function() {
          const nchar = this._input[this.offset];
          if (nchar === "=") {
            this.input();
            return this.tok.T_OR_EQUAL;
          } else if (nchar === "|") {
            this.input();
            return this.tok.T_BOOLEAN_OR;
          }
          return "|";
        },
        "^": function() {
          if (this._input[this.offset] === "=") {
            this.input();
            return this.tok.T_XOR_EQUAL;
          }
          return "^";
        }
      }
    };
  }
});

// node_modules/php-parser/src/lexer/utils.js
var require_utils = __commonJS({
  "node_modules/php-parser/src/lexer/utils.js"(exports, module2) {
    "use strict";
    var tokens = ";:,.\\[]()|^&+-/*=%!~$<>?@";
    module2.exports = {
      is_NUM: function() {
        const ch = this._input.charCodeAt(this.offset - 1);
        return ch > 47 && ch < 58 || ch === 95;
      },
      is_NUM_START: function() {
        const ch = this._input.charCodeAt(this.offset - 1);
        return ch > 47 && ch < 58;
      },
      is_LABEL: function() {
        const ch = this._input.charCodeAt(this.offset - 1);
        return ch > 96 && ch < 123 || ch > 64 && ch < 91 || ch === 95 || ch > 47 && ch < 58 || ch > 126;
      },
      is_LABEL_START: function() {
        const ch = this._input.charCodeAt(this.offset - 1);
        if (ch > 64 && ch < 91)
          return true;
        if (ch > 96 && ch < 123)
          return true;
        if (ch === 95)
          return true;
        if (ch > 126)
          return true;
        return false;
      },
      consume_LABEL: function() {
        while (this.offset < this.size) {
          const ch = this.input();
          if (!this.is_LABEL()) {
            if (ch)
              this.unput(1);
            break;
          }
        }
        return this;
      },
      is_TOKEN: function() {
        const ch = this._input[this.offset - 1];
        return tokens.indexOf(ch) !== -1;
      },
      is_WHITESPACE: function() {
        const ch = this._input[this.offset - 1];
        return ch === " " || ch === "	" || ch === "\n" || ch === "\r";
      },
      is_TABSPACE: function() {
        const ch = this._input[this.offset - 1];
        return ch === " " || ch === "	";
      },
      consume_TABSPACE: function() {
        while (this.offset < this.size) {
          const ch = this.input();
          if (!this.is_TABSPACE()) {
            if (ch)
              this.unput(1);
            break;
          }
        }
        return this;
      },
      is_HEX: function() {
        const ch = this._input.charCodeAt(this.offset - 1);
        if (ch > 47 && ch < 58)
          return true;
        if (ch > 64 && ch < 71)
          return true;
        if (ch > 96 && ch < 103)
          return true;
        if (ch === 95)
          return true;
        return false;
      }
    };
  }
});

// node_modules/php-parser/src/lexer.js
var require_lexer = __commonJS({
  "node_modules/php-parser/src/lexer.js"(exports, module2) {
    "use strict";
    var Lexer = function(engine) {
      this.engine = engine;
      this.tok = this.engine.tokens.names;
      this.EOF = 1;
      this.debug = false;
      this.all_tokens = true;
      this.comment_tokens = false;
      this.mode_eval = false;
      this.asp_tags = false;
      this.short_tags = false;
      this.version = 801;
      this.yyprevcol = 0;
      this.keywords = {
        __class__: this.tok.T_CLASS_C,
        __trait__: this.tok.T_TRAIT_C,
        __function__: this.tok.T_FUNC_C,
        __method__: this.tok.T_METHOD_C,
        __line__: this.tok.T_LINE,
        __file__: this.tok.T_FILE,
        __dir__: this.tok.T_DIR,
        __namespace__: this.tok.T_NS_C,
        exit: this.tok.T_EXIT,
        die: this.tok.T_EXIT,
        function: this.tok.T_FUNCTION,
        const: this.tok.T_CONST,
        return: this.tok.T_RETURN,
        try: this.tok.T_TRY,
        catch: this.tok.T_CATCH,
        finally: this.tok.T_FINALLY,
        throw: this.tok.T_THROW,
        if: this.tok.T_IF,
        elseif: this.tok.T_ELSEIF,
        endif: this.tok.T_ENDIF,
        else: this.tok.T_ELSE,
        while: this.tok.T_WHILE,
        endwhile: this.tok.T_ENDWHILE,
        do: this.tok.T_DO,
        for: this.tok.T_FOR,
        endfor: this.tok.T_ENDFOR,
        foreach: this.tok.T_FOREACH,
        endforeach: this.tok.T_ENDFOREACH,
        declare: this.tok.T_DECLARE,
        enddeclare: this.tok.T_ENDDECLARE,
        instanceof: this.tok.T_INSTANCEOF,
        as: this.tok.T_AS,
        switch: this.tok.T_SWITCH,
        endswitch: this.tok.T_ENDSWITCH,
        case: this.tok.T_CASE,
        default: this.tok.T_DEFAULT,
        break: this.tok.T_BREAK,
        continue: this.tok.T_CONTINUE,
        goto: this.tok.T_GOTO,
        echo: this.tok.T_ECHO,
        print: this.tok.T_PRINT,
        class: this.tok.T_CLASS,
        interface: this.tok.T_INTERFACE,
        trait: this.tok.T_TRAIT,
        enum: this.tok.T_ENUM,
        extends: this.tok.T_EXTENDS,
        implements: this.tok.T_IMPLEMENTS,
        new: this.tok.T_NEW,
        clone: this.tok.T_CLONE,
        var: this.tok.T_VAR,
        eval: this.tok.T_EVAL,
        include: this.tok.T_INCLUDE,
        include_once: this.tok.T_INCLUDE_ONCE,
        require: this.tok.T_REQUIRE,
        require_once: this.tok.T_REQUIRE_ONCE,
        namespace: this.tok.T_NAMESPACE,
        use: this.tok.T_USE,
        insteadof: this.tok.T_INSTEADOF,
        global: this.tok.T_GLOBAL,
        isset: this.tok.T_ISSET,
        empty: this.tok.T_EMPTY,
        __halt_compiler: this.tok.T_HALT_COMPILER,
        static: this.tok.T_STATIC,
        abstract: this.tok.T_ABSTRACT,
        final: this.tok.T_FINAL,
        private: this.tok.T_PRIVATE,
        protected: this.tok.T_PROTECTED,
        public: this.tok.T_PUBLIC,
        unset: this.tok.T_UNSET,
        list: this.tok.T_LIST,
        array: this.tok.T_ARRAY,
        callable: this.tok.T_CALLABLE,
        or: this.tok.T_LOGICAL_OR,
        and: this.tok.T_LOGICAL_AND,
        xor: this.tok.T_LOGICAL_XOR,
        match: this.tok.T_MATCH,
        readonly: this.tok.T_READ_ONLY
      };
      this.castKeywords = {
        int: this.tok.T_INT_CAST,
        integer: this.tok.T_INT_CAST,
        real: this.tok.T_DOUBLE_CAST,
        double: this.tok.T_DOUBLE_CAST,
        float: this.tok.T_DOUBLE_CAST,
        string: this.tok.T_STRING_CAST,
        binary: this.tok.T_STRING_CAST,
        array: this.tok.T_ARRAY_CAST,
        object: this.tok.T_OBJECT_CAST,
        bool: this.tok.T_BOOL_CAST,
        boolean: this.tok.T_BOOL_CAST,
        unset: this.tok.T_UNSET_CAST
      };
    };
    Lexer.prototype.setInput = function(input) {
      this._input = input;
      this.size = input.length;
      this.yylineno = 1;
      this.offset = 0;
      this.yyprevcol = 0;
      this.yytext = "";
      this.yylloc = {
        first_offset: 0,
        first_line: 1,
        first_column: 0,
        prev_offset: 0,
        prev_line: 1,
        prev_column: 0,
        last_line: 1,
        last_column: 0
      };
      this.tokens = [];
      if (this.version > 703) {
        this.keywords.fn = this.tok.T_FN;
      } else {
        delete this.keywords.fn;
      }
      this.done = this.offset >= this.size;
      if (!this.all_tokens && this.mode_eval) {
        this.conditionStack = ["INITIAL"];
        this.begin("ST_IN_SCRIPTING");
      } else {
        this.conditionStack = [];
        this.begin("INITIAL");
      }
      this.heredoc_label = {
        label: "",
        length: 0,
        indentation: 0,
        indentation_uses_spaces: false,
        finished: false,
        first_encaps_node: false,
        toString: function() {
          this.label;
        }
      };
      return this;
    };
    Lexer.prototype.input = function() {
      const ch = this._input[this.offset];
      if (!ch)
        return "";
      this.yytext += ch;
      this.offset++;
      if (ch === "\r" && this._input[this.offset] === "\n") {
        this.yytext += "\n";
        this.offset++;
      }
      if (ch === "\n" || ch === "\r") {
        this.yylloc.last_line = ++this.yylineno;
        this.yyprevcol = this.yylloc.last_column;
        this.yylloc.last_column = 0;
      } else {
        this.yylloc.last_column++;
      }
      return ch;
    };
    Lexer.prototype.unput = function(size) {
      if (size === 1) {
        this.offset--;
        if (this._input[this.offset] === "\n" && this._input[this.offset - 1] === "\r") {
          this.offset--;
          size++;
        }
        if (this._input[this.offset] === "\r" || this._input[this.offset] === "\n") {
          this.yylloc.last_line--;
          this.yylineno--;
          this.yylloc.last_column = this.yyprevcol;
        } else {
          this.yylloc.last_column--;
        }
        this.yytext = this.yytext.substring(0, this.yytext.length - size);
      } else if (size > 0) {
        this.offset -= size;
        if (size < this.yytext.length) {
          this.yytext = this.yytext.substring(0, this.yytext.length - size);
          this.yylloc.last_line = this.yylloc.first_line;
          this.yylloc.last_column = this.yyprevcol = this.yylloc.first_column;
          for (let i = 0; i < this.yytext.length; i++) {
            let c = this.yytext[i];
            if (c === "\r") {
              c = this.yytext[++i];
              this.yyprevcol = this.yylloc.last_column;
              this.yylloc.last_line++;
              this.yylloc.last_column = 0;
              if (c !== "\n") {
                if (c === "\r") {
                  this.yylloc.last_line++;
                } else {
                  this.yylloc.last_column++;
                }
              }
            } else if (c === "\n") {
              this.yyprevcol = this.yylloc.last_column;
              this.yylloc.last_line++;
              this.yylloc.last_column = 0;
            } else {
              this.yylloc.last_column++;
            }
          }
          this.yylineno = this.yylloc.last_line;
        } else {
          this.yytext = "";
          this.yylloc.last_line = this.yylineno = this.yylloc.first_line;
          this.yylloc.last_column = this.yylloc.first_column;
        }
      }
      return this;
    };
    Lexer.prototype.tryMatch = function(text) {
      return text === this.ahead(text.length);
    };
    Lexer.prototype.tryMatchCaseless = function(text) {
      return text === this.ahead(text.length).toLowerCase();
    };
    Lexer.prototype.ahead = function(size) {
      let text = this._input.substring(this.offset, this.offset + size);
      if (text[text.length - 1] === "\r" && this._input[this.offset + size + 1] === "\n") {
        text += "\n";
      }
      return text;
    };
    Lexer.prototype.consume = function(size) {
      for (let i = 0; i < size; i++) {
        const ch = this._input[this.offset];
        if (!ch)
          break;
        this.yytext += ch;
        this.offset++;
        if (ch === "\r" && this._input[this.offset] === "\n") {
          this.yytext += "\n";
          this.offset++;
          i++;
        }
        if (ch === "\n" || ch === "\r") {
          this.yylloc.last_line = ++this.yylineno;
          this.yyprevcol = this.yylloc.last_column;
          this.yylloc.last_column = 0;
        } else {
          this.yylloc.last_column++;
        }
      }
      return this;
    };
    Lexer.prototype.getState = function() {
      return {
        yytext: this.yytext,
        offset: this.offset,
        yylineno: this.yylineno,
        yyprevcol: this.yyprevcol,
        yylloc: {
          first_offset: this.yylloc.first_offset,
          first_line: this.yylloc.first_line,
          first_column: this.yylloc.first_column,
          last_line: this.yylloc.last_line,
          last_column: this.yylloc.last_column
        },
        heredoc_label: this.heredoc_label
      };
    };
    Lexer.prototype.setState = function(state) {
      this.yytext = state.yytext;
      this.offset = state.offset;
      this.yylineno = state.yylineno;
      this.yyprevcol = state.yyprevcol;
      this.yylloc = state.yylloc;
      if (state.heredoc_label) {
        this.heredoc_label = state.heredoc_label;
      }
      return this;
    };
    Lexer.prototype.appendToken = function(value, ahead) {
      this.tokens.push([value, ahead]);
      return this;
    };
    Lexer.prototype.lex = function() {
      this.yylloc.prev_offset = this.offset;
      this.yylloc.prev_line = this.yylloc.last_line;
      this.yylloc.prev_column = this.yylloc.last_column;
      let token = this.next() || this.lex();
      if (!this.all_tokens) {
        while (token === this.tok.T_WHITESPACE || !this.comment_tokens && (token === this.tok.T_COMMENT || token === this.tok.T_DOC_COMMENT) || token === this.tok.T_OPEN_TAG) {
          token = this.next() || this.lex();
        }
        if (token == this.tok.T_OPEN_TAG_WITH_ECHO) {
          return this.tok.T_ECHO;
        } else if (token === this.tok.T_CLOSE_TAG) {
          return ";";
        }
      }
      if (!this.yylloc.prev_offset) {
        this.yylloc.prev_offset = this.yylloc.first_offset;
        this.yylloc.prev_line = this.yylloc.first_line;
        this.yylloc.prev_column = this.yylloc.first_column;
      }
      return token;
    };
    Lexer.prototype.begin = function(condition) {
      this.conditionStack.push(condition);
      this.curCondition = condition;
      this.stateCb = this["match" + condition];
      if (typeof this.stateCb !== "function") {
        throw new Error('Undefined condition state "' + condition + '"');
      }
      return this;
    };
    Lexer.prototype.popState = function() {
      const n = this.conditionStack.length - 1;
      const condition = n > 0 ? this.conditionStack.pop() : this.conditionStack[0];
      this.curCondition = this.conditionStack[this.conditionStack.length - 1];
      this.stateCb = this["match" + this.curCondition];
      if (typeof this.stateCb !== "function") {
        throw new Error('Undefined condition state "' + this.curCondition + '"');
      }
      return condition;
    };
    Lexer.prototype.next = function() {
      let token;
      if (!this._input) {
        this.done = true;
      }
      this.yylloc.first_offset = this.offset;
      this.yylloc.first_line = this.yylloc.last_line;
      this.yylloc.first_column = this.yylloc.last_column;
      this.yytext = "";
      if (this.done) {
        this.yylloc.prev_offset = this.yylloc.first_offset;
        this.yylloc.prev_line = this.yylloc.first_line;
        this.yylloc.prev_column = this.yylloc.first_column;
        return this.EOF;
      }
      if (this.tokens.length > 0) {
        token = this.tokens.shift();
        if (typeof token[1] === "object") {
          this.setState(token[1]);
        } else {
          this.consume(token[1]);
        }
        token = token[0];
      } else {
        token = this.stateCb.apply(this, []);
      }
      if (this.offset >= this.size && this.tokens.length === 0) {
        this.done = true;
      }
      if (this.debug) {
        let tName = token;
        if (typeof tName === "number") {
          tName = this.engine.tokens.values[tName];
        } else {
          tName = '"' + tName + '"';
        }
        const e = new Error(tName + "	from " + this.yylloc.first_line + "," + this.yylloc.first_column + "	 - to " + this.yylloc.last_line + "," + this.yylloc.last_column + '	"' + this.yytext + '"');
        console.error(e.stack);
      }
      return token;
    };
    [
      require_attribute(),
      require_comments(),
      require_initial(),
      require_numbers(),
      require_property(),
      require_scripting(),
      require_strings(),
      require_tokens(),
      require_utils()
    ].forEach(function(ext) {
      for (const k in ext) {
        Lexer.prototype[k] = ext[k];
      }
    });
    module2.exports = Lexer;
  }
});

// node_modules/php-parser/src/ast/position.js
var require_position = __commonJS({
  "node_modules/php-parser/src/ast/position.js"(exports, module2) {
    "use strict";
    var Position14 = function(line, column, offset) {
      this.line = line;
      this.column = column;
      this.offset = offset;
    };
    module2.exports = Position14;
  }
});

// node_modules/php-parser/src/parser/array.js
var require_array = __commonJS({
  "node_modules/php-parser/src/parser/array.js"(exports, module2) {
    "use strict";
    module2.exports = {
      read_array: function() {
        let expect = null;
        let shortForm = false;
        const result = this.node("array");
        if (this.token === this.tok.T_ARRAY) {
          this.next().expect("(");
          expect = ")";
        } else {
          shortForm = true;
          expect = "]";
        }
        let items = [];
        if (this.next().token !== expect) {
          items = this.read_array_pair_list(shortForm);
        }
        this.expect(expect);
        this.next();
        return result(shortForm, items);
      },
      read_array_pair_list: function(shortForm) {
        const self = this;
        return this.read_list(function() {
          return self.read_array_pair(shortForm);
        }, ",", true);
      },
      read_array_pair: function(shortForm) {
        if (!shortForm && this.token === ")" || shortForm && this.token === "]") {
          return;
        }
        if (this.token === ",") {
          return this.node("noop")();
        }
        const entry = this.node("entry");
        let key = null;
        let value = null;
        let byRef = false;
        let unpack = false;
        if (this.token === "&") {
          this.next();
          byRef = true;
          value = this.read_variable(true, false);
        } else if (this.token === this.tok.T_ELLIPSIS && this.version >= 704) {
          this.next();
          if (this.token === "&") {
            this.error();
          }
          unpack = true;
          value = this.read_expr();
        } else {
          const expr = this.read_expr();
          if (this.token === this.tok.T_DOUBLE_ARROW) {
            this.next();
            key = expr;
            if (this.token === "&") {
              this.next();
              byRef = true;
              value = this.read_variable(true, false);
            } else {
              value = this.read_expr();
            }
          } else {
            value = expr;
          }
        }
        return entry(key, value, byRef, unpack);
      }
    };
  }
});

// node_modules/php-parser/src/parser/class.js
var require_class = __commonJS({
  "node_modules/php-parser/src/parser/class.js"(exports, module2) {
    "use strict";
    module2.exports = {
      read_class_declaration_statement: function(attrs) {
        const result = this.node("class");
        const flag = this.read_class_modifiers();
        if (this.token !== this.tok.T_CLASS) {
          this.error(this.tok.T_CLASS);
          this.next();
          return null;
        }
        this.next().expect(this.tok.T_STRING);
        let propName = this.node("identifier");
        const name = this.text();
        this.next();
        propName = propName(name);
        const propExtends = this.read_extends_from();
        const propImplements = this.read_implements_list();
        this.expect("{");
        const body = this.next().read_class_body(true, false);
        const node = result(propName, propExtends, propImplements, body, flag);
        if (attrs)
          node.attrGroups = attrs;
        return node;
      },
      read_class_modifiers: function() {
        return [0, 0, this.read_class_modifier()];
      },
      read_class_modifier: function() {
        const result = 0;
        if (this.token === this.tok.T_ABSTRACT) {
          this.next();
          return 1;
        } else if (this.token === this.tok.T_FINAL) {
          this.next();
          return 2;
        }
        return result;
      },
      read_class_body: function(allow_variables, allow_enum_cases) {
        let result = [];
        let attrs = [];
        while (this.token !== this.EOF && this.token !== "}") {
          if (this.token === this.tok.T_COMMENT) {
            result.push(this.read_comment());
            continue;
          }
          if (this.token === this.tok.T_DOC_COMMENT) {
            result.push(this.read_doc_comment());
            continue;
          }
          if (this.token === this.tok.T_USE) {
            result = result.concat(this.read_trait_use_statement());
            continue;
          }
          if (allow_enum_cases && this.token === this.tok.T_CASE) {
            const enumcase = this.read_enum_case();
            if (this.expect(";")) {
              this.next();
            }
            result = result.concat(enumcase);
            continue;
          }
          if (this.token === this.tok.T_ATTRIBUTE) {
            attrs = this.read_attr_list();
          }
          const locStart = this.position();
          const flags = this.read_member_flags(false);
          if (this.token === this.tok.T_CONST) {
            const constants = this.read_constant_list(flags, attrs);
            if (this.expect(";")) {
              this.next();
            }
            result = result.concat(constants);
            continue;
          }
          if (allow_variables && this.token === this.tok.T_VAR) {
            this.next().expect(this.tok.T_VARIABLE);
            flags[0] = null;
            flags[1] = 0;
          }
          if (this.token === this.tok.T_FUNCTION) {
            result.push(this.read_function(false, flags, attrs, locStart));
            attrs = [];
          } else if (allow_variables && (this.token === this.tok.T_VARIABLE || this.version >= 801 && this.token === this.tok.T_READ_ONLY || this.version >= 704 && (this.token === "?" || this.token === this.tok.T_CALLABLE || this.token === this.tok.T_ARRAY || this.token === this.tok.T_NS_SEPARATOR || this.token === this.tok.T_STRING || this.token === this.tok.T_NAMESPACE))) {
            const variables = this.read_variable_list(flags, attrs);
            attrs = [];
            this.expect(";");
            this.next();
            result = result.concat(variables);
          } else {
            this.error([
              this.tok.T_CONST,
              ...allow_variables ? [this.tok.T_VARIABLE] : [],
              ...allow_enum_cases ? [this.tok.T_CASE] : [],
              this.tok.T_FUNCTION
            ]);
            this.next();
          }
        }
        this.expect("}");
        this.next();
        return result;
      },
      read_variable_list: function(flags, attrs) {
        const result = this.node("propertystatement");
        const properties = this.read_list(function read_variable_declaration() {
          const result2 = this.node("property");
          let readonly = false;
          if (this.token === this.tok.T_READ_ONLY) {
            readonly = true;
            this.next();
          }
          const [nullable, type] = this.read_optional_type();
          this.expect(this.tok.T_VARIABLE);
          let propName = this.node("identifier");
          const name = this.text().substring(1);
          this.next();
          propName = propName(name);
          if (this.token === ";" || this.token === ",") {
            return result2(propName, null, readonly, nullable, type, attrs || []);
          } else if (this.token === "=") {
            return result2(propName, this.next().read_expr(), readonly, nullable, type, attrs || []);
          } else {
            this.expect([",", ";", "="]);
            return result2(propName, null, nullable, type, attrs || []);
          }
        }, ",");
        return result(null, properties, flags);
      },
      read_constant_list: function(flags, attrs) {
        if (this.expect(this.tok.T_CONST)) {
          this.next();
        }
        const result = this.node("classconstant");
        const items = this.read_list(function read_constant_declaration() {
          const result2 = this.node("constant");
          let constName = null;
          let value = null;
          if (this.token === this.tok.T_STRING || this.version >= 700 && this.is("IDENTIFIER")) {
            constName = this.node("identifier");
            const name = this.text();
            this.next();
            constName = constName(name);
          } else {
            this.expect("IDENTIFIER");
          }
          if (this.expect("=")) {
            value = this.next().read_expr();
          }
          return result2(constName, value);
        }, ",");
        return result(null, items, flags, attrs || []);
      },
      read_member_flags: function(asInterface) {
        const result = [-1, -1, -1];
        if (this.is("T_MEMBER_FLAGS")) {
          let idx = 0, val = 0;
          do {
            switch (this.token) {
              case this.tok.T_PUBLIC:
                idx = 0;
                val = 0;
                break;
              case this.tok.T_PROTECTED:
                idx = 0;
                val = 1;
                break;
              case this.tok.T_PRIVATE:
                idx = 0;
                val = 2;
                break;
              case this.tok.T_STATIC:
                idx = 1;
                val = 1;
                break;
              case this.tok.T_ABSTRACT:
                idx = 2;
                val = 1;
                break;
              case this.tok.T_FINAL:
                idx = 2;
                val = 2;
                break;
            }
            if (asInterface) {
              if (idx == 0 && val == 2) {
                this.expect([this.tok.T_PUBLIC, this.tok.T_PROTECTED]);
                val = -1;
              } else if (idx == 2 && val == 1) {
                this.error();
                val = -1;
              }
            }
            if (result[idx] !== -1) {
              this.error();
            } else if (val !== -1) {
              result[idx] = val;
            }
          } while (this.next().is("T_MEMBER_FLAGS"));
        }
        if (result[1] == -1)
          result[1] = 0;
        if (result[2] == -1)
          result[2] = 0;
        return result;
      },
      read_optional_type: function() {
        let nullable = false;
        if (this.token === "?") {
          nullable = true;
          this.next();
        }
        let type = this.read_types();
        if (nullable && !type) {
          this.raiseError("Expecting a type definition combined with nullable operator");
        }
        if (!nullable && !type) {
          return [false, null];
        }
        if (this.token === "|") {
          type = [type];
          do {
            this.next();
            const variant = this.read_type();
            if (!variant) {
              this.raiseError("Expecting a type definition");
              break;
            }
            type.push(variant);
          } while (this.token === "|");
        }
        return [nullable, type];
      },
      read_interface_declaration_statement: function(attrs) {
        const result = this.node("interface");
        if (this.token !== this.tok.T_INTERFACE) {
          this.error(this.tok.T_INTERFACE);
          this.next();
          return null;
        }
        this.next().expect(this.tok.T_STRING);
        let propName = this.node("identifier");
        const name = this.text();
        this.next();
        propName = propName(name);
        const propExtends = this.read_interface_extends_list();
        this.expect("{");
        const body = this.next().read_interface_body();
        return result(propName, propExtends, body, attrs || []);
      },
      read_interface_body: function() {
        let result = [], attrs = [];
        while (this.token !== this.EOF && this.token !== "}") {
          if (this.token === this.tok.T_COMMENT) {
            result.push(this.read_comment());
            continue;
          }
          if (this.token === this.tok.T_DOC_COMMENT) {
            result.push(this.read_doc_comment());
            continue;
          }
          const locStart = this.position();
          attrs = this.read_attr_list();
          const flags = this.read_member_flags(true);
          if (this.token == this.tok.T_CONST) {
            const constants = this.read_constant_list(flags, attrs);
            if (this.expect(";")) {
              this.next();
            }
            result = result.concat(constants);
            attrs = [];
          } else if (this.token === this.tok.T_FUNCTION) {
            const method = this.read_function_declaration(2, flags, attrs, locStart);
            method.parseFlags(flags);
            result.push(method);
            if (this.expect(";")) {
              this.next();
            }
            attrs = [];
          } else {
            this.error([this.tok.T_CONST, this.tok.T_FUNCTION]);
            this.next();
          }
        }
        if (this.expect("}")) {
          this.next();
        }
        return result;
      },
      read_trait_declaration_statement: function() {
        const result = this.node("trait");
        if (this.token !== this.tok.T_TRAIT) {
          this.error(this.tok.T_TRAIT);
          this.next();
          return null;
        }
        this.next().expect(this.tok.T_STRING);
        let propName = this.node("identifier");
        const name = this.text();
        this.next();
        propName = propName(name);
        this.expect("{");
        const body = this.next().read_class_body(true, false);
        return result(propName, body);
      },
      read_trait_use_statement: function() {
        const node = this.node("traituse");
        this.expect(this.tok.T_USE) && this.next();
        const traits = [this.read_namespace_name()];
        let adaptations = null;
        while (this.token === ",") {
          traits.push(this.next().read_namespace_name());
        }
        if (this.token === "{") {
          adaptations = [];
          while (this.next().token !== this.EOF) {
            if (this.token === "}")
              break;
            adaptations.push(this.read_trait_use_alias());
            this.expect(";");
          }
          if (this.expect("}")) {
            this.next();
          }
        } else {
          if (this.expect(";")) {
            this.next();
          }
        }
        return node(traits, adaptations);
      },
      read_trait_use_alias: function() {
        const node = this.node();
        let trait = null;
        let method;
        if (this.is("IDENTIFIER")) {
          method = this.node("identifier");
          const methodName = this.text();
          this.next();
          method = method(methodName);
        } else {
          method = this.read_namespace_name();
          if (this.token === this.tok.T_DOUBLE_COLON) {
            this.next();
            if (this.token === this.tok.T_STRING || this.version >= 700 && this.is("IDENTIFIER")) {
              trait = method;
              method = this.node("identifier");
              const methodName = this.text();
              this.next();
              method = method(methodName);
            } else {
              this.expect(this.tok.T_STRING);
            }
          } else {
            method = method.name;
          }
        }
        if (this.token === this.tok.T_INSTEADOF) {
          return node("traitprecedence", trait, method, this.next().read_name_list());
        } else if (this.token === this.tok.T_AS) {
          let flags = null;
          let alias = null;
          if (this.next().is("T_MEMBER_FLAGS")) {
            flags = this.read_member_flags();
          }
          if (this.token === this.tok.T_STRING || this.version >= 700 && this.is("IDENTIFIER")) {
            alias = this.node("identifier");
            const name = this.text();
            this.next();
            alias = alias(name);
          } else if (flags === false) {
            this.expect(this.tok.T_STRING);
          }
          return node("traitalias", trait, method, alias, flags);
        }
        this.expect([this.tok.T_AS, this.tok.T_INSTEADOF]);
        return node("traitalias", trait, method, null, null);
      }
    };
  }
});

// node_modules/php-parser/src/parser/comment.js
var require_comment = __commonJS({
  "node_modules/php-parser/src/parser/comment.js"(exports, module2) {
    "use strict";
    module2.exports = {
      read_comment: function() {
        const text = this.text();
        let result = this.ast.prepare(text.substring(0, 2) === "/*" ? "commentblock" : "commentline", null, this);
        const offset = this.lexer.yylloc.first_offset;
        const prev = this.prev;
        this.prev = [
          this.lexer.yylloc.last_line,
          this.lexer.yylloc.last_column,
          this.lexer.offset
        ];
        this.lex();
        result = result(text);
        result.offset = offset;
        this.prev = prev;
        return result;
      },
      read_doc_comment: function() {
        let result = this.ast.prepare("commentblock", null, this);
        const offset = this.lexer.yylloc.first_offset;
        const text = this.text();
        const prev = this.prev;
        this.prev = [
          this.lexer.yylloc.last_line,
          this.lexer.yylloc.last_column,
          this.lexer.offset
        ];
        this.lex();
        result = result(text);
        result.offset = offset;
        this.prev = prev;
        return result;
      }
    };
  }
});

// node_modules/php-parser/src/parser/expr.js
var require_expr = __commonJS({
  "node_modules/php-parser/src/parser/expr.js"(exports, module2) {
    "use strict";
    module2.exports = {
      read_expr: function(expr) {
        const result = this.node();
        if (this.token === "@") {
          if (!expr) {
            expr = this.next().read_expr();
          }
          return result("silent", expr);
        }
        if (!expr) {
          expr = this.read_expr_item();
        }
        if (this.token === "|") {
          return result("bin", "|", expr, this.next().read_expr());
        }
        if (this.token === "&") {
          return result("bin", "&", expr, this.next().read_expr());
        }
        if (this.token === "^") {
          return result("bin", "^", expr, this.next().read_expr());
        }
        if (this.token === ".") {
          return result("bin", ".", expr, this.next().read_expr());
        }
        if (this.token === "+") {
          return result("bin", "+", expr, this.next().read_expr());
        }
        if (this.token === "-") {
          return result("bin", "-", expr, this.next().read_expr());
        }
        if (this.token === "*") {
          return result("bin", "*", expr, this.next().read_expr());
        }
        if (this.token === "/") {
          return result("bin", "/", expr, this.next().read_expr());
        }
        if (this.token === "%") {
          return result("bin", "%", expr, this.next().read_expr());
        }
        if (this.token === this.tok.T_POW) {
          return result("bin", "**", expr, this.next().read_expr());
        }
        if (this.token === this.tok.T_SL) {
          return result("bin", "<<", expr, this.next().read_expr());
        }
        if (this.token === this.tok.T_SR) {
          return result("bin", ">>", expr, this.next().read_expr());
        }
        if (this.token === this.tok.T_BOOLEAN_OR) {
          return result("bin", "||", expr, this.next().read_expr());
        }
        if (this.token === this.tok.T_LOGICAL_OR) {
          return result("bin", "or", expr, this.next().read_expr());
        }
        if (this.token === this.tok.T_BOOLEAN_AND) {
          return result("bin", "&&", expr, this.next().read_expr());
        }
        if (this.token === this.tok.T_LOGICAL_AND) {
          return result("bin", "and", expr, this.next().read_expr());
        }
        if (this.token === this.tok.T_LOGICAL_XOR) {
          return result("bin", "xor", expr, this.next().read_expr());
        }
        if (this.token === this.tok.T_IS_IDENTICAL) {
          return result("bin", "===", expr, this.next().read_expr());
        }
        if (this.token === this.tok.T_IS_NOT_IDENTICAL) {
          return result("bin", "!==", expr, this.next().read_expr());
        }
        if (this.token === this.tok.T_IS_EQUAL) {
          return result("bin", "==", expr, this.next().read_expr());
        }
        if (this.token === this.tok.T_IS_NOT_EQUAL) {
          return result("bin", "!=", expr, this.next().read_expr());
        }
        if (this.token === "<") {
          return result("bin", "<", expr, this.next().read_expr());
        }
        if (this.token === ">") {
          return result("bin", ">", expr, this.next().read_expr());
        }
        if (this.token === this.tok.T_IS_SMALLER_OR_EQUAL) {
          return result("bin", "<=", expr, this.next().read_expr());
        }
        if (this.token === this.tok.T_IS_GREATER_OR_EQUAL) {
          return result("bin", ">=", expr, this.next().read_expr());
        }
        if (this.token === this.tok.T_SPACESHIP) {
          return result("bin", "<=>", expr, this.next().read_expr());
        }
        if (this.token === this.tok.T_INSTANCEOF) {
          expr = result("bin", "instanceof", expr, this.next().read_class_name_reference());
          if (this.token !== ";" && this.token !== this.tok.T_INLINE_HTML && this.token !== this.EOF) {
            expr = this.read_expr(expr);
          }
        }
        if (this.token === this.tok.T_COALESCE) {
          return result("bin", "??", expr, this.next().read_expr());
        }
        if (this.token === "?") {
          let trueArg = null;
          if (this.next().token !== ":") {
            trueArg = this.read_expr();
          }
          this.expect(":") && this.next();
          return result("retif", expr, trueArg, this.read_expr());
        } else {
          result.destroy(expr);
        }
        return expr;
      },
      read_expr_cast: function(type) {
        return this.node("cast")(type, this.text(), this.next().read_expr());
      },
      read_isset_variable: function() {
        return this.read_expr();
      },
      read_isset_variables: function() {
        return this.read_function_list(this.read_isset_variable, ",");
      },
      read_internal_functions_in_yacc: function() {
        let result = null;
        switch (this.token) {
          case this.tok.T_ISSET:
            {
              result = this.node("isset");
              if (this.next().expect("(")) {
                this.next();
              }
              const variables = this.read_isset_variables();
              if (this.expect(")")) {
                this.next();
              }
              result = result(variables);
            }
            break;
          case this.tok.T_EMPTY:
            {
              result = this.node("empty");
              if (this.next().expect("(")) {
                this.next();
              }
              const expression = this.read_expr();
              if (this.expect(")")) {
                this.next();
              }
              result = result(expression);
            }
            break;
          case this.tok.T_INCLUDE:
            result = this.node("include")(false, false, this.next().read_expr());
            break;
          case this.tok.T_INCLUDE_ONCE:
            result = this.node("include")(true, false, this.next().read_expr());
            break;
          case this.tok.T_EVAL:
            {
              result = this.node("eval");
              if (this.next().expect("(")) {
                this.next();
              }
              const expr = this.read_expr();
              if (this.expect(")")) {
                this.next();
              }
              result = result(expr);
            }
            break;
          case this.tok.T_REQUIRE:
            result = this.node("include")(false, true, this.next().read_expr());
            break;
          case this.tok.T_REQUIRE_ONCE:
            result = this.node("include")(true, true, this.next().read_expr());
            break;
        }
        return result;
      },
      read_optional_expr: function(stopToken) {
        if (this.token !== stopToken) {
          return this.read_expr();
        }
        return null;
      },
      read_exit_expr: function() {
        let expression = null;
        if (this.token === "(") {
          this.next();
          expression = this.read_optional_expr(")");
          this.expect(")") && this.next();
        }
        return expression;
      },
      read_expr_item: function() {
        let result, expr, attrs = [];
        if (this.token === "+") {
          return this.node("unary")("+", this.next().read_expr());
        }
        if (this.token === "-") {
          return this.node("unary")("-", this.next().read_expr());
        }
        if (this.token === "!") {
          return this.node("unary")("!", this.next().read_expr());
        }
        if (this.token === "~") {
          return this.node("unary")("~", this.next().read_expr());
        }
        if (this.token === "(") {
          expr = this.next().read_expr();
          expr.parenthesizedExpression = true;
          this.expect(")") && this.next();
          return this.handleDereferencable(expr);
        }
        if (this.token === "`") {
          return this.read_encapsed_string("`");
        }
        if (this.token === this.tok.T_LIST) {
          let assign = null;
          const isInner = this.innerList;
          result = this.node("list");
          if (!isInner) {
            assign = this.node("assign");
          }
          if (this.next().expect("(")) {
            this.next();
          }
          if (!this.innerList)
            this.innerList = true;
          const assignList = this.read_array_pair_list(false);
          if (this.expect(")")) {
            this.next();
          }
          let hasItem = false;
          for (let i = 0; i < assignList.length; i++) {
            if (assignList[i] !== null && assignList[i].kind !== "noop") {
              hasItem = true;
              break;
            }
          }
          if (!hasItem) {
            this.raiseError("Fatal Error :  Cannot use empty list on line " + this.lexer.yylloc.first_line);
          }
          if (!isInner) {
            this.innerList = false;
            if (this.expect("=")) {
              return assign(result(assignList, false), this.next().read_expr(), "=");
            } else {
              return result(assignList, false);
            }
          } else {
            return result(assignList, false);
          }
        }
        if (this.token === this.tok.T_ATTRIBUTE) {
          attrs = this.read_attr_list();
        }
        if (this.token === this.tok.T_CLONE) {
          return this.node("clone")(this.next().read_expr());
        }
        switch (this.token) {
          case this.tok.T_INC:
            return this.node("pre")("+", this.next().read_variable(false, false));
          case this.tok.T_DEC:
            return this.node("pre")("-", this.next().read_variable(false, false));
          case this.tok.T_NEW:
            return this.read_new_expr();
          case this.tok.T_ISSET:
          case this.tok.T_EMPTY:
          case this.tok.T_INCLUDE:
          case this.tok.T_INCLUDE_ONCE:
          case this.tok.T_EVAL:
          case this.tok.T_REQUIRE:
          case this.tok.T_REQUIRE_ONCE:
            return this.read_internal_functions_in_yacc();
          case this.tok.T_MATCH:
            return this.read_match_expression();
          case this.tok.T_INT_CAST:
            return this.read_expr_cast("int");
          case this.tok.T_DOUBLE_CAST:
            return this.read_expr_cast("float");
          case this.tok.T_STRING_CAST:
            return this.read_expr_cast(this.text().indexOf("binary") !== -1 ? "binary" : "string");
          case this.tok.T_ARRAY_CAST:
            return this.read_expr_cast("array");
          case this.tok.T_OBJECT_CAST:
            return this.read_expr_cast("object");
          case this.tok.T_BOOL_CAST:
            return this.read_expr_cast("bool");
          case this.tok.T_UNSET_CAST:
            return this.read_expr_cast("unset");
          case this.tok.T_THROW: {
            if (this.version < 800) {
              this.raiseError("PHP 8+ is required to use throw as an expression");
            }
            const result2 = this.node("throw");
            const expr2 = this.next().read_expr();
            return result2(expr2);
          }
          case this.tok.T_EXIT: {
            const useDie = this.lexer.yytext.toLowerCase() === "die";
            result = this.node("exit");
            this.next();
            const expression = this.read_exit_expr();
            return result(expression, useDie);
          }
          case this.tok.T_PRINT:
            return this.node("print")(this.next().read_expr());
          case this.tok.T_YIELD: {
            let value = null;
            let key = null;
            result = this.node("yield");
            if (this.next().is("EXPR")) {
              value = this.read_expr();
              if (this.token === this.tok.T_DOUBLE_ARROW) {
                key = value;
                value = this.next().read_expr();
              }
            }
            return result(value, key);
          }
          case this.tok.T_YIELD_FROM:
            result = this.node("yieldfrom");
            expr = this.next().read_expr();
            return result(expr);
          case this.tok.T_FN:
          case this.tok.T_FUNCTION:
            return this.read_inline_function(void 0, attrs);
          case this.tok.T_STATIC: {
            const backup = [this.token, this.lexer.getState()];
            this.next();
            if (this.token === this.tok.T_FUNCTION || this.version >= 704 && this.token === this.tok.T_FN) {
              return this.read_inline_function([0, 1, 0], attrs);
            } else {
              this.lexer.tokens.push(backup);
              this.next();
            }
          }
        }
        if (this.is("VARIABLE")) {
          result = this.node();
          expr = this.read_variable(false, false);
          const isConst = expr.kind === "identifier" || expr.kind === "staticlookup" && expr.offset.kind === "identifier";
          switch (this.token) {
            case "=": {
              if (isConst)
                this.error("VARIABLE");
              if (this.next().token == "&") {
                return this.read_assignref(result, expr);
              }
              return result("assign", expr, this.read_expr(), "=");
            }
            case this.tok.T_PLUS_EQUAL:
              if (isConst)
                this.error("VARIABLE");
              return result("assign", expr, this.next().read_expr(), "+=");
            case this.tok.T_MINUS_EQUAL:
              if (isConst)
                this.error("VARIABLE");
              return result("assign", expr, this.next().read_expr(), "-=");
            case this.tok.T_MUL_EQUAL:
              if (isConst)
                this.error("VARIABLE");
              return result("assign", expr, this.next().read_expr(), "*=");
            case this.tok.T_POW_EQUAL:
              if (isConst)
                this.error("VARIABLE");
              return result("assign", expr, this.next().read_expr(), "**=");
            case this.tok.T_DIV_EQUAL:
              if (isConst)
                this.error("VARIABLE");
              return result("assign", expr, this.next().read_expr(), "/=");
            case this.tok.T_CONCAT_EQUAL:
              if (isConst)
                this.error("VARIABLE");
              return result("assign", expr, this.next().read_expr(), ".=");
            case this.tok.T_MOD_EQUAL:
              if (isConst)
                this.error("VARIABLE");
              return result("assign", expr, this.next().read_expr(), "%=");
            case this.tok.T_AND_EQUAL:
              if (isConst)
                this.error("VARIABLE");
              return result("assign", expr, this.next().read_expr(), "&=");
            case this.tok.T_OR_EQUAL:
              if (isConst)
                this.error("VARIABLE");
              return result("assign", expr, this.next().read_expr(), "|=");
            case this.tok.T_XOR_EQUAL:
              if (isConst)
                this.error("VARIABLE");
              return result("assign", expr, this.next().read_expr(), "^=");
            case this.tok.T_SL_EQUAL:
              if (isConst)
                this.error("VARIABLE");
              return result("assign", expr, this.next().read_expr(), "<<=");
            case this.tok.T_SR_EQUAL:
              if (isConst)
                this.error("VARIABLE");
              return result("assign", expr, this.next().read_expr(), ">>=");
            case this.tok.T_COALESCE_EQUAL:
              if (isConst)
                this.error("VARIABLE");
              return result("assign", expr, this.next().read_expr(), "??=");
            case this.tok.T_INC:
              if (isConst)
                this.error("VARIABLE");
              this.next();
              return result("post", "+", expr);
            case this.tok.T_DEC:
              if (isConst)
                this.error("VARIABLE");
              this.next();
              return result("post", "-", expr);
            default:
              result.destroy(expr);
          }
        } else if (this.is("SCALAR")) {
          result = this.node();
          expr = this.read_scalar();
          if (expr.kind === "array" && expr.shortForm && this.token === "=") {
            const list = this.convertToList(expr);
            if (expr.loc)
              list.loc = expr.loc;
            const right = this.next().read_expr();
            return result("assign", list, right, "=");
          } else {
            result.destroy(expr);
          }
          return this.handleDereferencable(expr);
        } else {
          this.error("EXPR");
          this.next();
        }
        return expr;
      },
      convertToList: function(array) {
        const convertedItems = array.items.map((entry) => {
          if (entry.value && entry.value.kind === "array" && entry.value.shortForm) {
            entry.value = this.convertToList(entry.value);
          }
          return entry;
        });
        const node = this.node("list")(convertedItems, true);
        if (array.loc)
          node.loc = array.loc;
        if (array.leadingComments)
          node.leadingComments = array.leadingComments;
        if (array.trailingComments)
          node.trailingComments = array.trailingComments;
        return node;
      },
      read_assignref: function(result, left) {
        this.next();
        let right;
        if (this.token === this.tok.T_NEW) {
          if (this.version >= 700) {
            this.error();
          }
          right = this.read_new_expr();
        } else {
          right = this.read_variable(false, false);
        }
        return result("assignref", left, right);
      },
      read_inline_function: function(flags, attrs) {
        if (this.token === this.tok.T_FUNCTION) {
          const result2 = this.read_function(true, flags, attrs);
          result2.attrGroups = attrs;
          return result2;
        }
        if (!this.version >= 704) {
          this.raiseError("Arrow Functions are not allowed");
        }
        const node = this.node("arrowfunc");
        if (this.expect(this.tok.T_FN))
          this.next();
        const isRef = this.is_reference();
        if (this.expect("("))
          this.next();
        const params = this.read_parameter_list();
        if (this.expect(")"))
          this.next();
        let nullable = false;
        let returnType = null;
        if (this.token === ":") {
          if (this.next().token === "?") {
            nullable = true;
            this.next();
          }
          returnType = this.read_types();
        }
        if (this.expect(this.tok.T_DOUBLE_ARROW))
          this.next();
        const body = this.read_expr();
        const result = node(params, isRef, body, returnType, nullable, flags ? true : false);
        result.attrGroups = attrs;
        return result;
      },
      read_match_expression: function() {
        const node = this.node("match");
        this.expect(this.tok.T_MATCH) && this.next();
        if (this.version < 800) {
          this.raiseError("Match statements are not allowed before PHP 8");
        }
        let cond = null;
        let arms = [];
        if (this.expect("("))
          this.next();
        cond = this.read_expr();
        if (this.expect(")"))
          this.next();
        if (this.expect("{"))
          this.next();
        arms = this.read_match_arms();
        if (this.expect("}"))
          this.next();
        return node(cond, arms);
      },
      read_match_arms: function() {
        return this.read_list(() => this.read_match_arm(), ",", true);
      },
      read_match_arm: function() {
        if (this.token === "}") {
          return;
        }
        return this.node("matcharm")(this.read_match_arm_conds(), this.read_expr());
      },
      read_match_arm_conds: function() {
        let conds = [];
        if (this.token === this.tok.T_DEFAULT) {
          conds = null;
          this.next();
        } else {
          conds.push(this.read_expr());
          while (this.token === ",") {
            this.next();
            if (this.token === this.tok.T_DOUBLE_ARROW) {
              this.next();
              return conds;
            }
            conds.push(this.read_expr());
          }
        }
        if (this.expect(this.tok.T_DOUBLE_ARROW)) {
          this.next();
        }
        return conds;
      },
      read_attribute() {
        const name = this.text();
        let args = [];
        this.next();
        if (this.token === "(") {
          args = this.read_argument_list();
        }
        return this.node("attribute")(name, args);
      },
      read_attr_list() {
        const list = [];
        if (this.token === this.tok.T_ATTRIBUTE) {
          do {
            const attrGr = this.node("attrgroup")([]);
            this.next();
            attrGr.attrs.push(this.read_attribute());
            while (this.token === ",") {
              this.next();
              if (this.token !== "]")
                attrGr.attrs.push(this.read_attribute());
            }
            list.push(attrGr);
            this.expect("]");
            this.next();
          } while (this.token === this.tok.T_ATTRIBUTE);
        }
        return list;
      },
      read_new_expr: function() {
        const result = this.node("new");
        this.expect(this.tok.T_NEW) && this.next();
        let args = [];
        const attrs = this.read_attr_list();
        if (this.token === this.tok.T_CLASS) {
          const what = this.node("class");
          if (this.next().token === "(") {
            args = this.read_argument_list();
          }
          const propExtends = this.read_extends_from();
          const propImplements = this.read_implements_list();
          let body = null;
          if (this.expect("{")) {
            body = this.next().read_class_body(true, false);
          }
          const whatNode = what(null, propExtends, propImplements, body, [0, 0, 0]);
          whatNode.attrGroups = attrs;
          return result(whatNode, args);
        }
        let name = this.read_new_class_name();
        while (this.token === "[") {
          const offsetNode = this.node("offsetlookup");
          const offset = this.next().read_encaps_var_offset();
          this.expect("]") && this.next();
          name = offsetNode(name, offset);
        }
        if (this.token === "(") {
          args = this.read_argument_list();
        }
        return result(name, args);
      },
      read_new_class_name: function() {
        if (this.token === this.tok.T_NS_SEPARATOR || this.token === this.tok.T_NAME_RELATIVE || this.token === this.tok.T_NAME_QUALIFIED || this.token === this.tok.T_NAME_FULLY_QUALIFIED || this.token === this.tok.T_STRING || this.token === this.tok.T_NAMESPACE) {
          let result = this.read_namespace_name(true);
          if (this.token === this.tok.T_DOUBLE_COLON) {
            result = this.read_static_getter(result);
          }
          return result;
        } else if (this.is("VARIABLE")) {
          return this.read_variable(true, false);
        } else {
          this.expect([this.tok.T_STRING, "VARIABLE"]);
        }
      },
      handleDereferencable: function(expr) {
        while (this.token !== this.EOF) {
          if (this.token === this.tok.T_OBJECT_OPERATOR || this.token === this.tok.T_DOUBLE_COLON) {
            expr = this.recursive_variable_chain_scan(expr, false, false, true);
          } else if (this.token === this.tok.T_CURLY_OPEN || this.token === "[") {
            expr = this.read_dereferencable(expr);
          } else if (this.token === "(") {
            expr = this.node("call")(expr, this.read_argument_list());
          } else {
            return expr;
          }
        }
        return expr;
      }
    };
  }
});

// node_modules/php-parser/src/parser/enum.js
var require_enum = __commonJS({
  "node_modules/php-parser/src/parser/enum.js"(exports, module2) {
    "use strict";
    module2.exports = {
      read_enum_declaration_statement: function(attrs) {
        const result = this.node("enum");
        if (!this.expect(this.tok.T_ENUM)) {
          return null;
        }
        this.next().expect(this.tok.T_STRING);
        let propName = this.node("identifier");
        const name = this.text();
        this.next();
        propName = propName(name);
        const valueType = this.read_enum_value_type();
        const propImplements = this.read_implements_list();
        this.expect("{");
        const body = this.next().read_class_body(false, true);
        const node = result(propName, valueType, propImplements, body);
        if (attrs)
          node.attrGroups = attrs;
        return node;
      },
      read_enum_value_type: function() {
        if (this.token === ":") {
          return this.next().read_namespace_name();
        }
        return null;
      },
      read_enum_case: function() {
        this.expect(this.tok.T_CASE);
        const result = this.node("enumcase");
        let caseName = this.node("identifier");
        const name = this.next().text();
        this.next();
        caseName = caseName(name);
        const value = this.token === "=" ? this.next().read_expr() : null;
        this.expect(";");
        return result(caseName, value);
      }
    };
  }
});

// node_modules/php-parser/src/parser/function.js
var require_function = __commonJS({
  "node_modules/php-parser/src/parser/function.js"(exports, module2) {
    "use strict";
    module2.exports = {
      is_reference: function() {
        if (this.token === "&") {
          this.next();
          return true;
        }
        return false;
      },
      is_variadic: function() {
        if (this.token === this.tok.T_ELLIPSIS) {
          this.next();
          return true;
        }
        return false;
      },
      read_function: function(closure, flag, attrs, locStart) {
        const result = this.read_function_declaration(closure ? 1 : flag ? 2 : 0, flag && flag[1] === 1, attrs || [], locStart);
        if (flag && flag[2] == 1) {
          result.parseFlags(flag);
          if (this.expect(";")) {
            this.next();
          }
        } else {
          if (this.expect("{")) {
            result.body = this.read_code_block(false);
            if (result.loc && result.body.loc) {
              result.loc.end = result.body.loc.end;
            }
          }
          if (!closure && flag) {
            result.parseFlags(flag);
          }
        }
        return result;
      },
      read_function_declaration: function(type, isStatic, attrs, locStart) {
        let nodeName = "function";
        if (type === 1) {
          nodeName = "closure";
        } else if (type === 2) {
          nodeName = "method";
        }
        const result = this.node(nodeName);
        if (this.expect(this.tok.T_FUNCTION)) {
          this.next();
        }
        const isRef = this.is_reference();
        let name = false, use = [], returnType = null, nullable = false;
        if (type !== 1) {
          const nameNode = this.node("identifier");
          if (type === 2) {
            if (this.version >= 700) {
              if (this.token === this.tok.T_STRING || this.is("IDENTIFIER")) {
                name = this.text();
                this.next();
              } else if (this.version < 704) {
                this.error("IDENTIFIER");
              }
            } else if (this.token === this.tok.T_STRING) {
              name = this.text();
              this.next();
            } else {
              this.error("IDENTIFIER");
            }
          } else {
            if (this.version >= 700) {
              if (this.token === this.tok.T_STRING) {
                name = this.text();
                this.next();
              } else if (this.version >= 704) {
                if (!this.expect("(")) {
                  this.next();
                }
              } else {
                this.error(this.tok.T_STRING);
                this.next();
              }
            } else {
              if (this.expect(this.tok.T_STRING)) {
                name = this.text();
              }
              this.next();
            }
          }
          name = nameNode(name);
        }
        if (this.expect("("))
          this.next();
        const params = this.read_parameter_list(name.name === "__construct");
        if (this.expect(")"))
          this.next();
        if (type === 1) {
          use = this.read_lexical_vars();
        }
        if (this.token === ":") {
          if (this.next().token === "?") {
            nullable = true;
            this.next();
          }
          returnType = this.read_types();
        }
        const apply_attrgroup_location = (node) => {
          node.attrGroups = attrs || [];
          if (locStart && node.loc) {
            node.loc.start = locStart;
            if (node.loc.source) {
              node.loc.source = this.lexer._input.substr(node.loc.start.offset, node.loc.end.offset - node.loc.start.offset);
            }
          }
          return node;
        };
        if (type === 1) {
          return apply_attrgroup_location(result(params, isRef, use, returnType, nullable, isStatic));
        }
        return apply_attrgroup_location(result(name, params, isRef, returnType, nullable));
      },
      read_lexical_vars: function() {
        let result = [];
        if (this.token === this.tok.T_USE) {
          this.next();
          this.expect("(") && this.next();
          result = this.read_lexical_var_list();
          this.expect(")") && this.next();
        }
        return result;
      },
      read_list_with_dangling_comma: function(item) {
        const result = [];
        while (this.token != this.EOF) {
          result.push(item());
          if (this.token == ",") {
            this.next();
            if (this.version >= 800 && this.token === ")") {
              return result;
            }
          } else if (this.token == ")") {
            break;
          } else {
            this.error([",", ")"]);
            break;
          }
        }
        return result;
      },
      read_lexical_var_list: function() {
        return this.read_list_with_dangling_comma(this.read_lexical_var.bind(this));
      },
      read_lexical_var: function() {
        if (this.token === "&") {
          return this.read_byref(this.read_lexical_var.bind(this));
        }
        const result = this.node("variable");
        this.expect(this.tok.T_VARIABLE);
        const name = this.text().substring(1);
        this.next();
        return result(name, false);
      },
      read_parameter_list: function(is_class_constructor) {
        if (this.token !== ")") {
          let wasVariadic = false;
          return this.read_list_with_dangling_comma(function() {
            const parameter = this.read_parameter(is_class_constructor);
            if (parameter) {
              if (wasVariadic) {
                this.raiseError("Unexpected parameter after a variadic parameter");
              }
              if (parameter.variadic) {
                wasVariadic = true;
              }
            }
            return parameter;
          }.bind(this), ",");
        }
        return [];
      },
      read_parameter: function(is_class_constructor) {
        const node = this.node("parameter");
        let parameterName = null;
        let value = null;
        let types = null;
        let nullable = false;
        let readonly = false;
        let attrs = [];
        if (this.token === this.tok.T_ATTRIBUTE)
          attrs = this.read_attr_list();
        const flags = this.read_promoted();
        if (this.version >= 801 && this.token === this.tok.T_READ_ONLY) {
          if (is_class_constructor) {
            this.next();
            readonly = true;
          } else {
            this.raiseError("readonly properties can be used only on class constructor");
          }
        }
        if (this.token === "?") {
          this.next();
          nullable = true;
        }
        types = this.read_types();
        if (nullable && !types) {
          this.raiseError("Expecting a type definition combined with nullable operator");
        }
        const isRef = this.is_reference();
        const isVariadic = this.is_variadic();
        if (this.expect(this.tok.T_VARIABLE)) {
          parameterName = this.node("identifier");
          const name = this.text().substring(1);
          this.next();
          parameterName = parameterName(name);
        }
        if (this.token == "=") {
          value = this.next().read_expr();
        }
        const result = node(parameterName, types, value, isRef, isVariadic, readonly, nullable, flags);
        if (attrs)
          result.attrGroups = attrs;
        return result;
      },
      read_types() {
        const MODE_UNSET = "unset";
        const MODE_UNION = "union";
        const MODE_INTERSECTION = "intersection";
        const types = [];
        let mode = MODE_UNSET;
        const type = this.read_type();
        if (!type)
          return null;
        types.push(type);
        while (this.token === "|" || this.version >= 801 && this.token === "&") {
          const nextToken = this.peek();
          if (nextToken === this.tok.T_ELLIPSIS || nextToken === this.tok.T_VARIABLE) {
            break;
          }
          if (mode === MODE_UNSET) {
            mode = this.token === "|" ? MODE_UNION : MODE_INTERSECTION;
          } else {
            if (mode === MODE_UNION && this.token !== "|" || mode === MODE_INTERSECTION && this.token !== "&") {
              this.raiseError('Unexpect token "' + this.token + '", "|" and "&" can not be mixed');
            }
          }
          this.next();
          types.push(this.read_type());
        }
        if (types.length === 1) {
          return types[0];
        } else {
          return mode === MODE_INTERSECTION ? this.node("intersectiontype")(types) : this.node("uniontype")(types);
        }
      },
      read_promoted() {
        const MODIFIER_PUBLIC = 1;
        const MODIFIER_PROTECTED = 2;
        const MODIFIER_PRIVATE = 4;
        if (this.token === this.tok.T_PUBLIC) {
          this.next();
          return MODIFIER_PUBLIC;
        } else if (this.token === this.tok.T_PROTECTED) {
          this.next();
          return MODIFIER_PROTECTED;
        } else if (this.token === this.tok.T_PRIVATE) {
          this.next();
          return MODIFIER_PRIVATE;
        }
        return 0;
      },
      read_argument_list: function() {
        let result = [];
        this.expect("(") && this.next();
        if (this.version >= 801 && this.token === this.tok.T_ELLIPSIS && this.peek() === ")") {
          result.push(this.node("variadicplaceholder")());
          this.next();
        } else if (this.token !== ")") {
          result = this.read_non_empty_argument_list();
        }
        this.expect(")") && this.next();
        return result;
      },
      read_non_empty_argument_list: function() {
        let wasVariadic = false;
        return this.read_function_list(function() {
          const argument = this.read_argument();
          if (argument) {
            const isVariadic = argument.kind === "variadic";
            if (wasVariadic && !isVariadic) {
              this.raiseError("Unexpected non-variadic argument after a variadic argument");
            }
            if (isVariadic) {
              wasVariadic = true;
            }
          }
          return argument;
        }.bind(this), ",");
      },
      read_argument: function() {
        if (this.token === this.tok.T_ELLIPSIS) {
          return this.node("variadic")(this.next().read_expr());
        }
        if (this.token === this.tok.T_STRING || Object.values(this.lexer.keywords).includes(this.token)) {
          const nextToken = this.peek();
          if (nextToken === ":") {
            if (this.version < 800) {
              this.raiseError("PHP 8+ is required to use named arguments");
            }
            return this.node("namedargument")(this.text(), this.next().next().read_expr());
          }
        }
        return this.read_expr();
      },
      read_type: function() {
        const result = this.node();
        if (this.token === this.tok.T_ARRAY || this.token === this.tok.T_CALLABLE) {
          const type = this.text();
          this.next();
          return result("typereference", type.toLowerCase(), type);
        } else if (this.token === this.tok.T_NAME_RELATIVE || this.token === this.tok.T_NAME_QUALIFIED || this.token === this.tok.T_NAME_FULLY_QUALIFIED || this.token === this.tok.T_STRING || this.token === this.tok.T_STATIC) {
          const type = this.text();
          const backup = [this.token, this.lexer.getState()];
          this.next();
          if (this.token !== this.tok.T_NS_SEPARATOR && this.ast.typereference.types.indexOf(type.toLowerCase()) > -1) {
            return result("typereference", type.toLowerCase(), type);
          } else {
            this.lexer.tokens.push(backup);
            this.next();
            result.destroy();
            return this.read_namespace_name();
          }
        }
        result.destroy();
        return null;
      }
    };
  }
});

// node_modules/php-parser/src/parser/if.js
var require_if = __commonJS({
  "node_modules/php-parser/src/parser/if.js"(exports, module2) {
    "use strict";
    module2.exports = {
      read_if: function() {
        const result = this.node("if");
        const test = this.next().read_if_expr();
        let body = null;
        let alternate = null;
        let shortForm = false;
        if (this.token === ":") {
          shortForm = true;
          this.next();
          body = this.node("block");
          const items = [];
          while (this.token !== this.EOF && this.token !== this.tok.T_ENDIF) {
            if (this.token === this.tok.T_ELSEIF) {
              alternate = this.read_elseif_short();
              break;
            } else if (this.token === this.tok.T_ELSE) {
              alternate = this.read_else_short();
              break;
            }
            items.push(this.read_inner_statement());
          }
          body = body(null, items);
          this.expect(this.tok.T_ENDIF) && this.next();
          this.expectEndOfStatement();
        } else {
          body = this.read_statement();
          if (this.token === this.tok.T_ELSEIF) {
            alternate = this.read_if();
          } else if (this.token === this.tok.T_ELSE) {
            alternate = this.next().read_statement();
          }
        }
        return result(test, body, alternate, shortForm);
      },
      read_if_expr: function() {
        this.expect("(") && this.next();
        const result = this.read_expr();
        this.expect(")") && this.next();
        return result;
      },
      read_elseif_short: function() {
        let alternate = null;
        const result = this.node("if");
        const test = this.next().read_if_expr();
        if (this.expect(":"))
          this.next();
        const body = this.node("block");
        const items = [];
        while (this.token != this.EOF && this.token !== this.tok.T_ENDIF) {
          if (this.token === this.tok.T_ELSEIF) {
            alternate = this.read_elseif_short();
            break;
          } else if (this.token === this.tok.T_ELSE) {
            alternate = this.read_else_short();
            break;
          }
          items.push(this.read_inner_statement());
        }
        return result(test, body(null, items), alternate, true);
      },
      read_else_short: function() {
        if (this.next().expect(":"))
          this.next();
        const body = this.node("block");
        const items = [];
        while (this.token != this.EOF && this.token !== this.tok.T_ENDIF) {
          items.push(this.read_inner_statement());
        }
        return body(null, items);
      }
    };
  }
});

// node_modules/php-parser/src/parser/loops.js
var require_loops = __commonJS({
  "node_modules/php-parser/src/parser/loops.js"(exports, module2) {
    "use strict";
    module2.exports = {
      read_while: function() {
        const result = this.node("while");
        this.expect(this.tok.T_WHILE) && this.next();
        let test = null;
        let body = null;
        let shortForm = false;
        if (this.expect("("))
          this.next();
        test = this.read_expr();
        if (this.expect(")"))
          this.next();
        if (this.token === ":") {
          shortForm = true;
          body = this.read_short_form(this.tok.T_ENDWHILE);
        } else {
          body = this.read_statement();
        }
        return result(test, body, shortForm);
      },
      read_do: function() {
        const result = this.node("do");
        this.expect(this.tok.T_DO) && this.next();
        let test = null;
        let body = null;
        body = this.read_statement();
        if (this.expect(this.tok.T_WHILE)) {
          if (this.next().expect("("))
            this.next();
          test = this.read_expr();
          if (this.expect(")"))
            this.next();
          if (this.expect(";"))
            this.next();
        }
        return result(test, body);
      },
      read_for: function() {
        const result = this.node("for");
        this.expect(this.tok.T_FOR) && this.next();
        let init = [];
        let test = [];
        let increment = [];
        let body = null;
        let shortForm = false;
        if (this.expect("("))
          this.next();
        if (this.token !== ";") {
          init = this.read_list(this.read_expr, ",");
          if (this.expect(";"))
            this.next();
        } else {
          this.next();
        }
        if (this.token !== ";") {
          test = this.read_list(this.read_expr, ",");
          if (this.expect(";"))
            this.next();
        } else {
          this.next();
        }
        if (this.token !== ")") {
          increment = this.read_list(this.read_expr, ",");
          if (this.expect(")"))
            this.next();
        } else {
          this.next();
        }
        if (this.token === ":") {
          shortForm = true;
          body = this.read_short_form(this.tok.T_ENDFOR);
        } else {
          body = this.read_statement();
        }
        return result(init, test, increment, body, shortForm);
      },
      read_foreach: function() {
        const result = this.node("foreach");
        this.expect(this.tok.T_FOREACH) && this.next();
        let source = null;
        let key = null;
        let value = null;
        let body = null;
        let shortForm = false;
        if (this.expect("("))
          this.next();
        source = this.read_expr();
        if (this.expect(this.tok.T_AS)) {
          this.next();
          value = this.read_foreach_variable();
          if (this.token === this.tok.T_DOUBLE_ARROW) {
            key = value;
            value = this.next().read_foreach_variable();
          }
        }
        if (key && key.kind === "list") {
          this.raiseError("Fatal Error : Cannot use list as key element");
        }
        if (this.expect(")"))
          this.next();
        if (this.token === ":") {
          shortForm = true;
          body = this.read_short_form(this.tok.T_ENDFOREACH);
        } else {
          body = this.read_statement();
        }
        return result(source, key, value, body, shortForm);
      },
      read_foreach_variable: function() {
        if (this.token === this.tok.T_LIST || this.token === "[") {
          const isShort = this.token === "[";
          const result = this.node("list");
          this.next();
          if (!isShort && this.expect("("))
            this.next();
          const assignList = this.read_array_pair_list(isShort);
          if (this.expect(isShort ? "]" : ")"))
            this.next();
          return result(assignList, isShort);
        } else {
          return this.read_variable(false, false);
        }
      }
    };
  }
});

// node_modules/php-parser/src/parser/main.js
var require_main = __commonJS({
  "node_modules/php-parser/src/parser/main.js"(exports, module2) {
    "use strict";
    module2.exports = {
      read_start: function() {
        if (this.token == this.tok.T_NAMESPACE) {
          return this.read_namespace();
        } else {
          return this.read_top_statement();
        }
      }
    };
  }
});

// node_modules/php-parser/src/parser/namespace.js
var require_namespace = __commonJS({
  "node_modules/php-parser/src/parser/namespace.js"(exports, module2) {
    "use strict";
    module2.exports = {
      read_namespace: function() {
        const result = this.node("namespace");
        let body;
        this.expect(this.tok.T_NAMESPACE) && this.next();
        let name;
        if (this.token === "{") {
          name = {
            name: [""]
          };
        } else {
          name = this.read_namespace_name();
        }
        this.currentNamespace = name;
        if (this.token === ";") {
          this.currentNamespace = name;
          body = this.next().read_top_statements();
          this.expect(this.EOF);
          return result(name.name, body, false);
        } else if (this.token === "{") {
          this.currentNamespace = name;
          body = this.next().read_top_statements();
          this.expect("}") && this.next();
          if (body.length === 0 && this.extractDoc && this._docs.length > this._docIndex) {
            body.push(this.node("noop")());
          }
          return result(name.name, body, true);
        } else {
          this.error(["{", ";"]);
          this.currentNamespace = name;
          body = this.read_top_statements();
          this.expect(this.EOF);
          return result(name, body, false);
        }
      },
      read_namespace_name: function(resolveReference) {
        const result = this.node();
        let resolution;
        let name = this.text();
        switch (this.token) {
          case this.tok.T_NAME_RELATIVE:
            resolution = this.ast.name.RELATIVE_NAME;
            name = name.replace(/^namespace\\/, "");
            break;
          case this.tok.T_NAME_QUALIFIED:
            resolution = this.ast.name.QUALIFIED_NAME;
            break;
          case this.tok.T_NAME_FULLY_QUALIFIED:
            resolution = this.ast.name.FULL_QUALIFIED_NAME;
            break;
          default:
            resolution = this.ast.name.UNQUALIFIED_NAME;
            if (!this.expect(this.tok.T_STRING)) {
              return result("name", "", this.ast.name.FULL_QUALIFIED_NAME);
            }
        }
        this.next();
        if (resolveReference || this.token !== "(") {
          if (name.toLowerCase() === "parent") {
            return result("parentreference", name);
          } else if (name.toLowerCase() === "self") {
            return result("selfreference", name);
          }
        }
        return result("name", name, resolution);
      },
      read_use_statement: function() {
        let result = this.node("usegroup");
        let items = [];
        let name = null;
        this.expect(this.tok.T_USE) && this.next();
        const type = this.read_use_type();
        items.push(this.read_use_declaration(false));
        if (this.token === ",") {
          items = items.concat(this.next().read_use_declarations(false));
        } else if (this.token === "{") {
          name = items[0].name;
          items = this.next().read_use_declarations(type === null);
          this.expect("}") && this.next();
        }
        result = result(name, type, items);
        this.expect(";") && this.next();
        return result;
      },
      read_class_name_reference: function() {
        return this.read_variable(true, false);
      },
      read_use_declaration: function(typed) {
        const result = this.node("useitem");
        let type = null;
        if (typed)
          type = this.read_use_type();
        const name = this.read_namespace_name();
        const alias = this.read_use_alias();
        return result(name.name, alias, type);
      },
      read_use_declarations: function(typed) {
        const result = [this.read_use_declaration(typed)];
        while (this.token === ",") {
          this.next();
          if (typed) {
            if (this.token !== this.tok.T_NAME_RELATIVE && this.token !== this.tok.T_NAME_QUALIFIED && this.token !== this.tok.T_NAME_FULLY_QUALIFIED && this.token !== this.tok.T_FUNCTION && this.token !== this.tok.T_CONST && this.token !== this.tok.T_STRING) {
              break;
            }
          } else if (this.token !== this.tok.T_NAME_RELATIVE && this.token !== this.tok.T_NAME_QUALIFIED && this.token !== this.tok.T_NAME_FULLY_QUALIFIED && this.token !== this.tok.T_STRING && this.token !== this.tok.T_NS_SEPARATOR) {
            break;
          }
          result.push(this.read_use_declaration(typed));
        }
        return result;
      },
      read_use_alias: function() {
        let result = null;
        if (this.token === this.tok.T_AS) {
          if (this.next().expect(this.tok.T_STRING)) {
            const aliasName = this.node("identifier");
            const name = this.text();
            this.next();
            result = aliasName(name);
          }
        }
        return result;
      },
      read_use_type: function() {
        if (this.token === this.tok.T_FUNCTION) {
          this.next();
          return this.ast.useitem.TYPE_FUNCTION;
        } else if (this.token === this.tok.T_CONST) {
          this.next();
          return this.ast.useitem.TYPE_CONST;
        }
        return null;
      }
    };
  }
});

// node_modules/php-parser/src/parser/scalar.js
var require_scalar = __commonJS({
  "node_modules/php-parser/src/parser/scalar.js"(exports, module2) {
    "use strict";
    var specialChar = {
      "\\": "\\",
      $: "$",
      n: "\n",
      r: "\r",
      t: "	",
      f: String.fromCharCode(12),
      v: String.fromCharCode(11),
      e: String.fromCharCode(27)
    };
    module2.exports = {
      resolve_special_chars: function(text, doubleQuote) {
        if (!doubleQuote) {
          return text.replace(/\\\\/g, "\\").replace(/\\'/g, "'");
        }
        return text.replace(/\\"/, '"').replace(/\\([\\$nrtfve]|[xX][0-9a-fA-F]{1,2}|[0-7]{1,3}|u{([0-9a-fA-F]+)})/g, ($match, p1, p2) => {
          if (specialChar[p1]) {
            return specialChar[p1];
          } else if (p1[0] === "x" || p1[0] === "X") {
            return String.fromCodePoint(parseInt(p1.substr(1), 16));
          } else if (p1[0] === "u") {
            return String.fromCodePoint(parseInt(p2, 16));
          } else {
            return String.fromCodePoint(parseInt(p1, 8));
          }
        });
      },
      remove_heredoc_leading_whitespace_chars: function(text, indentation, indentation_uses_spaces, first_encaps_node) {
        if (indentation === 0) {
          return text;
        }
        this.check_heredoc_indentation_level(text, indentation, indentation_uses_spaces, first_encaps_node);
        const matchedChar = indentation_uses_spaces ? " " : "	";
        const removementRegExp = new RegExp(`\\n${matchedChar}{${indentation}}`, "g");
        const removementFirstEncapsNodeRegExp = new RegExp(`^${matchedChar}{${indentation}}`);
        if (first_encaps_node) {
          text = text.replace(removementFirstEncapsNodeRegExp, "");
        }
        return text.replace(removementRegExp, "\n");
      },
      check_heredoc_indentation_level: function(text, indentation, indentation_uses_spaces, first_encaps_node) {
        const textSize = text.length;
        let offset = 0;
        let leadingWhitespaceCharCount = 0;
        let inCoutingState = true;
        const chToCheck = indentation_uses_spaces ? " " : "	";
        let inCheckState = false;
        if (!first_encaps_node) {
          offset = text.indexOf("\n");
          if (offset === -1) {
            return;
          }
          offset++;
        }
        while (offset < textSize) {
          if (inCoutingState) {
            if (text[offset] === chToCheck) {
              leadingWhitespaceCharCount++;
            } else {
              inCheckState = true;
            }
          } else {
            inCoutingState = false;
          }
          if (text[offset] !== "\n" && inCheckState && leadingWhitespaceCharCount < indentation) {
            this.raiseError(`Invalid body indentation level (expecting an indentation at least ${indentation})`);
          } else {
            inCheckState = false;
          }
          if (text[offset] === "\n") {
            inCoutingState = true;
            leadingWhitespaceCharCount = 0;
          }
          offset++;
        }
      },
      read_dereferencable_scalar: function() {
        let result = null;
        switch (this.token) {
          case this.tok.T_CONSTANT_ENCAPSED_STRING:
            {
              let value = this.node("string");
              const text = this.text();
              let offset = 0;
              if (text[0] === "b" || text[0] === "B") {
                offset = 1;
              }
              const isDoubleQuote = text[offset] === '"';
              this.next();
              const textValue = this.resolve_special_chars(text.substring(offset + 1, text.length - 1), isDoubleQuote);
              value = value(isDoubleQuote, textValue, offset === 1, text);
              if (this.token === this.tok.T_DOUBLE_COLON) {
                result = this.read_static_getter(value);
              } else {
                result = value;
              }
            }
            break;
          case this.tok.T_ARRAY:
            result = this.read_array();
            break;
          case "[":
            result = this.read_array();
            break;
        }
        return result;
      },
      read_scalar: function() {
        if (this.is("T_MAGIC_CONST")) {
          return this.get_magic_constant();
        } else {
          let value, node;
          switch (this.token) {
            case this.tok.T_LNUMBER:
            case this.tok.T_DNUMBER: {
              const result = this.node("number");
              value = this.text();
              this.next();
              return result(value, null);
            }
            case this.tok.T_START_HEREDOC:
              if (this.lexer.curCondition === "ST_NOWDOC") {
                const start = this.lexer.yylloc.first_offset;
                node = this.node("nowdoc");
                value = this.next().text();
                if (this.lexer.heredoc_label.indentation > 0) {
                  value = value.substring(0, value.length - this.lexer.heredoc_label.indentation);
                }
                const lastCh = value[value.length - 1];
                if (lastCh === "\n") {
                  if (value[value.length - 2] === "\r") {
                    value = value.substring(0, value.length - 2);
                  } else {
                    value = value.substring(0, value.length - 1);
                  }
                } else if (lastCh === "\r") {
                  value = value.substring(0, value.length - 1);
                }
                this.expect(this.tok.T_ENCAPSED_AND_WHITESPACE) && this.next();
                this.expect(this.tok.T_END_HEREDOC) && this.next();
                const raw = this.lexer._input.substring(start, this.lexer.yylloc.first_offset);
                node = node(this.remove_heredoc_leading_whitespace_chars(value, this.lexer.heredoc_label.indentation, this.lexer.heredoc_label.indentation_uses_spaces, this.lexer.heredoc_label.first_encaps_node), raw, this.lexer.heredoc_label.label);
                this.lexer.heredoc_label.finished = true;
                return node;
              } else {
                return this.read_encapsed_string(this.tok.T_END_HEREDOC);
              }
            case '"':
              return this.read_encapsed_string('"');
            case 'b"':
            case 'B"': {
              return this.read_encapsed_string('"', true);
            }
            case this.tok.T_CONSTANT_ENCAPSED_STRING:
            case this.tok.T_ARRAY:
            case "[":
              return this.read_dereferencable_scalar();
            default: {
              const err = this.error("SCALAR");
              this.next();
              return err;
            }
          }
        }
      },
      read_dereferencable: function(expr) {
        let result, offset;
        const node = this.node("offsetlookup");
        if (this.token === "[") {
          offset = this.next().read_expr();
          if (this.expect("]"))
            this.next();
          result = node(expr, offset);
        } else if (this.token === this.tok.T_DOLLAR_OPEN_CURLY_BRACES) {
          offset = this.read_encapsed_string_item(false);
          result = node(expr, offset);
        }
        return result;
      },
      read_encapsed_string_item: function(isDoubleQuote) {
        const encapsedPart = this.node("encapsedpart");
        let syntax = null;
        let curly = false;
        let result = this.node(), offset, node, name;
        if (this.token === this.tok.T_ENCAPSED_AND_WHITESPACE) {
          const text = this.text();
          this.next();
          result = result("string", false, this.version >= 703 && !this.lexer.heredoc_label.finished ? this.remove_heredoc_leading_whitespace_chars(this.resolve_special_chars(text, isDoubleQuote), this.lexer.heredoc_label.indentation, this.lexer.heredoc_label.indentation_uses_spaces, this.lexer.heredoc_label.first_encaps_node) : text, false, text);
        } else if (this.token === this.tok.T_DOLLAR_OPEN_CURLY_BRACES) {
          syntax = "simple";
          curly = true;
          name = null;
          if (this.next().token === this.tok.T_STRING_VARNAME) {
            name = this.node("variable");
            const varName = this.text();
            this.next();
            result.destroy();
            if (this.token === "[") {
              name = name(varName, false);
              node = this.node("offsetlookup");
              offset = this.next().read_expr();
              this.expect("]") && this.next();
              result = node(name, offset);
            } else {
              result = name(varName, false);
            }
          } else {
            result = result("variable", this.read_expr(), false);
          }
          this.expect("}") && this.next();
        } else if (this.token === this.tok.T_CURLY_OPEN) {
          syntax = "complex";
          result.destroy();
          result = this.next().read_variable(false, false);
          this.expect("}") && this.next();
        } else if (this.token === this.tok.T_VARIABLE) {
          syntax = "simple";
          result.destroy();
          result = this.read_simple_variable();
          if (this.token === "[") {
            node = this.node("offsetlookup");
            offset = this.next().read_encaps_var_offset();
            this.expect("]") && this.next();
            result = node(result, offset);
          }
          if (this.token === this.tok.T_OBJECT_OPERATOR) {
            node = this.node("propertylookup");
            this.next().expect(this.tok.T_STRING);
            const what = this.node("identifier");
            name = this.text();
            this.next();
            result = node(result, what(name));
          }
        } else {
          this.expect(this.tok.T_ENCAPSED_AND_WHITESPACE);
          const value = this.text();
          this.next();
          result.destroy();
          result = result("string", false, value, false, value);
        }
        this.lexer.heredoc_label.first_encaps_node = false;
        return encapsedPart(result, syntax, curly);
      },
      read_encapsed_string: function(expect, isBinary = false) {
        const labelStart = this.lexer.yylloc.first_offset;
        let node = this.node("encapsed");
        this.next();
        const start = this.lexer.yylloc.prev_offset - (isBinary ? 1 : 0);
        const value = [];
        let type = null;
        if (expect === "`") {
          type = this.ast.encapsed.TYPE_SHELL;
        } else if (expect === '"') {
          type = this.ast.encapsed.TYPE_STRING;
        } else {
          type = this.ast.encapsed.TYPE_HEREDOC;
        }
        while (this.token !== expect && this.token !== this.EOF) {
          value.push(this.read_encapsed_string_item(true));
        }
        if (value.length > 0 && value[value.length - 1].kind === "encapsedpart" && value[value.length - 1].expression.kind === "string") {
          const node2 = value[value.length - 1].expression;
          const lastCh = node2.value[node2.value.length - 1];
          if (lastCh === "\n") {
            if (node2.value[node2.value.length - 2] === "\r") {
              node2.value = node2.value.substring(0, node2.value.length - 2);
            } else {
              node2.value = node2.value.substring(0, node2.value.length - 1);
            }
          } else if (lastCh === "\r") {
            node2.value = node2.value.substring(0, node2.value.length - 1);
          }
        }
        this.expect(expect) && this.next();
        const raw = this.lexer._input.substring(type === "heredoc" ? labelStart : start - 1, this.lexer.yylloc.first_offset);
        node = node(value, raw, type);
        if (expect === this.tok.T_END_HEREDOC) {
          node.label = this.lexer.heredoc_label.label;
          this.lexer.heredoc_label.finished = true;
        }
        return node;
      },
      get_magic_constant: function() {
        const result = this.node("magic");
        const name = this.text();
        this.next();
        return result(name.toUpperCase(), name);
      }
    };
  }
});

// node_modules/php-parser/src/parser/statement.js
var require_statement = __commonJS({
  "node_modules/php-parser/src/parser/statement.js"(exports, module2) {
    "use strict";
    module2.exports = {
      read_top_statements: function() {
        let result = [];
        while (this.token !== this.EOF && this.token !== "}") {
          const statement = this.read_top_statement();
          if (statement) {
            if (Array.isArray(statement)) {
              result = result.concat(statement);
            } else {
              result.push(statement);
            }
          }
        }
        return result;
      },
      read_top_statement: function() {
        let attrs = [];
        if (this.token === this.tok.T_ATTRIBUTE) {
          attrs = this.read_attr_list();
        }
        switch (this.token) {
          case this.tok.T_FUNCTION:
            return this.read_function(false, false, attrs);
          case this.tok.T_ABSTRACT:
          case this.tok.T_FINAL:
          case this.tok.T_CLASS:
            return this.read_class_declaration_statement(attrs);
          case this.tok.T_INTERFACE:
            return this.read_interface_declaration_statement(attrs);
          case this.tok.T_TRAIT:
            return this.read_trait_declaration_statement();
          case this.tok.T_ENUM:
            return this.read_enum_declaration_statement(attrs);
          case this.tok.T_USE:
            return this.read_use_statement();
          case this.tok.T_CONST: {
            const result = this.node("constantstatement");
            const items = this.next().read_const_list();
            this.expectEndOfStatement();
            return result(null, items);
          }
          case this.tok.T_NAMESPACE:
            return this.read_namespace();
          case this.tok.T_HALT_COMPILER: {
            const result = this.node("halt");
            if (this.next().expect("("))
              this.next();
            if (this.expect(")"))
              this.next();
            this.expect(";");
            this.lexer.done = true;
            return result(this.lexer._input.substring(this.lexer.offset));
          }
          default:
            return this.read_statement();
        }
      },
      read_inner_statements: function() {
        let result = [];
        while (this.token != this.EOF && this.token !== "}") {
          const statement = this.read_inner_statement();
          if (statement) {
            if (Array.isArray(statement)) {
              result = result.concat(statement);
            } else {
              result.push(statement);
            }
          }
        }
        return result;
      },
      read_const_list: function() {
        return this.read_list(function() {
          this.expect(this.tok.T_STRING);
          const result = this.node("constant");
          let constName = this.node("identifier");
          const name = this.text();
          this.next();
          constName = constName(name);
          if (this.expect("=")) {
            return result(constName, this.next().read_expr());
          } else {
            return result(constName, null);
          }
        }, ",", false);
      },
      read_declare_list: function() {
        const result = [];
        while (this.token != this.EOF && this.token !== ")") {
          this.expect(this.tok.T_STRING);
          const directive = this.node("declaredirective");
          let key = this.node("identifier");
          const name = this.text();
          this.next();
          key = key(name);
          let value = null;
          if (this.expect("=")) {
            value = this.next().read_expr();
          }
          result.push(directive(key, value));
          if (this.token !== ",")
            break;
          this.next();
        }
        return result;
      },
      read_inner_statement: function() {
        let attrs = [];
        if (this.token === this.tok.T_ATTRIBUTE) {
          attrs = this.read_attr_list();
        }
        switch (this.token) {
          case this.tok.T_FUNCTION: {
            const result = this.read_function(false, false);
            result.attrGroups = attrs;
            return result;
          }
          case this.tok.T_ABSTRACT:
          case this.tok.T_FINAL:
          case this.tok.T_CLASS:
            return this.read_class_declaration_statement();
          case this.tok.T_INTERFACE:
            return this.read_interface_declaration_statement();
          case this.tok.T_TRAIT:
            return this.read_trait_declaration_statement();
          case this.tok.T_ENUM:
            return this.read_enum_declaration_statement();
          case this.tok.T_HALT_COMPILER: {
            this.raiseError("__HALT_COMPILER() can only be used from the outermost scope");
            let node = this.node("halt");
            this.next().expect("(") && this.next();
            this.expect(")") && this.next();
            node = node(this.lexer._input.substring(this.lexer.offset));
            this.expect(";") && this.next();
            return node;
          }
          default:
            return this.read_statement();
        }
      },
      read_statement: function() {
        switch (this.token) {
          case "{":
            return this.read_code_block(false);
          case this.tok.T_IF:
            return this.read_if();
          case this.tok.T_SWITCH:
            return this.read_switch();
          case this.tok.T_FOR:
            return this.read_for();
          case this.tok.T_FOREACH:
            return this.read_foreach();
          case this.tok.T_WHILE:
            return this.read_while();
          case this.tok.T_DO:
            return this.read_do();
          case this.tok.T_COMMENT:
            return this.read_comment();
          case this.tok.T_DOC_COMMENT:
            return this.read_doc_comment();
          case this.tok.T_RETURN: {
            const result = this.node("return");
            this.next();
            const expr = this.read_optional_expr(";");
            this.expectEndOfStatement();
            return result(expr);
          }
          case this.tok.T_BREAK:
          case this.tok.T_CONTINUE: {
            const result = this.node(this.token === this.tok.T_CONTINUE ? "continue" : "break");
            this.next();
            const level = this.read_optional_expr(";");
            this.expectEndOfStatement();
            return result(level);
          }
          case this.tok.T_GLOBAL: {
            const result = this.node("global");
            const items = this.next().read_list(this.read_simple_variable, ",");
            this.expectEndOfStatement();
            return result(items);
          }
          case this.tok.T_STATIC: {
            const current = [this.token, this.lexer.getState()];
            const result = this.node();
            if (this.next().token === this.tok.T_DOUBLE_COLON) {
              this.lexer.tokens.push(current);
              const expr = this.next().read_expr();
              this.expectEndOfStatement(expr);
              return result("expressionstatement", expr);
            }
            if (this.token === this.tok.T_FUNCTION) {
              return this.read_function(true, [0, 1, 0]);
            }
            const items = this.read_variable_declarations();
            this.expectEndOfStatement();
            return result("static", items);
          }
          case this.tok.T_ECHO: {
            const result = this.node("echo");
            const text = this.text();
            const shortForm = text === "<?=" || text === "<%=";
            const expressions = this.next().read_function_list(this.read_expr, ",");
            this.expectEndOfStatement();
            return result(expressions, shortForm);
          }
          case this.tok.T_INLINE_HTML: {
            const value = this.text();
            let prevChar = this.lexer.yylloc.first_offset > 0 ? this.lexer._input[this.lexer.yylloc.first_offset - 1] : null;
            const fixFirstLine = prevChar === "\r" || prevChar === "\n";
            if (fixFirstLine) {
              if (prevChar === "\n" && this.lexer.yylloc.first_offset > 1 && this.lexer._input[this.lexer.yylloc.first_offset - 2] === "\r") {
                prevChar = "\r\n";
              }
            }
            const result = this.node("inline");
            this.next();
            return result(value, fixFirstLine ? prevChar + value : value);
          }
          case this.tok.T_UNSET: {
            const result = this.node("unset");
            this.next().expect("(") && this.next();
            const variables = this.read_function_list(this.read_variable, ",");
            this.expect(")") && this.next();
            this.expect(";") && this.next();
            return result(variables);
          }
          case this.tok.T_DECLARE: {
            const result = this.node("declare");
            const body = [];
            let mode;
            this.next().expect("(") && this.next();
            const directives = this.read_declare_list();
            this.expect(")") && this.next();
            if (this.token === ":") {
              this.next();
              while (this.token != this.EOF && this.token !== this.tok.T_ENDDECLARE) {
                body.push(this.read_top_statement());
              }
              if (body.length === 0 && this.extractDoc && this._docs.length > this._docIndex) {
                body.push(this.node("noop")());
              }
              this.expect(this.tok.T_ENDDECLARE) && this.next();
              this.expectEndOfStatement();
              mode = this.ast.declare.MODE_SHORT;
            } else if (this.token === "{") {
              this.next();
              while (this.token != this.EOF && this.token !== "}") {
                body.push(this.read_top_statement());
              }
              if (body.length === 0 && this.extractDoc && this._docs.length > this._docIndex) {
                body.push(this.node("noop")());
              }
              this.expect("}") && this.next();
              mode = this.ast.declare.MODE_BLOCK;
            } else {
              this.expect(";") && this.next();
              mode = this.ast.declare.MODE_NONE;
            }
            return result(directives, body, mode);
          }
          case this.tok.T_TRY:
            return this.read_try();
          case this.tok.T_THROW: {
            const result = this.node("throw");
            const expr = this.next().read_expr();
            this.expectEndOfStatement();
            return result(expr);
          }
          case ";": {
            this.next();
            return null;
          }
          case this.tok.T_STRING: {
            const result = this.node();
            const current = [this.token, this.lexer.getState()];
            const labelNameText = this.text();
            let labelName = this.node("identifier");
            if (this.next().token === ":") {
              labelName = labelName(labelNameText);
              this.next();
              return result("label", labelName);
            } else {
              labelName.destroy();
            }
            result.destroy();
            this.lexer.tokens.push(current);
            const statement = this.node("expressionstatement");
            const expr = this.next().read_expr();
            this.expectEndOfStatement(expr);
            return statement(expr);
          }
          case this.tok.T_GOTO: {
            const result = this.node("goto");
            let labelName = null;
            if (this.next().expect(this.tok.T_STRING)) {
              labelName = this.node("identifier");
              const name = this.text();
              this.next();
              labelName = labelName(name);
              this.expectEndOfStatement();
            }
            return result(labelName);
          }
          default: {
            const statement = this.node("expressionstatement");
            const expr = this.read_expr();
            this.expectEndOfStatement(expr);
            return statement(expr);
          }
        }
      },
      read_code_block: function(top) {
        const result = this.node("block");
        this.expect("{") && this.next();
        const body = top ? this.read_top_statements() : this.read_inner_statements();
        if (body.length === 0 && this.extractDoc && this._docs.length > this._docIndex) {
          body.push(this.node("noop")());
        }
        this.expect("}") && this.next();
        return result(null, body);
      }
    };
  }
});

// node_modules/php-parser/src/parser/switch.js
var require_switch = __commonJS({
  "node_modules/php-parser/src/parser/switch.js"(exports, module2) {
    "use strict";
    module2.exports = {
      read_switch: function() {
        const result = this.node("switch");
        this.expect(this.tok.T_SWITCH) && this.next();
        this.expect("(") && this.next();
        const test = this.read_expr();
        this.expect(")") && this.next();
        const shortForm = this.token === ":";
        const body = this.read_switch_case_list();
        return result(test, body, shortForm);
      },
      read_switch_case_list: function() {
        let expect = null;
        const result = this.node("block");
        const items = [];
        if (this.token === "{") {
          expect = "}";
        } else if (this.token === ":") {
          expect = this.tok.T_ENDSWITCH;
        } else {
          this.expect(["{", ":"]);
        }
        this.next();
        if (this.token === ";") {
          this.next();
        }
        while (this.token !== this.EOF && this.token !== expect) {
          items.push(this.read_case_list(expect));
        }
        if (items.length === 0 && this.extractDoc && this._docs.length > this._docIndex) {
          items.push(this.node("noop")());
        }
        this.expect(expect) && this.next();
        if (expect === this.tok.T_ENDSWITCH) {
          this.expectEndOfStatement();
        }
        return result(null, items);
      },
      read_case_list: function(stopToken) {
        const result = this.node("case");
        let test = null;
        if (this.token === this.tok.T_CASE) {
          test = this.next().read_expr();
        } else if (this.token === this.tok.T_DEFAULT) {
          this.next();
        } else {
          this.expect([this.tok.T_CASE, this.tok.T_DEFAULT]);
        }
        this.expect([":", ";"]) && this.next();
        const body = this.node("block");
        const items = [];
        while (this.token !== this.EOF && this.token !== stopToken && this.token !== this.tok.T_CASE && this.token !== this.tok.T_DEFAULT) {
          items.push(this.read_inner_statement());
        }
        return result(test, body(null, items));
      }
    };
  }
});

// node_modules/php-parser/src/parser/try.js
var require_try = __commonJS({
  "node_modules/php-parser/src/parser/try.js"(exports, module2) {
    "use strict";
    module2.exports = {
      read_try: function() {
        this.expect(this.tok.T_TRY);
        const result = this.node("try");
        let always = null;
        const catches = [];
        const body = this.next().read_statement();
        while (this.token === this.tok.T_CATCH) {
          const item = this.node("catch");
          this.next().expect("(") && this.next();
          const what = this.read_list(this.read_namespace_name, "|", false);
          let variable = null;
          if (this.version < 800 || this.token === this.tok.T_VARIABLE) {
            variable = this.read_variable(true, false);
          }
          this.expect(")");
          catches.push(item(this.next().read_statement(), what, variable));
        }
        if (this.token === this.tok.T_FINALLY) {
          always = this.next().read_statement();
        }
        return result(body, catches, always);
      }
    };
  }
});

// node_modules/php-parser/src/parser/utils.js
var require_utils2 = __commonJS({
  "node_modules/php-parser/src/parser/utils.js"(exports, module2) {
    "use strict";
    module2.exports = {
      read_short_form: function(token) {
        const body = this.node("block");
        const items = [];
        if (this.expect(":"))
          this.next();
        while (this.token != this.EOF && this.token !== token) {
          items.push(this.read_inner_statement());
        }
        if (items.length === 0 && this.extractDoc && this._docs.length > this._docIndex) {
          items.push(this.node("noop")());
        }
        if (this.expect(token))
          this.next();
        this.expectEndOfStatement();
        return body(null, items);
      },
      read_function_list: function(item, separator) {
        const result = [];
        do {
          if (this.token == separator && this.version >= 703 && result.length > 0) {
            result.push(this.node("noop")());
            break;
          }
          result.push(item.apply(this, []));
          if (this.token != separator) {
            break;
          }
          if (this.next().token == ")" && this.version >= 703) {
            break;
          }
        } while (this.token != this.EOF);
        return result;
      },
      read_list: function(item, separator, preserveFirstSeparator) {
        const result = [];
        if (this.token == separator) {
          if (preserveFirstSeparator) {
            result.push(typeof item === "function" ? this.node("noop")() : null);
          }
          this.next();
        }
        if (typeof item === "function") {
          do {
            const itemResult = item.apply(this, []);
            if (itemResult) {
              result.push(itemResult);
            }
            if (this.token != separator) {
              break;
            }
          } while (this.next().token != this.EOF);
        } else {
          if (this.expect(item)) {
            result.push(this.text());
          } else {
            return [];
          }
          while (this.next().token != this.EOF) {
            if (this.token != separator)
              break;
            if (this.next().token != item)
              break;
            result.push(this.text());
          }
        }
        return result;
      },
      read_name_list: function() {
        return this.read_list(this.read_namespace_name, ",", false);
      },
      read_byref: function(cb) {
        let byref = this.node("byref");
        this.next();
        byref = byref(null);
        const result = cb();
        if (result) {
          this.ast.swapLocations(result, byref, result, this);
          result.byref = true;
        }
        return result;
      },
      read_variable_declarations: function() {
        return this.read_list(function() {
          const node = this.node("staticvariable");
          let variable = this.node("variable");
          if (this.expect(this.tok.T_VARIABLE)) {
            const name = this.text().substring(1);
            this.next();
            variable = variable(name, false);
          } else {
            variable = variable("#ERR", false);
          }
          if (this.token === "=") {
            return node(variable, this.next().read_expr());
          } else {
            return variable;
          }
        }, ",");
      },
      read_extends_from: function() {
        if (this.token === this.tok.T_EXTENDS) {
          return this.next().read_namespace_name();
        }
        return null;
      },
      read_interface_extends_list: function() {
        if (this.token === this.tok.T_EXTENDS) {
          return this.next().read_name_list();
        }
        return null;
      },
      read_implements_list: function() {
        if (this.token === this.tok.T_IMPLEMENTS) {
          return this.next().read_name_list();
        }
        return null;
      }
    };
  }
});

// node_modules/php-parser/src/parser/variable.js
var require_variable = __commonJS({
  "node_modules/php-parser/src/parser/variable.js"(exports, module2) {
    "use strict";
    module2.exports = {
      read_variable: function(read_only, encapsed) {
        let result;
        if (this.token === "&") {
          return this.read_byref(this.read_variable.bind(this, read_only, encapsed));
        }
        if (this.is([this.tok.T_VARIABLE, "$"])) {
          result = this.read_reference_variable(encapsed);
        } else if (this.is([
          this.tok.T_NS_SEPARATOR,
          this.tok.T_STRING,
          this.tok.T_NAME_RELATIVE,
          this.tok.T_NAME_QUALIFIED,
          this.tok.T_NAME_FULLY_QUALIFIED,
          this.tok.T_NAMESPACE
        ])) {
          result = this.node();
          const name = this.read_namespace_name();
          if (this.token != this.tok.T_DOUBLE_COLON && this.token != "(" && ["parentreference", "selfreference"].indexOf(name.kind) === -1) {
            const literal = name.name.toLowerCase();
            if (literal === "true") {
              result = name.destroy(result("boolean", true, name.name));
            } else if (literal === "false") {
              result = name.destroy(result("boolean", false, name.name));
            } else if (literal === "null") {
              result = name.destroy(result("nullkeyword", name.name));
            } else {
              result.destroy(name);
              result = name;
            }
          } else {
            result.destroy(name);
            result = name;
          }
        } else if (this.token === this.tok.T_STATIC) {
          result = this.node("staticreference");
          const raw = this.text();
          this.next();
          result = result(raw);
        } else {
          this.expect("VARIABLE");
        }
        if (this.token === this.tok.T_DOUBLE_COLON) {
          result = this.read_static_getter(result, encapsed);
        }
        return this.recursive_variable_chain_scan(result, read_only, encapsed);
      },
      read_static_getter: function(what, encapsed) {
        const result = this.node("staticlookup");
        let offset, name;
        if (this.next().is([this.tok.T_VARIABLE, "$"])) {
          offset = this.read_reference_variable(encapsed);
        } else if (this.token === this.tok.T_STRING || this.token === this.tok.T_CLASS || this.version >= 700 && this.is("IDENTIFIER")) {
          offset = this.node("identifier");
          name = this.text();
          this.next();
          offset = offset(name);
        } else if (this.token === "{") {
          offset = this.node("literal");
          name = this.next().read_expr();
          this.expect("}") && this.next();
          offset = offset("literal", name, null);
          this.expect("(");
        } else {
          this.error([this.tok.T_VARIABLE, this.tok.T_STRING]);
          offset = this.node("identifier");
          name = this.text();
          this.next();
          offset = offset(name);
        }
        return result(what, offset);
      },
      read_what: function(is_static_lookup = false) {
        let what = null;
        let name = null;
        switch (this.next().token) {
          case this.tok.T_STRING:
            what = this.node("identifier");
            name = this.text();
            this.next();
            what = what(name);
            if (is_static_lookup && this.token === this.tok.T_OBJECT_OPERATOR) {
              this.error();
            }
            break;
          case this.tok.T_VARIABLE:
            what = this.node("variable");
            name = this.text().substring(1);
            this.next();
            what = what(name, false);
            break;
          case "$":
            what = this.node();
            this.next().expect(["$", "{", this.tok.T_VARIABLE]);
            if (this.token === "{") {
              name = this.next().read_expr();
              this.expect("}") && this.next();
              what = what("variable", name, true);
            } else {
              name = this.read_expr();
              what = what("variable", name, false);
            }
            break;
          case "{":
            what = this.node("encapsedpart");
            name = this.next().read_expr();
            this.expect("}") && this.next();
            what = what(name, "complex", false);
            break;
          default:
            this.error([this.tok.T_STRING, this.tok.T_VARIABLE, "$", "{"]);
            what = this.node("identifier");
            name = this.text();
            this.next();
            what = what(name);
            break;
        }
        return what;
      },
      recursive_variable_chain_scan: function(result, read_only, encapsed) {
        let node, offset;
        recursive_scan_loop:
          while (this.token != this.EOF) {
            switch (this.token) {
              case "(":
                if (read_only) {
                  return result;
                } else {
                  result = this.node("call")(result, this.read_argument_list());
                }
                break;
              case "[":
              case "{": {
                const backet = this.token;
                const isSquareBracket = backet === "[";
                node = this.node("offsetlookup");
                this.next();
                offset = false;
                if (encapsed) {
                  offset = this.read_encaps_var_offset();
                  this.expect(isSquareBracket ? "]" : "}") && this.next();
                } else {
                  const isCallableVariable = isSquareBracket ? this.token !== "]" : this.token !== "}";
                  if (isCallableVariable) {
                    offset = this.read_expr();
                    this.expect(isSquareBracket ? "]" : "}") && this.next();
                  } else {
                    this.next();
                  }
                }
                result = node(result, offset);
                break;
              }
              case this.tok.T_DOUBLE_COLON:
                if (result.kind === "staticlookup" && result.offset.kind === "identifier") {
                  this.error();
                }
                node = this.node("staticlookup");
                result = node(result, this.read_what(true));
                break;
              case this.tok.T_OBJECT_OPERATOR: {
                node = this.node("propertylookup");
                result = node(result, this.read_what());
                break;
              }
              case this.tok.T_NULLSAFE_OBJECT_OPERATOR: {
                node = this.node("nullsafepropertylookup");
                result = node(result, this.read_what());
                break;
              }
              default:
                break recursive_scan_loop;
            }
          }
        return result;
      },
      read_encaps_var_offset: function() {
        let offset = this.node();
        if (this.token === this.tok.T_STRING) {
          const text = this.text();
          this.next();
          offset = offset("identifier", text);
        } else if (this.token === this.tok.T_NUM_STRING) {
          const num = this.text();
          this.next();
          offset = offset("number", num, null);
        } else if (this.token === "-") {
          this.next();
          const num = -1 * this.text();
          this.expect(this.tok.T_NUM_STRING) && this.next();
          offset = offset("number", num, null);
        } else if (this.token === this.tok.T_VARIABLE) {
          const name = this.text().substring(1);
          this.next();
          offset = offset("variable", name, false);
        } else {
          this.expect([
            this.tok.T_STRING,
            this.tok.T_NUM_STRING,
            "-",
            this.tok.T_VARIABLE
          ]);
          const text = this.text();
          this.next();
          offset = offset("identifier", text);
        }
        return offset;
      },
      read_reference_variable: function(encapsed) {
        let result = this.read_simple_variable();
        let offset;
        while (this.token != this.EOF) {
          const node = this.node();
          if (this.token == "{" && !encapsed) {
            offset = this.next().read_expr();
            this.expect("}") && this.next();
            result = node("offsetlookup", result, offset);
          } else {
            node.destroy();
            break;
          }
        }
        return result;
      },
      read_simple_variable: function() {
        let result = this.node("variable");
        let name;
        if (this.expect([this.tok.T_VARIABLE, "$"]) && this.token === this.tok.T_VARIABLE) {
          name = this.text().substring(1);
          this.next();
          result = result(name, false);
        } else {
          if (this.token === "$")
            this.next();
          switch (this.token) {
            case "{": {
              const expr = this.next().read_expr();
              this.expect("}") && this.next();
              result = result(expr, true);
              break;
            }
            case "$":
              result = result(this.read_simple_variable(), false);
              break;
            case this.tok.T_VARIABLE: {
              name = this.text().substring(1);
              const node = this.node("variable");
              this.next();
              result = result(node(name, false), false);
              break;
            }
            default:
              this.error(["{", "$", this.tok.T_VARIABLE]);
              name = this.text();
              this.next();
              result = result(name, false);
          }
        }
        return result;
      }
    };
  }
});

// node_modules/php-parser/src/parser.js
var require_parser = __commonJS({
  "node_modules/php-parser/src/parser.js"(exports, module2) {
    "use strict";
    var Position14 = require_position();
    function isNumber(n) {
      return n != "." && n != "," && !isNaN(parseFloat(n)) && isFinite(n);
    }
    var Parser = function(lexer, ast) {
      this.lexer = lexer;
      this.ast = ast;
      this.tok = lexer.tok;
      this.EOF = lexer.EOF;
      this.token = null;
      this.prev = null;
      this.debug = false;
      this.version = 801;
      this.extractDoc = false;
      this.extractTokens = false;
      this.suppressErrors = false;
      const mapIt = function(item) {
        return [item, null];
      };
      this.entries = {
        IDENTIFIER: new Map([
          this.tok.T_ABSTRACT,
          this.tok.T_ARRAY,
          this.tok.T_AS,
          this.tok.T_BREAK,
          this.tok.T_CALLABLE,
          this.tok.T_CASE,
          this.tok.T_CATCH,
          this.tok.T_CLASS,
          this.tok.T_CLASS_C,
          this.tok.T_CLONE,
          this.tok.T_CONST,
          this.tok.T_CONTINUE,
          this.tok.T_DECLARE,
          this.tok.T_DEFAULT,
          this.tok.T_DIR,
          this.tok.T_DO,
          this.tok.T_ECHO,
          this.tok.T_ELSE,
          this.tok.T_ELSEIF,
          this.tok.T_EMPTY,
          this.tok.T_ENDDECLARE,
          this.tok.T_ENDFOR,
          this.tok.T_ENDFOREACH,
          this.tok.T_ENDIF,
          this.tok.T_ENDSWITCH,
          this.tok.T_ENDWHILE,
          this.tok.T_ENUM,
          this.tok.T_EVAL,
          this.tok.T_EXIT,
          this.tok.T_EXTENDS,
          this.tok.T_FILE,
          this.tok.T_FINAL,
          this.tok.T_FINALLY,
          this.tok.T_FN,
          this.tok.T_FOR,
          this.tok.T_FOREACH,
          this.tok.T_FUNC_C,
          this.tok.T_FUNCTION,
          this.tok.T_GLOBAL,
          this.tok.T_GOTO,
          this.tok.T_IF,
          this.tok.T_IMPLEMENTS,
          this.tok.T_INCLUDE,
          this.tok.T_INCLUDE_ONCE,
          this.tok.T_INSTANCEOF,
          this.tok.T_INSTEADOF,
          this.tok.T_INTERFACE,
          this.tok.T_ISSET,
          this.tok.T_LINE,
          this.tok.T_LIST,
          this.tok.T_LOGICAL_AND,
          this.tok.T_LOGICAL_OR,
          this.tok.T_LOGICAL_XOR,
          this.tok.T_MATCH,
          this.tok.T_METHOD_C,
          this.tok.T_NAMESPACE,
          this.tok.T_NEW,
          this.tok.T_NS_C,
          this.tok.T_PRINT,
          this.tok.T_PRIVATE,
          this.tok.T_PROTECTED,
          this.tok.T_PUBLIC,
          this.tok.T_READ_ONLY,
          this.tok.T_REQUIRE,
          this.tok.T_REQUIRE_ONCE,
          this.tok.T_RETURN,
          this.tok.T_STATIC,
          this.tok.T_SWITCH,
          this.tok.T_THROW,
          this.tok.T_TRAIT,
          this.tok.T_TRY,
          this.tok.T_UNSET,
          this.tok.T_USE,
          this.tok.T_VAR,
          this.tok.T_WHILE,
          this.tok.T_YIELD
        ].map(mapIt)),
        VARIABLE: new Map([
          this.tok.T_VARIABLE,
          "$",
          "&",
          this.tok.T_STRING,
          this.tok.T_NAME_RELATIVE,
          this.tok.T_NAME_QUALIFIED,
          this.tok.T_NAME_FULLY_QUALIFIED,
          this.tok.T_NAMESPACE,
          this.tok.T_STATIC
        ].map(mapIt)),
        SCALAR: new Map([
          this.tok.T_CONSTANT_ENCAPSED_STRING,
          this.tok.T_START_HEREDOC,
          this.tok.T_LNUMBER,
          this.tok.T_DNUMBER,
          this.tok.T_ARRAY,
          "[",
          this.tok.T_CLASS_C,
          this.tok.T_TRAIT_C,
          this.tok.T_FUNC_C,
          this.tok.T_METHOD_C,
          this.tok.T_LINE,
          this.tok.T_FILE,
          this.tok.T_DIR,
          this.tok.T_NS_C,
          '"',
          'b"',
          'B"',
          "-",
          this.tok.T_NS_SEPARATOR
        ].map(mapIt)),
        T_MAGIC_CONST: new Map([
          this.tok.T_CLASS_C,
          this.tok.T_TRAIT_C,
          this.tok.T_FUNC_C,
          this.tok.T_METHOD_C,
          this.tok.T_LINE,
          this.tok.T_FILE,
          this.tok.T_DIR,
          this.tok.T_NS_C
        ].map(mapIt)),
        T_MEMBER_FLAGS: new Map([
          this.tok.T_PUBLIC,
          this.tok.T_PRIVATE,
          this.tok.T_PROTECTED,
          this.tok.T_STATIC,
          this.tok.T_ABSTRACT,
          this.tok.T_FINAL
        ].map(mapIt)),
        EOS: new Map([";", this.EOF, this.tok.T_INLINE_HTML].map(mapIt)),
        EXPR: new Map([
          "@",
          "-",
          "+",
          "!",
          "~",
          "(",
          "`",
          this.tok.T_LIST,
          this.tok.T_CLONE,
          this.tok.T_INC,
          this.tok.T_DEC,
          this.tok.T_NEW,
          this.tok.T_ISSET,
          this.tok.T_EMPTY,
          this.tok.T_MATCH,
          this.tok.T_INCLUDE,
          this.tok.T_INCLUDE_ONCE,
          this.tok.T_REQUIRE,
          this.tok.T_REQUIRE_ONCE,
          this.tok.T_EVAL,
          this.tok.T_INT_CAST,
          this.tok.T_DOUBLE_CAST,
          this.tok.T_STRING_CAST,
          this.tok.T_ARRAY_CAST,
          this.tok.T_OBJECT_CAST,
          this.tok.T_BOOL_CAST,
          this.tok.T_UNSET_CAST,
          this.tok.T_EXIT,
          this.tok.T_PRINT,
          this.tok.T_YIELD,
          this.tok.T_STATIC,
          this.tok.T_FUNCTION,
          this.tok.T_FN,
          this.tok.T_VARIABLE,
          "$",
          this.tok.T_NS_SEPARATOR,
          this.tok.T_STRING,
          this.tok.T_NAME_RELATIVE,
          this.tok.T_NAME_QUALIFIED,
          this.tok.T_NAME_FULLY_QUALIFIED,
          this.tok.T_STRING,
          this.tok.T_CONSTANT_ENCAPSED_STRING,
          this.tok.T_START_HEREDOC,
          this.tok.T_LNUMBER,
          this.tok.T_DNUMBER,
          this.tok.T_ARRAY,
          "[",
          this.tok.T_CLASS_C,
          this.tok.T_TRAIT_C,
          this.tok.T_FUNC_C,
          this.tok.T_METHOD_C,
          this.tok.T_LINE,
          this.tok.T_FILE,
          this.tok.T_DIR,
          this.tok.T_NS_C,
          '"',
          'b"',
          'B"',
          "-",
          this.tok.T_NS_SEPARATOR
        ].map(mapIt))
      };
    };
    Parser.prototype.getTokenName = function(token) {
      if (!isNumber(token)) {
        return "'" + token + "'";
      } else {
        if (token == this.EOF)
          return "the end of file (EOF)";
        return this.lexer.engine.tokens.values[token];
      }
    };
    Parser.prototype.parse = function(code, filename) {
      this._errors = [];
      this.filename = filename || "eval";
      this.currentNamespace = [""];
      if (this.extractDoc) {
        this._docs = [];
      } else {
        this._docs = null;
      }
      if (this.extractTokens) {
        this._tokens = [];
      } else {
        this._tokens = null;
      }
      this._docIndex = 0;
      this._lastNode = null;
      this.lexer.setInput(code);
      this.lexer.all_tokens = this.extractTokens;
      this.lexer.comment_tokens = this.extractDoc;
      this.length = this.lexer._input.length;
      this.innerList = false;
      this.innerListForm = false;
      const program = this.node("program");
      const childs = [];
      this.next();
      while (this.token != this.EOF) {
        childs.push(this.read_start());
      }
      if (childs.length === 0 && this.extractDoc && this._docs.length > this._docIndex) {
        childs.push(this.node("noop")());
      }
      this.prev = [
        this.lexer.yylloc.last_line,
        this.lexer.yylloc.last_column,
        this.lexer.offset
      ];
      const result = program(childs, this._errors, this._docs, this._tokens);
      if (this.debug) {
        const errors = this.ast.checkNodes();
        if (errors.length > 0) {
          errors.forEach(function(error) {
            if (error.position) {
              console.log("Node at line " + error.position.line + ", column " + error.position.column);
            }
            console.log(error.stack.join("\n"));
          });
          throw new Error("Some nodes are not closed");
        }
      }
      return result;
    };
    Parser.prototype.raiseError = function(message, msgExpect, expect, token) {
      message += " on line " + this.lexer.yylloc.first_line;
      if (!this.suppressErrors) {
        const err = new SyntaxError(message, this.filename, this.lexer.yylloc.first_line);
        err.lineNumber = this.lexer.yylloc.first_line;
        err.fileName = this.filename;
        err.columnNumber = this.lexer.yylloc.first_column;
        throw err;
      }
      const node = this.ast.prepare("error", null, this)(message, token, this.lexer.yylloc.first_line, expect);
      this._errors.push(node);
      return node;
    };
    Parser.prototype.error = function(expect) {
      let msg = "Parse Error : syntax error";
      let token = this.getTokenName(this.token);
      let msgExpect = "";
      if (this.token !== this.EOF) {
        if (isNumber(this.token)) {
          let symbol = this.text();
          if (symbol.length > 10) {
            symbol = symbol.substring(0, 7) + "...";
          }
          token = "'" + symbol + "' (" + token + ")";
        }
        msg += ", unexpected " + token;
      }
      if (expect && !Array.isArray(expect)) {
        if (isNumber(expect) || expect.length === 1) {
          msgExpect = ", expecting " + this.getTokenName(expect);
        }
        msg += msgExpect;
      }
      return this.raiseError(msg, msgExpect, expect, token);
    };
    Parser.prototype.position = function() {
      return new Position14(this.lexer.yylloc.first_line, this.lexer.yylloc.first_column, this.lexer.yylloc.first_offset);
    };
    Parser.prototype.node = function(name) {
      if (this.extractDoc) {
        let docs = null;
        if (this._docIndex < this._docs.length) {
          docs = this._docs.slice(this._docIndex);
          this._docIndex = this._docs.length;
          if (this.debug) {
            console.log(new Error("Append docs on " + name));
            console.log(docs);
          }
        }
        const node = this.ast.prepare(name, docs, this);
        node.postBuild = function(self) {
          if (this._docIndex < this._docs.length) {
            if (this._lastNode) {
              const offset = this.prev[2];
              let max = this._docIndex;
              for (; max < this._docs.length; max++) {
                if (this._docs[max].offset > offset) {
                  break;
                }
              }
              if (max > this._docIndex) {
                this._lastNode.setTrailingComments(this._docs.slice(this._docIndex, max));
                this._docIndex = max;
              }
            } else if (this.token === this.EOF) {
              self.setTrailingComments(this._docs.slice(this._docIndex));
              this._docIndex = this._docs.length;
            }
          }
          this._lastNode = self;
        }.bind(this);
        return node;
      }
      return this.ast.prepare(name, null, this);
    };
    Parser.prototype.expectEndOfStatement = function(node) {
      if (this.token === ";") {
        if (node && this.lexer.yytext === ";") {
          node.includeToken(this);
        }
      } else if (this.token !== this.tok.T_INLINE_HTML && this.token !== this.EOF) {
        this.error(";");
        return false;
      }
      this.next();
      return true;
    };
    var ignoreStack = ["parser.next", "parser.node", "parser.showlog"];
    Parser.prototype.showlog = function() {
      const stack = new Error().stack.split("\n");
      let line;
      for (let offset = 2; offset < stack.length; offset++) {
        line = stack[offset].trim();
        let found = false;
        for (let i = 0; i < ignoreStack.length; i++) {
          if (line.substring(3, 3 + ignoreStack[i].length) === ignoreStack[i]) {
            found = true;
            break;
          }
        }
        if (!found) {
          break;
        }
      }
      console.log("Line " + this.lexer.yylloc.first_line + " : " + this.getTokenName(this.token) + ">" + this.lexer.yytext + "< @-->" + line);
      return this;
    };
    Parser.prototype.expect = function(token) {
      if (Array.isArray(token)) {
        if (token.indexOf(this.token) === -1) {
          this.error(token);
          return false;
        }
      } else if (this.token != token) {
        this.error(token);
        return false;
      }
      return true;
    };
    Parser.prototype.text = function() {
      return this.lexer.yytext;
    };
    Parser.prototype.next = function() {
      if (this.token !== ";" || this.lexer.yytext === ";") {
        this.prev = [
          this.lexer.yylloc.last_line,
          this.lexer.yylloc.last_column,
          this.lexer.offset
        ];
      }
      this.lex();
      if (this.debug) {
        this.showlog();
      }
      if (this.extractDoc) {
        while (this.token === this.tok.T_COMMENT || this.token === this.tok.T_DOC_COMMENT) {
          if (this.token === this.tok.T_COMMENT) {
            this._docs.push(this.read_comment());
          } else {
            this._docs.push(this.read_doc_comment());
          }
        }
      }
      return this;
    };
    Parser.prototype.peek = function() {
      const lexerState = this.lexer.getState();
      const nextToken = this.lexer.lex();
      this.lexer.setState(lexerState);
      return nextToken;
    };
    Parser.prototype.lex = function() {
      if (this.extractTokens) {
        do {
          this.token = this.lexer.lex() || this.EOF;
          if (this.token === this.EOF)
            return this;
          let entry = this.lexer.yytext;
          if (Object.prototype.hasOwnProperty.call(this.lexer.engine.tokens.values, this.token)) {
            entry = [
              this.lexer.engine.tokens.values[this.token],
              entry,
              this.lexer.yylloc.first_line,
              this.lexer.yylloc.first_offset,
              this.lexer.offset
            ];
          } else {
            entry = [
              null,
              entry,
              this.lexer.yylloc.first_line,
              this.lexer.yylloc.first_offset,
              this.lexer.offset
            ];
          }
          this._tokens.push(entry);
          if (this.token === this.tok.T_CLOSE_TAG) {
            this.token = ";";
            return this;
          } else if (this.token === this.tok.T_OPEN_TAG_WITH_ECHO) {
            this.token = this.tok.T_ECHO;
            return this;
          }
        } while (this.token === this.tok.T_WHITESPACE || !this.extractDoc && (this.token === this.tok.T_COMMENT || this.token === this.tok.T_DOC_COMMENT) || this.token === this.tok.T_OPEN_TAG);
      } else {
        this.token = this.lexer.lex() || this.EOF;
      }
      return this;
    };
    Parser.prototype.is = function(type) {
      if (Array.isArray(type)) {
        return type.indexOf(this.token) !== -1;
      }
      return this.entries[type].has(this.token);
    };
    [
      require_array(),
      require_class(),
      require_comment(),
      require_expr(),
      require_enum(),
      require_function(),
      require_if(),
      require_loops(),
      require_main(),
      require_namespace(),
      require_scalar(),
      require_statement(),
      require_switch(),
      require_try(),
      require_utils2(),
      require_variable()
    ].forEach(function(ext) {
      for (const k in ext) {
        if (Object.prototype.hasOwnProperty.call(Parser.prototype, k)) {
          throw new Error("Function " + k + " is already defined - collision");
        }
        Parser.prototype[k] = ext[k];
      }
    });
    module2.exports = Parser;
  }
});

// node_modules/php-parser/src/tokens.js
var require_tokens2 = __commonJS({
  "node_modules/php-parser/src/tokens.js"(exports, module2) {
    "use strict";
    var tokens = {
      values: {
        101: "T_HALT_COMPILER",
        102: "T_USE",
        103: "T_ENCAPSED_AND_WHITESPACE",
        104: "T_OBJECT_OPERATOR",
        105: "T_STRING",
        106: "T_DOLLAR_OPEN_CURLY_BRACES",
        107: "T_STRING_VARNAME",
        108: "T_CURLY_OPEN",
        109: "T_NUM_STRING",
        110: "T_ISSET",
        111: "T_EMPTY",
        112: "T_INCLUDE",
        113: "T_INCLUDE_ONCE",
        114: "T_EVAL",
        115: "T_REQUIRE",
        116: "T_REQUIRE_ONCE",
        117: "T_NAMESPACE",
        118: "T_NS_SEPARATOR",
        119: "T_AS",
        120: "T_IF",
        121: "T_ENDIF",
        122: "T_WHILE",
        123: "T_DO",
        124: "T_FOR",
        125: "T_SWITCH",
        126: "T_BREAK",
        127: "T_CONTINUE",
        128: "T_RETURN",
        129: "T_GLOBAL",
        130: "T_STATIC",
        131: "T_ECHO",
        132: "T_INLINE_HTML",
        133: "T_UNSET",
        134: "T_FOREACH",
        135: "T_DECLARE",
        136: "T_TRY",
        137: "T_THROW",
        138: "T_GOTO",
        139: "T_FINALLY",
        140: "T_CATCH",
        141: "T_ENDDECLARE",
        142: "T_LIST",
        143: "T_CLONE",
        144: "T_PLUS_EQUAL",
        145: "T_MINUS_EQUAL",
        146: "T_MUL_EQUAL",
        147: "T_DIV_EQUAL",
        148: "T_CONCAT_EQUAL",
        149: "T_MOD_EQUAL",
        150: "T_AND_EQUAL",
        151: "T_OR_EQUAL",
        152: "T_XOR_EQUAL",
        153: "T_SL_EQUAL",
        154: "T_SR_EQUAL",
        155: "T_INC",
        156: "T_DEC",
        157: "T_BOOLEAN_OR",
        158: "T_BOOLEAN_AND",
        159: "T_LOGICAL_OR",
        160: "T_LOGICAL_AND",
        161: "T_LOGICAL_XOR",
        162: "T_SL",
        163: "T_SR",
        164: "T_IS_IDENTICAL",
        165: "T_IS_NOT_IDENTICAL",
        166: "T_IS_EQUAL",
        167: "T_IS_NOT_EQUAL",
        168: "T_IS_SMALLER_OR_EQUAL",
        169: "T_IS_GREATER_OR_EQUAL",
        170: "T_INSTANCEOF",
        171: "T_INT_CAST",
        172: "T_DOUBLE_CAST",
        173: "T_STRING_CAST",
        174: "T_ARRAY_CAST",
        175: "T_OBJECT_CAST",
        176: "T_BOOL_CAST",
        177: "T_UNSET_CAST",
        178: "T_EXIT",
        179: "T_PRINT",
        180: "T_YIELD",
        181: "T_YIELD_FROM",
        182: "T_FUNCTION",
        183: "T_DOUBLE_ARROW",
        184: "T_DOUBLE_COLON",
        185: "T_ARRAY",
        186: "T_CALLABLE",
        187: "T_CLASS",
        188: "T_ABSTRACT",
        189: "T_TRAIT",
        190: "T_FINAL",
        191: "T_EXTENDS",
        192: "T_INTERFACE",
        193: "T_IMPLEMENTS",
        194: "T_VAR",
        195: "T_PUBLIC",
        196: "T_PROTECTED",
        197: "T_PRIVATE",
        198: "T_CONST",
        199: "T_NEW",
        200: "T_INSTEADOF",
        201: "T_ELSEIF",
        202: "T_ELSE",
        203: "T_ENDSWITCH",
        204: "T_CASE",
        205: "T_DEFAULT",
        206: "T_ENDFOR",
        207: "T_ENDFOREACH",
        208: "T_ENDWHILE",
        209: "T_CONSTANT_ENCAPSED_STRING",
        210: "T_LNUMBER",
        211: "T_DNUMBER",
        212: "T_LINE",
        213: "T_FILE",
        214: "T_DIR",
        215: "T_TRAIT_C",
        216: "T_METHOD_C",
        217: "T_FUNC_C",
        218: "T_NS_C",
        219: "T_START_HEREDOC",
        220: "T_END_HEREDOC",
        221: "T_CLASS_C",
        222: "T_VARIABLE",
        223: "T_OPEN_TAG",
        224: "T_OPEN_TAG_WITH_ECHO",
        225: "T_CLOSE_TAG",
        226: "T_WHITESPACE",
        227: "T_COMMENT",
        228: "T_DOC_COMMENT",
        229: "T_ELLIPSIS",
        230: "T_COALESCE",
        231: "T_POW",
        232: "T_POW_EQUAL",
        233: "T_SPACESHIP",
        234: "T_COALESCE_EQUAL",
        235: "T_FN",
        236: "T_NULLSAFE_OBJECT_OPERATOR",
        237: "T_MATCH",
        238: "T_ATTRIBUTE",
        239: "T_ENUM",
        240: "T_READ_ONLY",
        241: "T_NAME_RELATIVE",
        242: "T_NAME_QUALIFIED",
        243: "T_NAME_FULLY_QUALIFIED"
      },
      names: {
        T_HALT_COMPILER: 101,
        T_USE: 102,
        T_ENCAPSED_AND_WHITESPACE: 103,
        T_OBJECT_OPERATOR: 104,
        T_STRING: 105,
        T_DOLLAR_OPEN_CURLY_BRACES: 106,
        T_STRING_VARNAME: 107,
        T_CURLY_OPEN: 108,
        T_NUM_STRING: 109,
        T_ISSET: 110,
        T_EMPTY: 111,
        T_INCLUDE: 112,
        T_INCLUDE_ONCE: 113,
        T_EVAL: 114,
        T_REQUIRE: 115,
        T_REQUIRE_ONCE: 116,
        T_NAMESPACE: 117,
        T_NS_SEPARATOR: 118,
        T_AS: 119,
        T_IF: 120,
        T_ENDIF: 121,
        T_WHILE: 122,
        T_DO: 123,
        T_FOR: 124,
        T_SWITCH: 125,
        T_BREAK: 126,
        T_CONTINUE: 127,
        T_RETURN: 128,
        T_GLOBAL: 129,
        T_STATIC: 130,
        T_ECHO: 131,
        T_INLINE_HTML: 132,
        T_UNSET: 133,
        T_FOREACH: 134,
        T_DECLARE: 135,
        T_TRY: 136,
        T_THROW: 137,
        T_GOTO: 138,
        T_FINALLY: 139,
        T_CATCH: 140,
        T_ENDDECLARE: 141,
        T_LIST: 142,
        T_CLONE: 143,
        T_PLUS_EQUAL: 144,
        T_MINUS_EQUAL: 145,
        T_MUL_EQUAL: 146,
        T_DIV_EQUAL: 147,
        T_CONCAT_EQUAL: 148,
        T_MOD_EQUAL: 149,
        T_AND_EQUAL: 150,
        T_OR_EQUAL: 151,
        T_XOR_EQUAL: 152,
        T_SL_EQUAL: 153,
        T_SR_EQUAL: 154,
        T_INC: 155,
        T_DEC: 156,
        T_BOOLEAN_OR: 157,
        T_BOOLEAN_AND: 158,
        T_LOGICAL_OR: 159,
        T_LOGICAL_AND: 160,
        T_LOGICAL_XOR: 161,
        T_SL: 162,
        T_SR: 163,
        T_IS_IDENTICAL: 164,
        T_IS_NOT_IDENTICAL: 165,
        T_IS_EQUAL: 166,
        T_IS_NOT_EQUAL: 167,
        T_IS_SMALLER_OR_EQUAL: 168,
        T_IS_GREATER_OR_EQUAL: 169,
        T_INSTANCEOF: 170,
        T_INT_CAST: 171,
        T_DOUBLE_CAST: 172,
        T_STRING_CAST: 173,
        T_ARRAY_CAST: 174,
        T_OBJECT_CAST: 175,
        T_BOOL_CAST: 176,
        T_UNSET_CAST: 177,
        T_EXIT: 178,
        T_PRINT: 179,
        T_YIELD: 180,
        T_YIELD_FROM: 181,
        T_FUNCTION: 182,
        T_DOUBLE_ARROW: 183,
        T_DOUBLE_COLON: 184,
        T_ARRAY: 185,
        T_CALLABLE: 186,
        T_CLASS: 187,
        T_ABSTRACT: 188,
        T_TRAIT: 189,
        T_FINAL: 190,
        T_EXTENDS: 191,
        T_INTERFACE: 192,
        T_IMPLEMENTS: 193,
        T_VAR: 194,
        T_PUBLIC: 195,
        T_PROTECTED: 196,
        T_PRIVATE: 197,
        T_CONST: 198,
        T_NEW: 199,
        T_INSTEADOF: 200,
        T_ELSEIF: 201,
        T_ELSE: 202,
        T_ENDSWITCH: 203,
        T_CASE: 204,
        T_DEFAULT: 205,
        T_ENDFOR: 206,
        T_ENDFOREACH: 207,
        T_ENDWHILE: 208,
        T_CONSTANT_ENCAPSED_STRING: 209,
        T_LNUMBER: 210,
        T_DNUMBER: 211,
        T_LINE: 212,
        T_FILE: 213,
        T_DIR: 214,
        T_TRAIT_C: 215,
        T_METHOD_C: 216,
        T_FUNC_C: 217,
        T_NS_C: 218,
        T_START_HEREDOC: 219,
        T_END_HEREDOC: 220,
        T_CLASS_C: 221,
        T_VARIABLE: 222,
        T_OPEN_TAG: 223,
        T_OPEN_TAG_WITH_ECHO: 224,
        T_CLOSE_TAG: 225,
        T_WHITESPACE: 226,
        T_COMMENT: 227,
        T_DOC_COMMENT: 228,
        T_ELLIPSIS: 229,
        T_COALESCE: 230,
        T_POW: 231,
        T_POW_EQUAL: 232,
        T_SPACESHIP: 233,
        T_COALESCE_EQUAL: 234,
        T_FN: 235,
        T_NULLSAFE_OBJECT_OPERATOR: 236,
        T_MATCH: 237,
        T_ATTRIBUTE: 238,
        T_ENUM: 239,
        T_READ_ONLY: 240,
        T_NAME_RELATIVE: 241,
        T_NAME_QUALIFIED: 242,
        T_NAME_FULLY_QUALIFIED: 243
      }
    };
    module2.exports = Object.freeze(tokens);
  }
});

// node_modules/php-parser/src/ast/location.js
var require_location = __commonJS({
  "node_modules/php-parser/src/ast/location.js"(exports, module2) {
    "use strict";
    var Location = function(source, start, end) {
      this.source = source;
      this.start = start;
      this.end = end;
    };
    module2.exports = Location;
  }
});

// node_modules/php-parser/src/ast/node.js
var require_node = __commonJS({
  "node_modules/php-parser/src/ast/node.js"(exports, module2) {
    "use strict";
    var Node8 = function Node9(kind, docs, location) {
      this.kind = kind;
      if (docs) {
        this.leadingComments = docs;
      }
      if (location) {
        this.loc = location;
      }
    };
    Node8.prototype.setTrailingComments = function(docs) {
      this.trailingComments = docs;
    };
    Node8.prototype.destroy = function(node) {
      if (!node) {
        throw new Error("Node already initialized, you must swap with another node");
      }
      if (this.leadingComments) {
        if (node.leadingComments) {
          node.leadingComments = Array.concat(this.leadingComments, node.leadingComments);
        } else {
          node.leadingComments = this.leadingComments;
        }
      }
      if (this.trailingComments) {
        if (node.trailingComments) {
          node.trailingComments = Array.concat(this.trailingComments, node.trailingComments);
        } else {
          node.trailingComments = this.trailingComments;
        }
      }
      return node;
    };
    Node8.prototype.includeToken = function(parser) {
      if (this.loc) {
        if (this.loc.end) {
          this.loc.end.line = parser.lexer.yylloc.last_line;
          this.loc.end.column = parser.lexer.yylloc.last_column;
          this.loc.end.offset = parser.lexer.offset;
        }
        if (parser.ast.withSource) {
          this.loc.source = parser.lexer._input.substring(this.loc.start.offset, parser.lexer.offset);
        }
      }
      return this;
    };
    Node8.extends = function(type, constructor) {
      constructor.prototype = Object.create(this.prototype);
      constructor.extends = this.extends;
      constructor.prototype.constructor = constructor;
      constructor.kind = type;
      return constructor;
    };
    module2.exports = Node8;
  }
});

// node_modules/php-parser/src/ast/expression.js
var require_expression = __commonJS({
  "node_modules/php-parser/src/ast/expression.js"(exports, module2) {
    "use strict";
    var Node8 = require_node();
    var KIND = "expression";
    module2.exports = Node8.extends(KIND, function Expression2(kind, docs, location) {
      Node8.apply(this, [kind || KIND, docs, location]);
    });
  }
});

// node_modules/php-parser/src/ast/array.js
var require_array2 = __commonJS({
  "node_modules/php-parser/src/ast/array.js"(exports, module2) {
    "use strict";
    var Expr = require_expression();
    var KIND = "array";
    module2.exports = Expr.extends(KIND, function Array2(shortForm, items, docs, location) {
      Expr.apply(this, [KIND, docs, location]);
      this.items = items;
      this.shortForm = shortForm;
    });
  }
});

// node_modules/php-parser/src/ast/arrowfunc.js
var require_arrowfunc = __commonJS({
  "node_modules/php-parser/src/ast/arrowfunc.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "arrowfunc";
    module2.exports = Expression2.extends(KIND, function Closure(args, byref, body, type, nullable, isStatic, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.arguments = args;
      this.byref = byref;
      this.body = body;
      this.type = type;
      this.nullable = nullable;
      this.isStatic = isStatic || false;
    });
  }
});

// node_modules/php-parser/src/ast/assign.js
var require_assign = __commonJS({
  "node_modules/php-parser/src/ast/assign.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "assign";
    module2.exports = Expression2.extends(KIND, function Assign(left, right, operator, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.left = left;
      this.right = right;
      this.operator = operator;
    });
  }
});

// node_modules/php-parser/src/ast/assignref.js
var require_assignref = __commonJS({
  "node_modules/php-parser/src/ast/assignref.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "assignref";
    module2.exports = Expression2.extends(KIND, function AssignRef(left, right, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.left = left;
      this.right = right;
    });
  }
});

// node_modules/php-parser/src/ast/attribute.js
var require_attribute2 = __commonJS({
  "node_modules/php-parser/src/ast/attribute.js"(exports, module2) {
    "use strict";
    var Node8 = require_node();
    var KIND = "attribute";
    module2.exports = Node8.extends(KIND, function Attribute(name, args, docs, location) {
      Node8.apply(this, [KIND, docs, location]);
      this.name = name;
      this.args = args;
    });
  }
});

// node_modules/php-parser/src/ast/attrgroup.js
var require_attrgroup = __commonJS({
  "node_modules/php-parser/src/ast/attrgroup.js"(exports, module2) {
    "use strict";
    var Node8 = require_node();
    var KIND = "attrgroup";
    module2.exports = Node8.extends(KIND, function AttrGroup(attrs, docs, location) {
      Node8.apply(this, [KIND, docs, location]);
      this.attrs = attrs || [];
    });
  }
});

// node_modules/php-parser/src/ast/operation.js
var require_operation = __commonJS({
  "node_modules/php-parser/src/ast/operation.js"(exports, module2) {
    "use strict";
    var Expr = require_expression();
    var KIND = "operation";
    module2.exports = Expr.extends(KIND, function Operation(kind, docs, location) {
      Expr.apply(this, [kind || KIND, docs, location]);
    });
  }
});

// node_modules/php-parser/src/ast/bin.js
var require_bin = __commonJS({
  "node_modules/php-parser/src/ast/bin.js"(exports, module2) {
    "use strict";
    var Operation = require_operation();
    var KIND = "bin";
    module2.exports = Operation.extends(KIND, function Bin(type, left, right, docs, location) {
      Operation.apply(this, [KIND, docs, location]);
      this.type = type;
      this.left = left;
      this.right = right;
    });
  }
});

// node_modules/php-parser/src/ast/statement.js
var require_statement2 = __commonJS({
  "node_modules/php-parser/src/ast/statement.js"(exports, module2) {
    "use strict";
    var Node8 = require_node();
    var KIND = "statement";
    module2.exports = Node8.extends(KIND, function Statement(kind, docs, location) {
      Node8.apply(this, [kind || KIND, docs, location]);
    });
  }
});

// node_modules/php-parser/src/ast/block.js
var require_block = __commonJS({
  "node_modules/php-parser/src/ast/block.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "block";
    module2.exports = Statement.extends(KIND, function Block(kind, children, docs, location) {
      Statement.apply(this, [kind || KIND, docs, location]);
      this.children = children.filter(Boolean);
    });
  }
});

// node_modules/php-parser/src/ast/literal.js
var require_literal = __commonJS({
  "node_modules/php-parser/src/ast/literal.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "literal";
    module2.exports = Expression2.extends(KIND, function Literal(kind, value, raw, docs, location) {
      Expression2.apply(this, [kind || KIND, docs, location]);
      this.value = value;
      if (raw) {
        this.raw = raw;
      }
    });
  }
});

// node_modules/php-parser/src/ast/boolean.js
var require_boolean = __commonJS({
  "node_modules/php-parser/src/ast/boolean.js"(exports, module2) {
    "use strict";
    var Literal = require_literal();
    var KIND = "boolean";
    module2.exports = Literal.extends(KIND, function Boolean2(value, raw, docs, location) {
      Literal.apply(this, [KIND, value, raw, docs, location]);
    });
  }
});

// node_modules/php-parser/src/ast/break.js
var require_break = __commonJS({
  "node_modules/php-parser/src/ast/break.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "break";
    module2.exports = Statement.extends(KIND, function Break(level, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.level = level;
    });
  }
});

// node_modules/php-parser/src/ast/byref.js
var require_byref = __commonJS({
  "node_modules/php-parser/src/ast/byref.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "byref";
    module2.exports = Expression2.extends(KIND, function ByRef(what, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.what = what;
    });
  }
});

// node_modules/php-parser/src/ast/call.js
var require_call = __commonJS({
  "node_modules/php-parser/src/ast/call.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "call";
    module2.exports = Expression2.extends(KIND, function Call3(what, args, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.what = what;
      this.arguments = args;
    });
  }
});

// node_modules/php-parser/src/ast/case.js
var require_case = __commonJS({
  "node_modules/php-parser/src/ast/case.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "case";
    module2.exports = Statement.extends(KIND, function Case(test, body, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.test = test;
      this.body = body;
    });
  }
});

// node_modules/php-parser/src/ast/cast.js
var require_cast = __commonJS({
  "node_modules/php-parser/src/ast/cast.js"(exports, module2) {
    "use strict";
    var Operation = require_operation();
    var KIND = "cast";
    module2.exports = Operation.extends(KIND, function Cast(type, raw, expr, docs, location) {
      Operation.apply(this, [KIND, docs, location]);
      this.type = type;
      this.raw = raw;
      this.expr = expr;
    });
  }
});

// node_modules/php-parser/src/ast/catch.js
var require_catch = __commonJS({
  "node_modules/php-parser/src/ast/catch.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "catch";
    module2.exports = Statement.extends(KIND, function Catch(body, what, variable, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.body = body;
      this.what = what;
      this.variable = variable;
    });
  }
});

// node_modules/php-parser/src/ast/declaration.js
var require_declaration = __commonJS({
  "node_modules/php-parser/src/ast/declaration.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "declaration";
    var IS_UNDEFINED = "";
    var IS_PUBLIC = "public";
    var IS_PROTECTED = "protected";
    var IS_PRIVATE = "private";
    var Declaration = Statement.extends(KIND, function Declaration2(kind, name, docs, location) {
      Statement.apply(this, [kind || KIND, docs, location]);
      this.name = name;
    });
    Declaration.prototype.parseFlags = function(flags) {
      this.isAbstract = flags[2] === 1;
      this.isFinal = flags[2] === 2;
      if (this.kind !== "class") {
        if (flags[0] === -1) {
          this.visibility = IS_UNDEFINED;
        } else if (flags[0] === null) {
          this.visibility = null;
        } else if (flags[0] === 0) {
          this.visibility = IS_PUBLIC;
        } else if (flags[0] === 1) {
          this.visibility = IS_PROTECTED;
        } else if (flags[0] === 2) {
          this.visibility = IS_PRIVATE;
        }
        this.isStatic = flags[1] === 1;
      }
    };
    module2.exports = Declaration;
  }
});

// node_modules/php-parser/src/ast/class.js
var require_class2 = __commonJS({
  "node_modules/php-parser/src/ast/class.js"(exports, module2) {
    "use strict";
    var Declaration = require_declaration();
    var KIND = "class";
    module2.exports = Declaration.extends(KIND, function Class5(name, ext, impl, body, flags, docs, location) {
      Declaration.apply(this, [KIND, name, docs, location]);
      this.isAnonymous = name ? false : true;
      this.extends = ext;
      this.implements = impl;
      this.body = body;
      this.attrGroups = [];
      this.parseFlags(flags);
    });
  }
});

// node_modules/php-parser/src/ast/constantstatement.js
var require_constantstatement = __commonJS({
  "node_modules/php-parser/src/ast/constantstatement.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "constantstatement";
    module2.exports = Statement.extends(KIND, function ConstantStatement(kind, constants, docs, location) {
      Statement.apply(this, [kind || KIND, docs, location]);
      this.constants = constants;
    });
  }
});

// node_modules/php-parser/src/ast/classconstant.js
var require_classconstant = __commonJS({
  "node_modules/php-parser/src/ast/classconstant.js"(exports, module2) {
    "use strict";
    var ConstantStatement = require_constantstatement();
    var KIND = "classconstant";
    var IS_UNDEFINED = "";
    var IS_PUBLIC = "public";
    var IS_PROTECTED = "protected";
    var IS_PRIVATE = "private";
    var ClassConstant = ConstantStatement.extends(KIND, function ClassConstant2(kind, constants, flags, attrGroups, docs, location) {
      ConstantStatement.apply(this, [kind || KIND, constants, docs, location]);
      this.parseFlags(flags);
      this.attrGroups = attrGroups;
    });
    ClassConstant.prototype.parseFlags = function(flags) {
      if (flags[0] === -1) {
        this.visibility = IS_UNDEFINED;
      } else if (flags[0] === null) {
        this.visibility = null;
      } else if (flags[0] === 0) {
        this.visibility = IS_PUBLIC;
      } else if (flags[0] === 1) {
        this.visibility = IS_PROTECTED;
      } else if (flags[0] === 2) {
        this.visibility = IS_PRIVATE;
      }
    };
    module2.exports = ClassConstant;
  }
});

// node_modules/php-parser/src/ast/clone.js
var require_clone = __commonJS({
  "node_modules/php-parser/src/ast/clone.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "clone";
    module2.exports = Expression2.extends(KIND, function Clone(what, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.what = what;
    });
  }
});

// node_modules/php-parser/src/ast/closure.js
var require_closure = __commonJS({
  "node_modules/php-parser/src/ast/closure.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "closure";
    module2.exports = Expression2.extends(KIND, function Closure(args, byref, uses, type, nullable, isStatic, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.uses = uses;
      this.arguments = args;
      this.byref = byref;
      this.type = type;
      this.nullable = nullable;
      this.isStatic = isStatic || false;
      this.body = null;
      this.attrGroups = [];
    });
  }
});

// node_modules/php-parser/src/ast/comment.js
var require_comment2 = __commonJS({
  "node_modules/php-parser/src/ast/comment.js"(exports, module2) {
    "use strict";
    var Node8 = require_node();
    module2.exports = Node8.extends("comment", function Comment5(kind, value, docs, location) {
      Node8.apply(this, [kind, docs, location]);
      this.value = value;
    });
  }
});

// node_modules/php-parser/src/ast/commentblock.js
var require_commentblock = __commonJS({
  "node_modules/php-parser/src/ast/commentblock.js"(exports, module2) {
    "use strict";
    var Comment5 = require_comment2();
    var KIND = "commentblock";
    module2.exports = Comment5.extends(KIND, function CommentBlock3(value, docs, location) {
      Comment5.apply(this, [KIND, value, docs, location]);
    });
  }
});

// node_modules/php-parser/src/ast/commentline.js
var require_commentline = __commonJS({
  "node_modules/php-parser/src/ast/commentline.js"(exports, module2) {
    "use strict";
    var Comment5 = require_comment2();
    var KIND = "commentline";
    module2.exports = Comment5.extends(KIND, function CommentLine(value, docs, location) {
      Comment5.apply(this, [KIND, value, docs, location]);
    });
  }
});

// node_modules/php-parser/src/ast/constant.js
var require_constant = __commonJS({
  "node_modules/php-parser/src/ast/constant.js"(exports, module2) {
    "use strict";
    var Node8 = require_node();
    var KIND = "constant";
    module2.exports = Node8.extends(KIND, function Constant(name, value, docs, location) {
      Node8.apply(this, [KIND, docs, location]);
      this.name = name;
      this.value = value;
    });
  }
});

// node_modules/php-parser/src/ast/continue.js
var require_continue = __commonJS({
  "node_modules/php-parser/src/ast/continue.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "continue";
    module2.exports = Statement.extends(KIND, function Continue(level, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.level = level;
    });
  }
});

// node_modules/php-parser/src/ast/declare.js
var require_declare = __commonJS({
  "node_modules/php-parser/src/ast/declare.js"(exports, module2) {
    "use strict";
    var Block = require_block();
    var KIND = "declare";
    var Declare = Block.extends(KIND, function Declare2(directives, body, mode, docs, location) {
      Block.apply(this, [KIND, body, docs, location]);
      this.directives = directives;
      this.mode = mode;
    });
    Declare.MODE_SHORT = "short";
    Declare.MODE_BLOCK = "block";
    Declare.MODE_NONE = "none";
    module2.exports = Declare;
  }
});

// node_modules/php-parser/src/ast/declaredirective.js
var require_declaredirective = __commonJS({
  "node_modules/php-parser/src/ast/declaredirective.js"(exports, module2) {
    "use strict";
    var Node8 = require_node();
    var KIND = "declaredirective";
    module2.exports = Node8.extends(KIND, function DeclareDirective(key, value, docs, location) {
      Node8.apply(this, [KIND, docs, location]);
      this.key = key;
      this.value = value;
    });
  }
});

// node_modules/php-parser/src/ast/do.js
var require_do = __commonJS({
  "node_modules/php-parser/src/ast/do.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "do";
    module2.exports = Statement.extends(KIND, function Do(test, body, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.test = test;
      this.body = body;
    });
  }
});

// node_modules/php-parser/src/ast/echo.js
var require_echo = __commonJS({
  "node_modules/php-parser/src/ast/echo.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "echo";
    module2.exports = Statement.extends(KIND, function Echo(expressions, shortForm, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.shortForm = shortForm;
      this.expressions = expressions;
    });
  }
});

// node_modules/php-parser/src/ast/empty.js
var require_empty = __commonJS({
  "node_modules/php-parser/src/ast/empty.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "empty";
    module2.exports = Expression2.extends(KIND, function Empty(expression, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.expression = expression;
    });
  }
});

// node_modules/php-parser/src/ast/encapsed.js
var require_encapsed = __commonJS({
  "node_modules/php-parser/src/ast/encapsed.js"(exports, module2) {
    "use strict";
    var Literal = require_literal();
    var KIND = "encapsed";
    var Encapsed = Literal.extends(KIND, function Encapsed2(value, raw, type, docs, location) {
      Literal.apply(this, [KIND, value, raw, docs, location]);
      this.type = type;
    });
    Encapsed.TYPE_STRING = "string";
    Encapsed.TYPE_SHELL = "shell";
    Encapsed.TYPE_HEREDOC = "heredoc";
    Encapsed.TYPE_OFFSET = "offset";
    module2.exports = Encapsed;
  }
});

// node_modules/php-parser/src/ast/encapsedpart.js
var require_encapsedpart = __commonJS({
  "node_modules/php-parser/src/ast/encapsedpart.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "encapsedpart";
    module2.exports = Expression2.extends(KIND, function EncapsedPart(expression, syntax, curly, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.expression = expression;
      this.syntax = syntax;
      this.curly = curly;
    });
  }
});

// node_modules/php-parser/src/ast/entry.js
var require_entry = __commonJS({
  "node_modules/php-parser/src/ast/entry.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "entry";
    module2.exports = Expression2.extends(KIND, function Entry(key, value, byRef, unpack, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.key = key;
      this.value = value;
      this.byRef = byRef;
      this.unpack = unpack;
    });
  }
});

// node_modules/php-parser/src/ast/enum.js
var require_enum2 = __commonJS({
  "node_modules/php-parser/src/ast/enum.js"(exports, module2) {
    "use strict";
    var Declaration = require_declaration();
    var KIND = "enum";
    module2.exports = Declaration.extends(KIND, function Enum(name, valueType, impl, body, docs, location) {
      Declaration.apply(this, [KIND, name, docs, location]);
      this.valueType = valueType;
      this.implements = impl;
      this.body = body;
      this.attrGroups = [];
    });
  }
});

// node_modules/php-parser/src/ast/enumcase.js
var require_enumcase = __commonJS({
  "node_modules/php-parser/src/ast/enumcase.js"(exports, module2) {
    "use strict";
    var Node8 = require_node();
    var KIND = "enumcase";
    module2.exports = Node8.extends(KIND, function EnumCase(name, value, docs, location) {
      Node8.apply(this, [KIND, docs, location]);
      this.name = name;
      this.value = value;
    });
  }
});

// node_modules/php-parser/src/ast/error.js
var require_error = __commonJS({
  "node_modules/php-parser/src/ast/error.js"(exports, module2) {
    "use strict";
    var Node8 = require_node();
    var KIND = "error";
    module2.exports = Node8.extends(KIND, function Error2(message, token, line, expected, docs, location) {
      Node8.apply(this, [KIND, docs, location]);
      this.message = message;
      this.token = token;
      this.line = line;
      this.expected = expected;
    });
  }
});

// node_modules/php-parser/src/ast/eval.js
var require_eval = __commonJS({
  "node_modules/php-parser/src/ast/eval.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "eval";
    module2.exports = Expression2.extends(KIND, function Eval(source, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.source = source;
    });
  }
});

// node_modules/php-parser/src/ast/exit.js
var require_exit = __commonJS({
  "node_modules/php-parser/src/ast/exit.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "exit";
    module2.exports = Expression2.extends(KIND, function Exit(expression, useDie, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.expression = expression;
      this.useDie = useDie;
    });
  }
});

// node_modules/php-parser/src/ast/expressionstatement.js
var require_expressionstatement = __commonJS({
  "node_modules/php-parser/src/ast/expressionstatement.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "expressionstatement";
    module2.exports = Statement.extends(KIND, function ExpressionStatement(expr, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.expression = expr;
    });
  }
});

// node_modules/php-parser/src/ast/for.js
var require_for = __commonJS({
  "node_modules/php-parser/src/ast/for.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "for";
    module2.exports = Statement.extends(KIND, function For(init, test, increment, body, shortForm, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.init = init;
      this.test = test;
      this.increment = increment;
      this.shortForm = shortForm;
      this.body = body;
    });
  }
});

// node_modules/php-parser/src/ast/foreach.js
var require_foreach = __commonJS({
  "node_modules/php-parser/src/ast/foreach.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "foreach";
    module2.exports = Statement.extends(KIND, function Foreach(source, key, value, body, shortForm, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.source = source;
      this.key = key;
      this.value = value;
      this.shortForm = shortForm;
      this.body = body;
    });
  }
});

// node_modules/php-parser/src/ast/function.js
var require_function2 = __commonJS({
  "node_modules/php-parser/src/ast/function.js"(exports, module2) {
    "use strict";
    var Declaration = require_declaration();
    var KIND = "function";
    module2.exports = Declaration.extends(KIND, function _Function(name, args, byref, type, nullable, docs, location) {
      Declaration.apply(this, [KIND, name, docs, location]);
      this.arguments = args;
      this.byref = byref;
      this.type = type;
      this.nullable = nullable;
      this.body = null;
      this.attrGroups = [];
    });
  }
});

// node_modules/php-parser/src/ast/global.js
var require_global = __commonJS({
  "node_modules/php-parser/src/ast/global.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "global";
    module2.exports = Statement.extends(KIND, function Global(items, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.items = items;
    });
  }
});

// node_modules/php-parser/src/ast/goto.js
var require_goto = __commonJS({
  "node_modules/php-parser/src/ast/goto.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "goto";
    module2.exports = Statement.extends(KIND, function Goto(label, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.label = label;
    });
  }
});

// node_modules/php-parser/src/ast/halt.js
var require_halt = __commonJS({
  "node_modules/php-parser/src/ast/halt.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "halt";
    module2.exports = Statement.extends(KIND, function Halt(after, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.after = after;
    });
  }
});

// node_modules/php-parser/src/ast/identifier.js
var require_identifier = __commonJS({
  "node_modules/php-parser/src/ast/identifier.js"(exports, module2) {
    "use strict";
    var Node8 = require_node();
    var KIND = "identifier";
    var Identifier4 = Node8.extends(KIND, function Identifier5(name, docs, location) {
      Node8.apply(this, [KIND, docs, location]);
      this.name = name;
    });
    module2.exports = Identifier4;
  }
});

// node_modules/php-parser/src/ast/if.js
var require_if2 = __commonJS({
  "node_modules/php-parser/src/ast/if.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "if";
    module2.exports = Statement.extends(KIND, function If(test, body, alternate, shortForm, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.test = test;
      this.body = body;
      this.alternate = alternate;
      this.shortForm = shortForm;
    });
  }
});

// node_modules/php-parser/src/ast/include.js
var require_include = __commonJS({
  "node_modules/php-parser/src/ast/include.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "include";
    module2.exports = Expression2.extends(KIND, function Include(once, require2, target, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.once = once;
      this.require = require2;
      this.target = target;
    });
  }
});

// node_modules/php-parser/src/ast/inline.js
var require_inline = __commonJS({
  "node_modules/php-parser/src/ast/inline.js"(exports, module2) {
    "use strict";
    var Literal = require_literal();
    var KIND = "inline";
    module2.exports = Literal.extends(KIND, function Inline(value, raw, docs, location) {
      Literal.apply(this, [KIND, value, raw, docs, location]);
    });
  }
});

// node_modules/php-parser/src/ast/interface.js
var require_interface = __commonJS({
  "node_modules/php-parser/src/ast/interface.js"(exports, module2) {
    "use strict";
    var Declaration = require_declaration();
    var KIND = "interface";
    module2.exports = Declaration.extends(KIND, function Interface(name, ext, body, attrGroups, docs, location) {
      Declaration.apply(this, [KIND, name, docs, location]);
      this.extends = ext;
      this.body = body;
      this.attrGroups = attrGroups;
    });
  }
});

// node_modules/php-parser/src/ast/intersectiontype.js
var require_intersectiontype = __commonJS({
  "node_modules/php-parser/src/ast/intersectiontype.js"(exports, module2) {
    "use strict";
    var Declaration = require_declaration();
    var KIND = "intersectiontype";
    module2.exports = Declaration.extends(KIND, function IntersectionType(types, docs, location) {
      Declaration.apply(this, [KIND, null, docs, location]);
      this.types = types;
    });
  }
});

// node_modules/php-parser/src/ast/isset.js
var require_isset = __commonJS({
  "node_modules/php-parser/src/ast/isset.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "isset";
    module2.exports = Expression2.extends(KIND, function Isset(variables, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.variables = variables;
    });
  }
});

// node_modules/php-parser/src/ast/label.js
var require_label = __commonJS({
  "node_modules/php-parser/src/ast/label.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "label";
    module2.exports = Statement.extends(KIND, function Label(name, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.name = name;
    });
  }
});

// node_modules/php-parser/src/ast/list.js
var require_list = __commonJS({
  "node_modules/php-parser/src/ast/list.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "list";
    module2.exports = Expression2.extends(KIND, function List(items, shortForm, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.items = items;
      this.shortForm = shortForm;
    });
  }
});

// node_modules/php-parser/src/ast/lookup.js
var require_lookup = __commonJS({
  "node_modules/php-parser/src/ast/lookup.js"(exports, module2) {
    "use strict";
    var Expr = require_expression();
    var KIND = "lookup";
    module2.exports = Expr.extends(KIND, function Lookup(kind, what, offset, docs, location) {
      Expr.apply(this, [kind || KIND, docs, location]);
      this.what = what;
      this.offset = offset;
    });
  }
});

// node_modules/php-parser/src/ast/magic.js
var require_magic = __commonJS({
  "node_modules/php-parser/src/ast/magic.js"(exports, module2) {
    "use strict";
    var Literal = require_literal();
    var KIND = "magic";
    module2.exports = Literal.extends(KIND, function Magic(value, raw, docs, location) {
      Literal.apply(this, [KIND, value, raw, docs, location]);
    });
  }
});

// node_modules/php-parser/src/ast/match.js
var require_match = __commonJS({
  "node_modules/php-parser/src/ast/match.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "match";
    module2.exports = Expression2.extends(KIND, function Match(cond, arms, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.cond = cond;
      this.arms = arms;
    });
  }
});

// node_modules/php-parser/src/ast/matcharm.js
var require_matcharm = __commonJS({
  "node_modules/php-parser/src/ast/matcharm.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "matcharm";
    module2.exports = Expression2.extends(KIND, function MatchArm(conds, body, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.conds = conds;
      this.body = body;
    });
  }
});

// node_modules/php-parser/src/ast/method.js
var require_method = __commonJS({
  "node_modules/php-parser/src/ast/method.js"(exports, module2) {
    "use strict";
    var Function_ = require_function2();
    var KIND = "method";
    module2.exports = Function_.extends(KIND, function Method3() {
      Function_.apply(this, arguments);
      this.kind = KIND;
    });
  }
});

// node_modules/php-parser/src/ast/reference.js
var require_reference = __commonJS({
  "node_modules/php-parser/src/ast/reference.js"(exports, module2) {
    "use strict";
    var Node8 = require_node();
    var KIND = "reference";
    var Reference = Node8.extends(KIND, function Reference2(kind, docs, location) {
      Node8.apply(this, [kind || KIND, docs, location]);
    });
    module2.exports = Reference;
  }
});

// node_modules/php-parser/src/ast/name.js
var require_name = __commonJS({
  "node_modules/php-parser/src/ast/name.js"(exports, module2) {
    "use strict";
    var Reference = require_reference();
    var KIND = "name";
    var Name3 = Reference.extends(KIND, function Name4(name, resolution, docs, location) {
      Reference.apply(this, [KIND, docs, location]);
      this.name = name.replace(/\\$/, "");
      this.resolution = resolution;
    });
    Name3.UNQUALIFIED_NAME = "uqn";
    Name3.QUALIFIED_NAME = "qn";
    Name3.FULL_QUALIFIED_NAME = "fqn";
    Name3.RELATIVE_NAME = "rn";
    module2.exports = Name3;
  }
});

// node_modules/php-parser/src/ast/namespace.js
var require_namespace2 = __commonJS({
  "node_modules/php-parser/src/ast/namespace.js"(exports, module2) {
    "use strict";
    var Block = require_block();
    var KIND = "namespace";
    module2.exports = Block.extends(KIND, function Namespace6(name, children, withBrackets, docs, location) {
      Block.apply(this, [KIND, children, docs, location]);
      this.name = name;
      this.withBrackets = withBrackets || false;
    });
  }
});

// node_modules/php-parser/src/ast/namedargument.js
var require_namedargument = __commonJS({
  "node_modules/php-parser/src/ast/namedargument.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "namedargument";
    module2.exports = Expression2.extends(KIND, function namedargument(name, value, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.name = name;
      this.value = value;
    });
  }
});

// node_modules/php-parser/src/ast/new.js
var require_new = __commonJS({
  "node_modules/php-parser/src/ast/new.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "new";
    module2.exports = Expression2.extends(KIND, function New2(what, args, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.what = what;
      this.arguments = args;
    });
  }
});

// node_modules/php-parser/src/ast/noop.js
var require_noop = __commonJS({
  "node_modules/php-parser/src/ast/noop.js"(exports, module2) {
    "use strict";
    var Node8 = require_node();
    var KIND = "noop";
    module2.exports = Node8.extends(KIND, function Noop(docs, location) {
      Node8.apply(this, [KIND, docs, location]);
    });
  }
});

// node_modules/php-parser/src/ast/nowdoc.js
var require_nowdoc = __commonJS({
  "node_modules/php-parser/src/ast/nowdoc.js"(exports, module2) {
    "use strict";
    var Literal = require_literal();
    var KIND = "nowdoc";
    module2.exports = Literal.extends(KIND, function Nowdoc(value, raw, label, docs, location) {
      Literal.apply(this, [KIND, value, raw, docs, location]);
      this.label = label;
    });
  }
});

// node_modules/php-parser/src/ast/nullkeyword.js
var require_nullkeyword = __commonJS({
  "node_modules/php-parser/src/ast/nullkeyword.js"(exports, module2) {
    "use strict";
    var Node8 = require_node();
    var KIND = "nullkeyword";
    module2.exports = Node8.extends(KIND, function NullKeyword(raw, docs, location) {
      Node8.apply(this, [KIND, docs, location]);
      this.raw = raw;
    });
  }
});

// node_modules/php-parser/src/ast/nullsafepropertylookup.js
var require_nullsafepropertylookup = __commonJS({
  "node_modules/php-parser/src/ast/nullsafepropertylookup.js"(exports, module2) {
    "use strict";
    var Lookup = require_lookup();
    var KIND = "nullsafepropertylookup";
    module2.exports = Lookup.extends(KIND, function PropertyLookup(what, offset, docs, location) {
      Lookup.apply(this, [KIND, what, offset, docs, location]);
    });
  }
});

// node_modules/php-parser/src/ast/number.js
var require_number = __commonJS({
  "node_modules/php-parser/src/ast/number.js"(exports, module2) {
    "use strict";
    var Literal = require_literal();
    var KIND = "number";
    module2.exports = Literal.extends(KIND, function Number2(value, raw, docs, location) {
      Literal.apply(this, [KIND, value, raw, docs, location]);
    });
  }
});

// node_modules/php-parser/src/ast/offsetlookup.js
var require_offsetlookup = __commonJS({
  "node_modules/php-parser/src/ast/offsetlookup.js"(exports, module2) {
    "use strict";
    var Lookup = require_lookup();
    var KIND = "offsetlookup";
    module2.exports = Lookup.extends(KIND, function OffsetLookup(what, offset, docs, location) {
      Lookup.apply(this, [KIND, what, offset, docs, location]);
    });
  }
});

// node_modules/php-parser/src/ast/parameter.js
var require_parameter = __commonJS({
  "node_modules/php-parser/src/ast/parameter.js"(exports, module2) {
    "use strict";
    var Declaration = require_declaration();
    var KIND = "parameter";
    module2.exports = Declaration.extends(KIND, function Parameter(name, type, value, isRef, isVariadic, readonly, nullable, flags, docs, location) {
      Declaration.apply(this, [KIND, name, docs, location]);
      this.value = value;
      this.type = type;
      this.byref = isRef;
      this.variadic = isVariadic;
      this.readonly = readonly;
      this.nullable = nullable;
      this.flags = flags || 0;
      this.attrGroups = [];
    });
  }
});

// node_modules/php-parser/src/ast/parentreference.js
var require_parentreference = __commonJS({
  "node_modules/php-parser/src/ast/parentreference.js"(exports, module2) {
    "use strict";
    var Reference = require_reference();
    var KIND = "parentreference";
    var ParentReference = Reference.extends(KIND, function ParentReference2(raw, docs, location) {
      Reference.apply(this, [KIND, docs, location]);
      this.raw = raw;
    });
    module2.exports = ParentReference;
  }
});

// node_modules/php-parser/src/ast/post.js
var require_post = __commonJS({
  "node_modules/php-parser/src/ast/post.js"(exports, module2) {
    "use strict";
    var Operation = require_operation();
    var KIND = "post";
    module2.exports = Operation.extends(KIND, function Post(type, what, docs, location) {
      Operation.apply(this, [KIND, docs, location]);
      this.type = type;
      this.what = what;
    });
  }
});

// node_modules/php-parser/src/ast/pre.js
var require_pre = __commonJS({
  "node_modules/php-parser/src/ast/pre.js"(exports, module2) {
    "use strict";
    var Operation = require_operation();
    var KIND = "pre";
    module2.exports = Operation.extends(KIND, function Pre(type, what, docs, location) {
      Operation.apply(this, [KIND, docs, location]);
      this.type = type;
      this.what = what;
    });
  }
});

// node_modules/php-parser/src/ast/print.js
var require_print = __commonJS({
  "node_modules/php-parser/src/ast/print.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "print";
    module2.exports = Expression2.extends(KIND, function Print(expression, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.expression = expression;
    });
  }
});

// node_modules/php-parser/src/ast/program.js
var require_program = __commonJS({
  "node_modules/php-parser/src/ast/program.js"(exports, module2) {
    "use strict";
    var Block = require_block();
    var KIND = "program";
    module2.exports = Block.extends(KIND, function Program(children, errors, comments, tokens, docs, location) {
      Block.apply(this, [KIND, children, docs, location]);
      this.errors = errors;
      if (comments) {
        this.comments = comments;
      }
      if (tokens) {
        this.tokens = tokens;
      }
    });
  }
});

// node_modules/php-parser/src/ast/property.js
var require_property2 = __commonJS({
  "node_modules/php-parser/src/ast/property.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "property";
    module2.exports = Statement.extends(KIND, function Property3(name, value, readonly, nullable, type, attrGroups, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.name = name;
      this.value = value;
      this.readonly = readonly;
      this.nullable = nullable;
      this.type = type;
      this.attrGroups = attrGroups;
    });
  }
});

// node_modules/php-parser/src/ast/propertylookup.js
var require_propertylookup = __commonJS({
  "node_modules/php-parser/src/ast/propertylookup.js"(exports, module2) {
    "use strict";
    var Lookup = require_lookup();
    var KIND = "propertylookup";
    module2.exports = Lookup.extends(KIND, function PropertyLookup(what, offset, docs, location) {
      Lookup.apply(this, [KIND, what, offset, docs, location]);
    });
  }
});

// node_modules/php-parser/src/ast/propertystatement.js
var require_propertystatement = __commonJS({
  "node_modules/php-parser/src/ast/propertystatement.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "propertystatement";
    var IS_UNDEFINED = "";
    var IS_PUBLIC = "public";
    var IS_PROTECTED = "protected";
    var IS_PRIVATE = "private";
    var PropertyStatement3 = Statement.extends(KIND, function PropertyStatement4(kind, properties, flags, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.properties = properties;
      this.parseFlags(flags);
    });
    PropertyStatement3.prototype.parseFlags = function(flags) {
      if (flags[0] === -1) {
        this.visibility = IS_UNDEFINED;
      } else if (flags[0] === null) {
        this.visibility = null;
      } else if (flags[0] === 0) {
        this.visibility = IS_PUBLIC;
      } else if (flags[0] === 1) {
        this.visibility = IS_PROTECTED;
      } else if (flags[0] === 2) {
        this.visibility = IS_PRIVATE;
      }
      this.isStatic = flags[1] === 1;
    };
    module2.exports = PropertyStatement3;
  }
});

// node_modules/php-parser/src/ast/retif.js
var require_retif = __commonJS({
  "node_modules/php-parser/src/ast/retif.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "retif";
    module2.exports = Expression2.extends(KIND, function RetIf(test, trueExpr, falseExpr, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.test = test;
      this.trueExpr = trueExpr;
      this.falseExpr = falseExpr;
    });
  }
});

// node_modules/php-parser/src/ast/return.js
var require_return = __commonJS({
  "node_modules/php-parser/src/ast/return.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "return";
    module2.exports = Statement.extends(KIND, function Return(expr, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.expr = expr;
    });
  }
});

// node_modules/php-parser/src/ast/selfreference.js
var require_selfreference = __commonJS({
  "node_modules/php-parser/src/ast/selfreference.js"(exports, module2) {
    "use strict";
    var Reference = require_reference();
    var KIND = "selfreference";
    var SelfReference = Reference.extends(KIND, function SelfReference2(raw, docs, location) {
      Reference.apply(this, [KIND, docs, location]);
      this.raw = raw;
    });
    module2.exports = SelfReference;
  }
});

// node_modules/php-parser/src/ast/silent.js
var require_silent = __commonJS({
  "node_modules/php-parser/src/ast/silent.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "silent";
    module2.exports = Expression2.extends(KIND, function Silent(expr, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.expr = expr;
    });
  }
});

// node_modules/php-parser/src/ast/static.js
var require_static = __commonJS({
  "node_modules/php-parser/src/ast/static.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "static";
    module2.exports = Statement.extends(KIND, function Static(variables, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.variables = variables;
    });
  }
});

// node_modules/php-parser/src/ast/staticvariable.js
var require_staticvariable = __commonJS({
  "node_modules/php-parser/src/ast/staticvariable.js"(exports, module2) {
    "use strict";
    var Node8 = require_node();
    var KIND = "staticvariable";
    module2.exports = Node8.extends(KIND, function StaticVariable(variable, defaultValue, docs, location) {
      Node8.apply(this, [KIND, docs, location]);
      this.variable = variable;
      this.defaultValue = defaultValue;
    });
  }
});

// node_modules/php-parser/src/ast/staticlookup.js
var require_staticlookup = __commonJS({
  "node_modules/php-parser/src/ast/staticlookup.js"(exports, module2) {
    "use strict";
    var Lookup = require_lookup();
    var KIND = "staticlookup";
    module2.exports = Lookup.extends(KIND, function StaticLookup(what, offset, docs, location) {
      Lookup.apply(this, [KIND, what, offset, docs, location]);
    });
  }
});

// node_modules/php-parser/src/ast/staticreference.js
var require_staticreference = __commonJS({
  "node_modules/php-parser/src/ast/staticreference.js"(exports, module2) {
    "use strict";
    var Reference = require_reference();
    var KIND = "staticreference";
    var StaticReference = Reference.extends(KIND, function StaticReference2(raw, docs, location) {
      Reference.apply(this, [KIND, docs, location]);
      this.raw = raw;
    });
    module2.exports = StaticReference;
  }
});

// node_modules/php-parser/src/ast/string.js
var require_string = __commonJS({
  "node_modules/php-parser/src/ast/string.js"(exports, module2) {
    "use strict";
    var Literal = require_literal();
    var KIND = "string";
    module2.exports = Literal.extends(KIND, function String2(isDoubleQuote, value, unicode, raw, docs, location) {
      Literal.apply(this, [KIND, value, raw, docs, location]);
      this.unicode = unicode;
      this.isDoubleQuote = isDoubleQuote;
    });
  }
});

// node_modules/php-parser/src/ast/switch.js
var require_switch2 = __commonJS({
  "node_modules/php-parser/src/ast/switch.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "switch";
    module2.exports = Statement.extends(KIND, function Switch(test, body, shortForm, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.test = test;
      this.body = body;
      this.shortForm = shortForm;
    });
  }
});

// node_modules/php-parser/src/ast/throw.js
var require_throw = __commonJS({
  "node_modules/php-parser/src/ast/throw.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "throw";
    module2.exports = Statement.extends(KIND, function Throw(what, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.what = what;
    });
  }
});

// node_modules/php-parser/src/ast/trait.js
var require_trait = __commonJS({
  "node_modules/php-parser/src/ast/trait.js"(exports, module2) {
    "use strict";
    var Declaration = require_declaration();
    var KIND = "trait";
    module2.exports = Declaration.extends(KIND, function Trait(name, body, docs, location) {
      Declaration.apply(this, [KIND, name, docs, location]);
      this.body = body;
    });
  }
});

// node_modules/php-parser/src/ast/traitalias.js
var require_traitalias = __commonJS({
  "node_modules/php-parser/src/ast/traitalias.js"(exports, module2) {
    "use strict";
    var Node8 = require_node();
    var KIND = "traitalias";
    var IS_UNDEFINED = "";
    var IS_PUBLIC = "public";
    var IS_PROTECTED = "protected";
    var IS_PRIVATE = "private";
    module2.exports = Node8.extends(KIND, function TraitAlias(trait, method, as, flags, docs, location) {
      Node8.apply(this, [KIND, docs, location]);
      this.trait = trait;
      this.method = method;
      this.as = as;
      this.visibility = IS_UNDEFINED;
      if (flags) {
        if (flags[0] === 0) {
          this.visibility = IS_PUBLIC;
        } else if (flags[0] === 1) {
          this.visibility = IS_PROTECTED;
        } else if (flags[0] === 2) {
          this.visibility = IS_PRIVATE;
        }
      }
    });
  }
});

// node_modules/php-parser/src/ast/traitprecedence.js
var require_traitprecedence = __commonJS({
  "node_modules/php-parser/src/ast/traitprecedence.js"(exports, module2) {
    "use strict";
    var Node8 = require_node();
    var KIND = "traitprecedence";
    module2.exports = Node8.extends(KIND, function TraitPrecedence(trait, method, instead, docs, location) {
      Node8.apply(this, [KIND, docs, location]);
      this.trait = trait;
      this.method = method;
      this.instead = instead;
    });
  }
});

// node_modules/php-parser/src/ast/traituse.js
var require_traituse = __commonJS({
  "node_modules/php-parser/src/ast/traituse.js"(exports, module2) {
    "use strict";
    var Node8 = require_node();
    var KIND = "traituse";
    module2.exports = Node8.extends(KIND, function TraitUse(traits, adaptations, docs, location) {
      Node8.apply(this, [KIND, docs, location]);
      this.traits = traits;
      this.adaptations = adaptations;
    });
  }
});

// node_modules/php-parser/src/ast/try.js
var require_try2 = __commonJS({
  "node_modules/php-parser/src/ast/try.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "try";
    module2.exports = Statement.extends(KIND, function Try(body, catches, always, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.body = body;
      this.catches = catches;
      this.always = always;
    });
  }
});

// node_modules/php-parser/src/ast/typereference.js
var require_typereference = __commonJS({
  "node_modules/php-parser/src/ast/typereference.js"(exports, module2) {
    "use strict";
    var Reference = require_reference();
    var KIND = "typereference";
    var TypeReference3 = Reference.extends(KIND, function TypeReference4(name, raw, docs, location) {
      Reference.apply(this, [KIND, docs, location]);
      this.name = name;
      this.raw = raw;
    });
    TypeReference3.types = [
      "int",
      "float",
      "string",
      "bool",
      "object",
      "array",
      "callable",
      "iterable",
      "void",
      "static"
    ];
    module2.exports = TypeReference3;
  }
});

// node_modules/php-parser/src/ast/unary.js
var require_unary = __commonJS({
  "node_modules/php-parser/src/ast/unary.js"(exports, module2) {
    "use strict";
    var Operation = require_operation();
    var KIND = "unary";
    module2.exports = Operation.extends(KIND, function Unary(type, what, docs, location) {
      Operation.apply(this, [KIND, docs, location]);
      this.type = type;
      this.what = what;
    });
  }
});

// node_modules/php-parser/src/ast/uniontype.js
var require_uniontype = __commonJS({
  "node_modules/php-parser/src/ast/uniontype.js"(exports, module2) {
    "use strict";
    var Declaration = require_declaration();
    var KIND = "uniontype";
    module2.exports = Declaration.extends(KIND, function UnionType(types, docs, location) {
      Declaration.apply(this, [KIND, null, docs, location]);
      this.types = types;
    });
  }
});

// node_modules/php-parser/src/ast/unset.js
var require_unset = __commonJS({
  "node_modules/php-parser/src/ast/unset.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "unset";
    module2.exports = Statement.extends(KIND, function Unset(variables, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.variables = variables;
    });
  }
});

// node_modules/php-parser/src/ast/usegroup.js
var require_usegroup = __commonJS({
  "node_modules/php-parser/src/ast/usegroup.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "usegroup";
    module2.exports = Statement.extends(KIND, function UseGroup2(name, type, items, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.name = name;
      this.type = type;
      this.items = items;
    });
  }
});

// node_modules/php-parser/src/ast/useitem.js
var require_useitem = __commonJS({
  "node_modules/php-parser/src/ast/useitem.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "useitem";
    var UseItem2 = Statement.extends(KIND, function UseItem3(name, alias, type, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.name = name;
      this.alias = alias;
      this.type = type;
    });
    UseItem2.TYPE_CONST = "const";
    UseItem2.TYPE_FUNCTION = "function";
    module2.exports = UseItem2;
  }
});

// node_modules/php-parser/src/ast/variable.js
var require_variable2 = __commonJS({
  "node_modules/php-parser/src/ast/variable.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "variable";
    module2.exports = Expression2.extends(KIND, function Variable(name, curly, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.name = name;
      this.curly = curly || false;
    });
  }
});

// node_modules/php-parser/src/ast/variadic.js
var require_variadic = __commonJS({
  "node_modules/php-parser/src/ast/variadic.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "variadic";
    module2.exports = Expression2.extends(KIND, function variadic(what, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.what = what;
    });
  }
});

// node_modules/php-parser/src/ast/variadicplaceholder.js
var require_variadicplaceholder = __commonJS({
  "node_modules/php-parser/src/ast/variadicplaceholder.js"(exports, module2) {
    "use strict";
    var Node8 = require_node();
    var KIND = "variadicplaceholder";
    module2.exports = Node8.extends(KIND, function VariadicPlaceholder(docs, location) {
      Node8.apply(this, [KIND, docs, location]);
    });
  }
});

// node_modules/php-parser/src/ast/while.js
var require_while = __commonJS({
  "node_modules/php-parser/src/ast/while.js"(exports, module2) {
    "use strict";
    var Statement = require_statement2();
    var KIND = "while";
    module2.exports = Statement.extends(KIND, function While(test, body, shortForm, docs, location) {
      Statement.apply(this, [KIND, docs, location]);
      this.test = test;
      this.body = body;
      this.shortForm = shortForm;
    });
  }
});

// node_modules/php-parser/src/ast/yield.js
var require_yield = __commonJS({
  "node_modules/php-parser/src/ast/yield.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "yield";
    module2.exports = Expression2.extends(KIND, function Yield(value, key, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.value = value;
      this.key = key;
    });
  }
});

// node_modules/php-parser/src/ast/yieldfrom.js
var require_yieldfrom = __commonJS({
  "node_modules/php-parser/src/ast/yieldfrom.js"(exports, module2) {
    "use strict";
    var Expression2 = require_expression();
    var KIND = "yieldfrom";
    module2.exports = Expression2.extends(KIND, function YieldFrom(value, docs, location) {
      Expression2.apply(this, [KIND, docs, location]);
      this.value = value;
    });
  }
});

// node_modules/php-parser/src/ast.js
var require_ast = __commonJS({
  "node_modules/php-parser/src/ast.js"(exports, module2) {
    "use strict";
    var Location = require_location();
    var Position14 = require_position();
    var AST = function(withPositions, withSource) {
      this.withPositions = withPositions;
      this.withSource = withSource;
    };
    AST.precedence = {};
    [
      ["or"],
      ["xor"],
      ["and"],
      ["="],
      ["?"],
      ["??"],
      ["||"],
      ["&&"],
      ["|"],
      ["^"],
      ["&"],
      ["==", "!=", "===", "!==", "<=>"],
      ["<", "<=", ">", ">="],
      ["<<", ">>"],
      ["+", "-", "."],
      ["*", "/", "%"],
      ["!"],
      ["instanceof"],
      ["cast", "silent"],
      ["**"]
    ].forEach(function(list, index) {
      list.forEach(function(operator) {
        AST.precedence[operator] = index + 1;
      });
    });
    AST.prototype.isRightAssociative = function(operator) {
      return operator === "**" || operator === "??";
    };
    AST.prototype.swapLocations = function(target, first, last, parser) {
      if (this.withPositions) {
        target.loc.start = first.loc.start;
        target.loc.end = last.loc.end;
        if (this.withSource) {
          target.loc.source = parser.lexer._input.substring(target.loc.start.offset, target.loc.end.offset);
        }
      }
    };
    AST.prototype.resolveLocations = function(target, first, last, parser) {
      if (this.withPositions) {
        if (target.loc.start.offset > first.loc.start.offset) {
          target.loc.start = first.loc.start;
        }
        if (target.loc.end.offset < last.loc.end.offset) {
          target.loc.end = last.loc.end;
        }
        if (this.withSource) {
          target.loc.source = parser.lexer._input.substring(target.loc.start.offset, target.loc.end.offset);
        }
      }
    };
    AST.prototype.resolvePrecedence = function(result, parser) {
      let buffer, lLevel, rLevel;
      if (result.kind === "call") {
        this.resolveLocations(result, result.what, result, parser);
      } else if (result.kind === "propertylookup" || result.kind === "staticlookup" || result.kind === "offsetlookup" && result.offset) {
        this.resolveLocations(result, result.what, result.offset, parser);
      } else if (result.kind === "bin") {
        if (result.right && !result.right.parenthesizedExpression) {
          if (result.right.kind === "bin") {
            lLevel = AST.precedence[result.type];
            rLevel = AST.precedence[result.right.type];
            if (lLevel && rLevel && rLevel <= lLevel && (result.type !== result.right.type || !this.isRightAssociative(result.type))) {
              buffer = result.right;
              result.right = result.right.left;
              this.swapLocations(result, result.left, result.right, parser);
              buffer.left = this.resolvePrecedence(result, parser);
              this.swapLocations(buffer, buffer.left, buffer.right, parser);
              result = buffer;
            }
          } else if (result.right.kind === "retif") {
            lLevel = AST.precedence[result.type];
            rLevel = AST.precedence["?"];
            if (lLevel && rLevel && rLevel <= lLevel) {
              buffer = result.right;
              result.right = result.right.test;
              this.swapLocations(result, result.left, result.right, parser);
              buffer.test = this.resolvePrecedence(result, parser);
              this.swapLocations(buffer, buffer.test, buffer.falseExpr, parser);
              result = buffer;
            }
          }
        }
      } else if ((result.kind === "silent" || result.kind === "cast") && result.expr && !result.expr.parenthesizedExpression) {
        if (result.expr.kind === "bin") {
          buffer = result.expr;
          result.expr = result.expr.left;
          this.swapLocations(result, result, result.expr, parser);
          buffer.left = this.resolvePrecedence(result, parser);
          this.swapLocations(buffer, buffer.left, buffer.right, parser);
          result = buffer;
        } else if (result.expr.kind === "retif") {
          buffer = result.expr;
          result.expr = result.expr.test;
          this.swapLocations(result, result, result.expr, parser);
          buffer.test = this.resolvePrecedence(result, parser);
          this.swapLocations(buffer, buffer.test, buffer.falseExpr, parser);
          result = buffer;
        }
      } else if (result.kind === "unary") {
        if (result.what && !result.what.parenthesizedExpression) {
          if (result.what.kind === "bin") {
            buffer = result.what;
            result.what = result.what.left;
            this.swapLocations(result, result, result.what, parser);
            buffer.left = this.resolvePrecedence(result, parser);
            this.swapLocations(buffer, buffer.left, buffer.right, parser);
            result = buffer;
          } else if (result.what.kind === "retif") {
            buffer = result.what;
            result.what = result.what.test;
            this.swapLocations(result, result, result.what, parser);
            buffer.test = this.resolvePrecedence(result, parser);
            this.swapLocations(buffer, buffer.test, buffer.falseExpr, parser);
            result = buffer;
          }
        }
      } else if (result.kind === "retif") {
        if (result.falseExpr && result.falseExpr.kind === "retif" && !result.falseExpr.parenthesizedExpression) {
          buffer = result.falseExpr;
          result.falseExpr = buffer.test;
          this.swapLocations(result, result.test, result.falseExpr, parser);
          buffer.test = this.resolvePrecedence(result, parser);
          this.swapLocations(buffer, buffer.test, buffer.falseExpr, parser);
          result = buffer;
        }
      } else if (result.kind === "assign") {
        if (result.right && result.right.kind === "bin" && !result.right.parenthesizedExpression) {
          lLevel = AST.precedence["="];
          rLevel = AST.precedence[result.right.type];
          if (lLevel && rLevel && rLevel < lLevel) {
            buffer = result.right;
            result.right = result.right.left;
            buffer.left = result;
            this.swapLocations(buffer, buffer.left, result.right, parser);
            result = buffer;
          }
        }
      } else if (result.kind === "expressionstatement") {
        this.swapLocations(result, result.expression, result, parser);
      }
      return result;
    };
    AST.prototype.prepare = function(kind, docs, parser) {
      let start = null;
      if (this.withPositions || this.withSource) {
        start = parser.position();
      }
      const self = this;
      const result = function() {
        let location = null;
        const args = Array.prototype.slice.call(arguments);
        args.push(docs);
        if (self.withPositions || self.withSource) {
          let src = null;
          if (self.withSource) {
            src = parser.lexer._input.substring(start.offset, parser.prev[2]);
          }
          location = new Location(src, start, new Position14(parser.prev[0], parser.prev[1], parser.prev[2]));
          args.push(location);
        }
        if (!kind) {
          kind = args.shift();
        }
        const node = self[kind];
        if (typeof node !== "function") {
          throw new Error('Undefined node "' + kind + '"');
        }
        const astNode = Object.create(node.prototype);
        node.apply(astNode, args);
        result.instance = astNode;
        if (result.trailingComments) {
          astNode.trailingComments = result.trailingComments;
        }
        if (typeof result.postBuild === "function") {
          result.postBuild(astNode);
        }
        if (parser.debug) {
          delete self.stack[result.stackUid];
        }
        return self.resolvePrecedence(astNode, parser);
      };
      if (parser.debug) {
        if (!this.stack) {
          this.stack = {};
          this.stackUid = 1;
        }
        this.stack[++this.stackUid] = {
          position: start,
          stack: new Error().stack.split("\n").slice(3, 5)
        };
        result.stackUid = this.stackUid;
      }
      result.setTrailingComments = function(docs2) {
        if (result.instance) {
          result.instance.setTrailingComments(docs2);
        } else {
          result.trailingComments = docs2;
        }
      };
      result.destroy = function(target) {
        if (docs) {
          if (target) {
            if (!target.leadingComments) {
              target.leadingComments = docs;
            } else {
              target.leadingComments = docs.concat(target.leadingComments);
            }
          } else {
            parser._docIndex = parser._docs.length - docs.length;
          }
        }
        if (parser.debug) {
          delete self.stack[result.stackUid];
        }
      };
      return result;
    };
    AST.prototype.checkNodes = function() {
      const errors = [];
      for (const k in this.stack) {
        if (Object.prototype.hasOwnProperty.call(this.stack, k)) {
          this.stack[k].key = k;
          errors.push(this.stack[k]);
        }
      }
      this.stack = {};
      return errors;
    };
    [
      require_array2(),
      require_arrowfunc(),
      require_assign(),
      require_assignref(),
      require_attribute2(),
      require_attrgroup(),
      require_bin(),
      require_block(),
      require_boolean(),
      require_break(),
      require_byref(),
      require_call(),
      require_case(),
      require_cast(),
      require_catch(),
      require_class2(),
      require_classconstant(),
      require_clone(),
      require_closure(),
      require_comment2(),
      require_commentblock(),
      require_commentline(),
      require_constant(),
      require_constantstatement(),
      require_continue(),
      require_declaration(),
      require_declare(),
      require_declaredirective(),
      require_do(),
      require_echo(),
      require_empty(),
      require_encapsed(),
      require_encapsedpart(),
      require_entry(),
      require_enum2(),
      require_enumcase(),
      require_error(),
      require_eval(),
      require_exit(),
      require_expression(),
      require_expressionstatement(),
      require_for(),
      require_foreach(),
      require_function2(),
      require_global(),
      require_goto(),
      require_halt(),
      require_identifier(),
      require_if2(),
      require_include(),
      require_inline(),
      require_interface(),
      require_intersectiontype(),
      require_isset(),
      require_label(),
      require_list(),
      require_literal(),
      require_lookup(),
      require_magic(),
      require_match(),
      require_matcharm(),
      require_method(),
      require_name(),
      require_namespace2(),
      require_namedargument(),
      require_new(),
      require_node(),
      require_noop(),
      require_nowdoc(),
      require_nullkeyword(),
      require_nullsafepropertylookup(),
      require_number(),
      require_offsetlookup(),
      require_operation(),
      require_parameter(),
      require_parentreference(),
      require_post(),
      require_pre(),
      require_print(),
      require_program(),
      require_property2(),
      require_propertylookup(),
      require_propertystatement(),
      require_reference(),
      require_retif(),
      require_return(),
      require_selfreference(),
      require_silent(),
      require_statement2(),
      require_static(),
      require_staticvariable(),
      require_staticlookup(),
      require_staticreference(),
      require_string(),
      require_switch2(),
      require_throw(),
      require_trait(),
      require_traitalias(),
      require_traitprecedence(),
      require_traituse(),
      require_try2(),
      require_typereference(),
      require_unary(),
      require_uniontype(),
      require_unset(),
      require_usegroup(),
      require_useitem(),
      require_variable2(),
      require_variadic(),
      require_variadicplaceholder(),
      require_while(),
      require_yield(),
      require_yieldfrom()
    ].forEach(function(ctor) {
      AST.prototype[ctor.kind] = ctor;
    });
    module2.exports = AST;
  }
});

// node_modules/php-parser/src/index.js
var require_src = __commonJS({
  "node_modules/php-parser/src/index.js"(exports, module2) {
    "use strict";
    var lexer = require_lexer();
    var parser = require_parser();
    var tokens = require_tokens2();
    var AST = require_ast();
    function combine(src, to) {
      const keys = Object.keys(src);
      let i = keys.length;
      while (i--) {
        const k = keys[i];
        const val = src[k];
        if (val === null) {
          delete to[k];
        } else if (typeof val === "function") {
          to[k] = val.bind(to);
        } else if (Array.isArray(val)) {
          to[k] = Array.isArray(to[k]) ? to[k].concat(val) : val;
        } else if (typeof val === "object") {
          to[k] = typeof to[k] === "object" ? combine(val, to[k]) : val;
        } else {
          to[k] = val;
        }
      }
      return to;
    }
    var Engine9 = function(options) {
      if (typeof this === "function") {
        return new this(options);
      }
      this.tokens = tokens;
      this.lexer = new lexer(this);
      this.ast = new AST();
      this.parser = new parser(this.lexer, this.ast);
      if (options && typeof options === "object") {
        if (options.parser) {
          if (!options.lexer) {
            options.lexer = {};
          }
          if (options.parser.version) {
            if (typeof options.parser.version === "string") {
              let version = options.parser.version.split(".");
              version = parseInt(version[0]) * 100 + parseInt(version[1]);
              if (isNaN(version)) {
                throw new Error("Bad version number : " + options.parser.version);
              } else {
                options.parser.version = version;
              }
            } else if (typeof options.parser.version !== "number") {
              throw new Error("Expecting a number for version");
            }
            if (options.parser.version < 500 || options.parser.version > 900) {
              throw new Error("Can only handle versions between 5.x to 8.x");
            }
          }
        }
        combine(options, this);
        this.lexer.version = this.parser.version;
      }
    };
    var getStringBuffer = function(buffer) {
      return typeof buffer.write === "function" ? buffer.toString() : buffer;
    };
    Engine9.create = function(options) {
      return new Engine9(options);
    };
    Engine9.parseEval = function(buffer, options) {
      const self = new Engine9(options);
      return self.parseEval(buffer);
    };
    Engine9.prototype.parseEval = function(buffer) {
      this.lexer.mode_eval = true;
      this.lexer.all_tokens = false;
      buffer = getStringBuffer(buffer);
      return this.parser.parse(buffer, "eval");
    };
    Engine9.parseCode = function(buffer, filename, options) {
      if (typeof filename === "object" && !options) {
        options = filename;
        filename = "unknown";
      }
      const self = new Engine9(options);
      return self.parseCode(buffer, filename);
    };
    Engine9.prototype.parseCode = function(buffer, filename) {
      this.lexer.mode_eval = false;
      this.lexer.all_tokens = false;
      buffer = getStringBuffer(buffer);
      return this.parser.parse(buffer, filename);
    };
    Engine9.tokenGetAll = function(buffer, options) {
      const self = new Engine9(options);
      return self.tokenGetAll(buffer);
    };
    Engine9.prototype.tokenGetAll = function(buffer) {
      this.lexer.mode_eval = false;
      this.lexer.all_tokens = true;
      buffer = getStringBuffer(buffer);
      const EOF = this.lexer.EOF;
      const names = this.tokens.values;
      this.lexer.setInput(buffer);
      let token = this.lexer.lex() || EOF;
      const result = [];
      while (token != EOF) {
        let entry = this.lexer.yytext;
        if (Object.prototype.hasOwnProperty.call(names, token)) {
          entry = [names[token], entry, this.lexer.yylloc.first_line];
        }
        result.push(entry);
        token = this.lexer.lex() || EOF;
      }
      return result;
    };
    module2.exports = Engine9;
    module2.exports.tokens = tokens;
    module2.exports.lexer = lexer;
    module2.exports.AST = AST;
    module2.exports.parser = parser;
    module2.exports.combine = combine;
    module2.exports.Engine = Engine9;
    module2.exports.default = Engine9;
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  activate: () => activate19
});
module.exports = __toCommonJS(src_exports);
var import_coc19 = require("coc.nvim");
var import_fs8 = __toESM(require("fs"));

// src/actions/changeVisibility.ts
var import_coc = require("coc.nvim");
function activate(context) {
  const documentSelector = [{ language: "php", scheme: "file" }];
  context.subscriptions.push(import_coc.languages.registerCodeActionProvider(documentSelector, new ChangeVisibilityCodeActionProvider(), "intelephense"));
  context.subscriptions.push(import_coc.commands.registerCommand("intelephense.runChangeVisibility", runChangeVisibilityCommand(), null, true));
}
function runChangeVisibilityCommand() {
  return async (doc, wordRange, text) => {
    const visibilities = ["public", "protected", "private"];
    const changeVisibilities = visibilities.filter((v) => v !== text);
    const picked = await import_coc.window.showMenuPicker(changeVisibilities, `Select (from ${text})`);
    if (picked !== -1) {
      const edits = [import_coc.TextEdit.replace(wordRange, changeVisibilities[picked])];
      await doc.applyEdits(edits);
    }
  };
}
var ChangeVisibilityCodeActionProvider = class {
  async provideCodeActions(document, range) {
    const codeActions = [];
    const doc = import_coc.workspace.getDocument(document.uri);
    if (this.cursorRange(range)) {
      const cursorPosition = await import_coc.window.getCursorPosition();
      const wordRange = doc.getWordRangeAtPosition(cursorPosition);
      if (!wordRange)
        return [];
      const text = document.getText(wordRange) || "";
      if (!text)
        return [];
      if (!["public", "protected", "private"].includes(text))
        return [];
      const actionCommand = {
        title: "",
        command: "intelephense.runChangeVisibility",
        arguments: [doc, wordRange, text]
      };
      const codeAction = {
        title: "Change Visibility",
        command: actionCommand
      };
      codeActions.push(codeAction);
    }
    return codeActions;
  }
  cursorRange(range) {
    return range.start.line === range.end.line && range.start.character === range.end.character;
  }
};

// src/actions/getterSetter.ts
var import_coc2 = require("coc.nvim");

// src/parsers/getterSetter.ts
var import_php_parser = __toESM(require_src());

// src/parsers/phpDoc.ts
function matchTypeDetailFromVarTag(docLine, variable) {
  let matchTypeDetail = null;
  const patterns = [
    `@var\\s+([\\w|<,\\-\\s\\\\]+[>]+)\\s+(\\$${variable})\\s+.*$`,
    `@var\\s+(\\S+)\\s+(\\$${variable})\\s+.*$`,
    `@var\\s+([\\w|<,\\-\\s\\\\]+[>]+)\\s+(\\$${variable})$`,
    `@var\\s+(\\S+)\\s+(\\$${variable})$`,
    `@var\\s+([\\w|<,\\-\\s\\\\]+[>]+)$`,
    `@var\\s+(\\S+)$`
  ];
  if (docLine.includes("@var")) {
    for (const p of patterns) {
      const trimDocLine = docLine.trim();
      const reg = new RegExp(p);
      const m = reg.exec(trimDocLine);
      if (m) {
        matchTypeDetail = {
          value: m[1],
          trimedInput: m.input,
          pattern: p
        };
        break;
      }
    }
  }
  return matchTypeDetail;
}

// src/parsers/getterSetter.ts
var parserEngine = new import_php_parser.Engine({
  parser: {
    extractDoc: true,
    php7: true,
    locations: true,
    suppressErrors: true
  },
  ast: {
    all_tokens: true,
    withPositions: true
  }
});
function getAst(code) {
  try {
    return parserEngine.parseEval(stripPHPTag(code));
  } catch (e) {
    return void 0;
  }
  function stripPHPTag(code2) {
    return code2.replace("<?php", "").replace("?>", "");
  }
}
function isClassRegion(code, startLine, endLine) {
  let flag = false;
  const ast = getAst(code);
  if (!ast)
    return flag;
  const classNode = getClassesNodes(ast.children);
  classNode.forEach((c) => {
    if (c.loc && c.loc.start.line <= startLine && c.loc.end.line >= endLine) {
      flag = true;
    }
  });
  return flag;
}
function getMethods(nodes) {
  const methods = [];
  function wrapper(node) {
    if (node.kind === "class") {
      const classNode = node;
      classNode.body.forEach((node2) => {
        const methodDetail = getMethod(node2);
        if (methodDetail) {
          methods.push(methodDetail);
        }
      });
    }
  }
  nodes.forEach((node) => {
    if (node.kind === "namespace") {
      const namespaceNode = node;
      namespaceNode.children.forEach((node2) => {
        wrapper(node2);
      });
    }
  });
  nodes.forEach((node) => {
    wrapper(node);
  });
  return methods;
}
function getMethod(node) {
  if (node.kind !== "method")
    return;
  const methodNode = node;
  if (!methodNode.loc)
    return;
  const identifer = methodNode.name;
  const name = identifer.name;
  const startLine = methodNode.loc.start.line;
  const endLine = methodNode.loc.end.line;
  const comments = [];
  if (methodNode.leadingComments) {
    const leadingComments = methodNode.leadingComments;
    leadingComments.forEach((comment) => {
      comments.push(comment.value);
    });
  }
  const methodDetail = {
    name,
    startLine,
    endLine,
    comments
  };
  return methodDetail;
}
function getClassesNodes(node) {
  const classNodes = [];
  function wrapper(node2) {
    if (node2.kind === "class") {
      const classNode = node2;
      classNodes.push(classNode);
    }
  }
  node.forEach((node2) => {
    if (node2.kind === "namespace") {
      const namespaceNode = node2;
      namespaceNode.children.forEach((node3) => {
        wrapper(node3);
      });
    }
  });
  node.forEach((node2) => {
    wrapper(node2);
  });
  return classNodes;
}
function getPropertiesWithClassDetail(nodes) {
  const propertiesWithClassDetail = [];
  const classNodes = getClassesNodes(nodes);
  classNodes.forEach((classNode) => {
    const identiferNode = classNode.name;
    const className = identiferNode.name;
    const classStartLine = classNode.loc ? classNode.loc.start.line : 0;
    const classEndLine = classNode.loc ? classNode.loc.end.line : 0;
    classNode.body.forEach((declaration) => {
      const propertiesDetails = getProperties(declaration);
      if (propertiesDetails) {
        propertiesDetails.forEach((p) => {
          propertiesWithClassDetail.push(__spreadValues({
            className,
            classStartLine,
            classEndLine
          }, p));
        });
      }
    });
  });
  return propertiesWithClassDetail;
}
function getProperties(node) {
  const propertiesDetails = [];
  if (node.kind !== "propertystatement")
    return propertiesDetails;
  const propertyStatementNode = node;
  const parentNode = node;
  propertyStatementNode.properties.forEach((node2) => {
    if (node2.kind === "property") {
      const propertyNode = node2;
      const identifiierNode = propertyNode.name;
      const name = identifiierNode.name;
      const nullable = propertyNode.nullable;
      const startLine = propertyNode.loc ? propertyNode.loc.start.line : 0;
      const endLine = propertyNode.loc ? propertyNode.loc.end.line : 0;
      let type = null;
      let docVarType = null;
      const comments = [];
      if (propertyNode.type) {
        if (Array.isArray(propertyNode.type)) {
        } else {
          if (propertyNode.type.kind === "typereference") {
            const typereferenceNode = propertyNode.type;
            type = typereferenceNode.name;
          } else if (propertyNode.type.kind === "name") {
            const nameNode = propertyNode.type;
            type = nameNode.name;
          } else if (propertyNode.type.kind === "uniontype") {
            if ("types" in propertyNode.type) {
              const uniontypeTypesNode = propertyNode.type["types"];
              const items = [];
              uniontypeTypesNode.forEach((node3) => {
                items.push(node3.name);
              });
              type = items;
            }
          }
        }
      }
      if (parentNode.leadingComments) {
        const leadingComments = parentNode["leadingComments"];
        leadingComments.forEach((c) => {
          if (c.kind === "commentblock") {
            const commentNode = c;
            comments.push(commentNode.value);
          }
        });
        comments.forEach((comment) => {
          const splitComments = comment.split("\n");
          splitComments.forEach((c) => {
            if (!docVarType) {
              const matchTypeDetail = matchTypeDetailFromVarTag(c, name);
              if (matchTypeDetail) {
                docVarType = matchTypeDetail == null ? void 0 : matchTypeDetail.value;
              }
            }
          });
        });
      }
      const propertyDetail = {
        propertyName: name,
        propertyNullable: nullable,
        propertyType: type,
        propertyStartLine: startLine,
        propertyEndLine: endLine,
        propertyDocVarType: docVarType
      };
      propertiesDetails.push(propertyDetail);
    }
  });
  return propertiesDetails;
}
function getConstructorPropertiesWithClassDetail(nodes) {
  const propertiesWithClassDetail = [];
  function wrapper(node) {
    if (node.kind === "class") {
      const classNode = node;
      const identiferNode = classNode.name;
      const className = identiferNode.name;
      const classStartLine = classNode.loc ? classNode.loc.start.line : 0;
      const classEndLine = classNode.loc ? classNode.loc.end.line : 0;
      const propertiesDetail = getConstructorProperties(classNode);
      propertiesDetail.forEach((p) => {
        propertiesWithClassDetail.push(__spreadProps(__spreadValues({}, p), {
          className,
          classStartLine,
          classEndLine
        }));
      });
    }
  }
  nodes.forEach((node) => {
    if (node.kind === "namespace") {
      const namespaceNode = node;
      namespaceNode.children.forEach((node2) => {
        wrapper(node2);
      });
    }
  });
  nodes.forEach((node) => {
    wrapper(node);
  });
  return propertiesWithClassDetail;
}
function getConstructorProperties(classNode) {
  const propertiesDetails = [];
  classNode.body.forEach((declaration) => {
    if (declaration.kind === "method") {
      const methodNode = declaration;
      const identifer = methodNode.name;
      if (identifer.name === "__construct") {
        methodNode.arguments.forEach((parameter) => {
          if ("flags" in parameter) {
            const identifiierNode = parameter.name;
            const name = identifiierNode.name;
            const nullable = parameter.nullable;
            const startLine = parameter.loc ? parameter.loc.start.line : 0;
            const endLine = parameter.loc ? parameter.loc.end.line : 0;
            let type = null;
            if (parameter.type) {
              if (Array.isArray(parameter.type)) {
              } else {
                if (parameter.type.kind === "typereference") {
                  const typereferenceNode = parameter.type;
                  type = typereferenceNode.name;
                } else if (parameter.type.kind === "name") {
                  const nameNode = parameter.type;
                  type = nameNode.name;
                } else if (parameter.type.kind === "uniontype") {
                  if ("types" in parameter.type) {
                    const uniontypeTypesNode = parameter.type["types"];
                    const items = [];
                    uniontypeTypesNode.forEach((node) => {
                      items.push(node.name);
                    });
                    type = items;
                  }
                }
              }
            }
            const propertyDetail = {
              propertyName: name,
              propertyNullable: nullable,
              propertyStartLine: startLine,
              propertyEndLine: endLine,
              propertyType: type,
              propertyDocVarType: null
            };
            propertiesDetails.push(propertyDetail);
          }
        });
      }
    }
  });
  return propertiesDetails;
}

// src/actions/getterSetter.ts
var GETTER_SETTER_INDENT_SPACE = 4;
function activate2(context) {
  const documentSelector = [{ language: "php", scheme: "file" }];
  context.subscriptions.push(import_coc2.languages.registerCodeActionProvider(documentSelector, new GetterSetterCodeActionProvider(), "intelephense"));
}
var GetterSetterCodeActionProvider = class {
  constructor() {
  }
  async provideCodeActions(document, range, context, token) {
    const codeActions = [];
    const doc = import_coc2.workspace.getDocument(document.uri);
    if (this.lineRange(range) || this.selectedRange(doc, range)) {
      const ast = getAst(document.getText());
      if (!ast)
        return [];
      if (!isClassRegion(document.getText(), range.start.line + 1, range.end.line + 1)) {
        return [];
      }
      const propertiesFeatureItems = getPropertiesWithClassDetail(ast.children);
      const constructorFeatureItems = getConstructorPropertiesWithClassDetail(ast.children);
      const featureItems = propertiesFeatureItems.concat(constructorFeatureItems);
      const methods = getMethods(ast.children);
      const getterItems = [];
      const setterItems = [];
      featureItems.forEach((f) => {
        if (f.classStartLine <= range.start.line + 1 && f.classEndLine >= range.end.line) {
          if (f.propertyStartLine >= range.start.line + 1 && f.propertyEndLine <= range.end.line) {
            const name = f.propertyName.split("_").map((str) => str.charAt(0).toLocaleUpperCase() + str.slice(1)).join("");
            let existsSameGetter = false;
            let existsSameSetter = false;
            methods.forEach((m) => {
              if (f.classStartLine <= m.startLine && f.classEndLine >= m.endLine) {
                if ("get" + name === m.name)
                  existsSameGetter = true;
                if ("set" + name === m.name)
                  existsSameSetter = true;
              }
            });
            if (!existsSameGetter) {
              getterItems.push({
                methodName: "get" + name,
                propertyName: f.propertyName,
                propertyNullable: f.propertyNullable,
                propertyType: f.propertyType,
                propertyDocVarType: f.propertyDocVarType
              });
            }
            if (!existsSameSetter) {
              setterItems.push({
                methodName: "set" + name,
                propertyName: f.propertyName,
                propertyNullable: f.propertyNullable,
                propertyType: f.propertyType,
                propertyDocVarType: f.propertyDocVarType
              });
            }
          }
        }
      });
      let insertLine;
      if (featureItems) {
        if (featureItems[0]) {
          insertLine = featureItems[0].classEndLine;
        }
      }
      const getterNewText = this.generateGetterNewText(getterItems);
      const setterNewText = this.generateSetterNewText(setterItems);
      if (getterNewText && insertLine) {
        const editPosition = import_coc2.Position.create(insertLine - 1, 0);
        const getterEdit = import_coc2.TextEdit.insert(editPosition, getterNewText);
        const codeAction = {
          title: "Insert PHP Getter",
          edit: {
            changes: {
              [doc.uri]: [getterEdit]
            }
          }
        };
        codeActions.push(codeAction);
      }
      if (setterNewText && insertLine) {
        const editPosition = import_coc2.Position.create(insertLine - 1, 0);
        const setterEdit = import_coc2.TextEdit.insert(editPosition, setterNewText);
        const codeAction = {
          title: "Insert PHP Setter",
          edit: {
            changes: {
              [doc.uri]: [setterEdit]
            }
          }
        };
        codeActions.push(codeAction);
      }
      if (getterNewText && setterNewText && insertLine) {
        const editPosition = import_coc2.Position.create(insertLine - 1, 0);
        const getterSetterNewText = getterNewText + setterNewText;
        const getterSetterEdit = import_coc2.TextEdit.insert(editPosition, getterSetterNewText);
        const codeAction = {
          title: "Insert Getter & Setter",
          edit: {
            changes: {
              [doc.uri]: [getterSetterEdit]
            }
          }
        };
        codeActions.push(codeAction);
      }
    }
    return codeActions;
  }
  generateGetterNewText(items) {
    const newTextLines = [];
    items.forEach((item) => {
      const lines = [];
      const indentSpace = " ".repeat(GETTER_SETTER_INDENT_SPACE);
      lines.push("\n");
      if (item.propertyType === null && item.propertyDocVarType) {
        lines.push(`${indentSpace}/**
`);
        lines.push(`${indentSpace} * @return ${item.propertyDocVarType}
`);
        lines.push(`${indentSpace} */
`);
      }
      if (item.propertyType && Array.isArray(item.propertyType)) {
        const property = item.propertyType.join("|");
        lines.push(`${indentSpace}public function ${item.methodName}(): ${property}
`);
      } else if (item.propertyType && typeof item.propertyType === "string") {
        lines.push(`${indentSpace}public function ${item.methodName}(): ${item.propertyNullable ? "?" : ""}${item.propertyType}
`);
      } else {
        lines.push(`${indentSpace}public function ${item.methodName}()
`);
      }
      lines.push(`${indentSpace}{
`);
      lines.push(`${indentSpace}${indentSpace}return ${"$this->" + item.propertyName};
`);
      lines.push(`${indentSpace}}
`);
      newTextLines.push(...lines);
    });
    return newTextLines ? newTextLines.join("") : void 0;
  }
  generateSetterNewText(items) {
    const newTextLines = [];
    items.forEach((item) => {
      const lines = [];
      const indentSpace = " ".repeat(GETTER_SETTER_INDENT_SPACE);
      lines.push("\n");
      if (item.propertyType === null && item.propertyDocVarType) {
        lines.push(`${indentSpace}/**
`);
        lines.push(`${indentSpace} * @param ${item.propertyDocVarType} $${item.propertyName}
`);
        lines.push(`${indentSpace} */
`);
      }
      if (item.propertyType && Array.isArray(item.propertyType)) {
        const property = item.propertyType.join("|");
        lines.push(`${indentSpace}public function ${item.methodName}(${item.propertyNullable ? "?" : ""}${property} $${item.propertyName})
`);
      } else if (item.propertyType && typeof item.propertyType === "string") {
        lines.push(`${indentSpace}public function ${item.methodName}(${item.propertyNullable ? "?" : ""}${item.propertyType} $${item.propertyName})
`);
      } else {
        lines.push(`${indentSpace}public function ${item.methodName}($${item.propertyName})
`);
      }
      lines.push(`${indentSpace}{
`);
      lines.push(`${indentSpace}${indentSpace}${"$this->" + item.propertyName} = $${item.propertyName};
`);
      lines.push(`${indentSpace}}
`);
      newTextLines.push(...lines);
    });
    return newTextLines ? newTextLines.join("") : void 0;
  }
  wholeRange(doc, range) {
    const whole = import_coc2.Range.create(0, 0, doc.lineCount, 0);
    return whole.start.line === range.start.line && whole.start.character === range.start.character && whole.end.line === range.end.line && whole.end.character === whole.end.character;
  }
  lineRange(r) {
    return r.start.line + 1 === r.end.line && r.start.character === 0 && r.end.character === 0 || r.start.line === r.end.line && r.start.character === 0;
  }
  selectedRange(doc, range) {
    return range.start.line < range.end.line && !this.wholeRange(doc, range);
  }
};

// src/actions/ignoreComment.ts
var import_coc3 = require("coc.nvim");
function activate3(context) {
  if (import_coc3.workspace.getConfiguration("intelephense").get("client.diagnosticsIgnoreErrorFeature")) {
    context.subscriptions.push(import_coc3.languages.registerCodeActionProvider([{ language: "php", scheme: "file" }], new IgnoreCommentCodeActionProvider(), "intelephense"));
  }
}
var IgnoreCommentCodeActionProvider = class {
  async provideCodeActions(document, range, context) {
    const doc = import_coc3.workspace.getDocument(document.uri);
    const codeActions = [];
    if (this.lineRange(range) && context.diagnostics.length > 0) {
      let existsIntelephenseDiagnostics = false;
      context.diagnostics.forEach((d) => {
        if (d.source === "intelephense") {
          existsIntelephenseDiagnostics = true;
        }
      });
      const line = doc.getline(range.start.line);
      const thisLineFullLength = doc.getline(range.start.line).length;
      const thisLineTrimLength = doc.getline(range.start.line).trim().length;
      const ignoreLineLength = thisLineFullLength - thisLineTrimLength;
      let ignoreLineNewText = "/** @intelephense-ignore-next-line */\n";
      if (ignoreLineLength > 0) {
        const addIndentSpace = " ".repeat(ignoreLineLength);
        ignoreLineNewText = "/** @intelephense-ignore-next-line */\n" + addIndentSpace;
      }
      let thisLineContent = doc.getline(range.start.line);
      thisLineContent = thisLineContent.trim();
      if (!thisLineContent.startsWith("/**") && !thisLineContent.startsWith("*") && existsIntelephenseDiagnostics) {
        const edit = import_coc3.TextEdit.insert(import_coc3.Position.create(range.start.line, ignoreLineLength), ignoreLineNewText);
        codeActions.push({
          title: "Add @intelephense-ignore-next-line",
          edit: {
            changes: {
              [doc.uri]: [edit]
            }
          }
        });
      }
      if (!thisLineContent.startsWith("/**") && !thisLineContent.startsWith("*") && existsIntelephenseDiagnostics) {
        const edit = import_coc3.TextEdit.replace(range, `${line} // @intelephense-ignore-line${range.start.line + 1 === range.end.line ? "\n" : ""}`);
        codeActions.push({
          title: "Add @intelephense-ignore-line",
          edit: {
            changes: {
              [doc.uri]: [edit]
            }
          }
        });
      }
    }
    return codeActions;
  }
  async _getWordAtCursorPosition(document, doc) {
    const cursorPosition = await import_coc3.window.getCursorPosition();
    const wordRange = doc.getWordRangeAtPosition(cursorPosition, "$");
    if (!wordRange)
      return null;
    const text = document.getText(wordRange) || "";
    if (!text)
      return null;
    return text;
  }
  lineRange(r) {
    return r.start.line + 1 === r.end.line && r.start.character === 0 && r.end.character === 0 || r.start.line === r.end.line && r.start.character === 0;
  }
};

// src/actions/openPHPNet.ts
var import_coc4 = require("coc.nvim");
function activate4(context) {
  context.subscriptions.push(import_coc4.languages.registerCodeActionProvider([{ language: "php", scheme: "file" }], new OpenPHPNetCodeActionProvider(), "intelephense"));
}
var OpenPHPNetCodeActionProvider = class {
  async provideCodeActions(document, range, context) {
    const doc = import_coc4.workspace.getDocument(document.uri);
    const codeActions = [];
    if (this.lineRange(range) || range.start.line === range.end.line) {
      const text = await this._getWordAtCursorPosition(document, doc);
      if (text) {
        const url = "https://www.php.net/" + encodeURIComponent(text);
        const title = `Open 'php.net' for '${text}'`;
        const command = {
          title: "",
          command: "vscode.open",
          arguments: [url]
        };
        const action = {
          title,
          command
        };
        codeActions.push(action);
      }
    }
    return codeActions;
  }
  async _getWordAtCursorPosition(document, doc) {
    const cursorPosition = await import_coc4.window.getCursorPosition();
    const wordRange = doc.getWordRangeAtPosition(cursorPosition, "$");
    if (!wordRange)
      return null;
    const text = document.getText(wordRange) || "";
    if (!text)
      return null;
    return text;
  }
  lineRange(r) {
    return r.start.line + 1 === r.end.line && r.start.character === 0 && r.end.character === 0 || r.start.line === r.end.line && r.start.character === 0;
  }
};

// src/actions/removeUnusedImports.ts
var import_coc5 = require("coc.nvim");

// src/parsers/removeUnusedImports.ts
var import_php_parser2 = __toESM(require_src());
var parserEngine2 = new import_php_parser2.Engine({
  parser: {
    extractDoc: true,
    php7: true,
    locations: true,
    suppressErrors: true
  },
  ast: {
    all_tokens: true,
    withPositions: true
  }
});
function getAst2(code) {
  try {
    return parserEngine2.parseEval(stripPHPTag(code));
  } catch (e) {
    return void 0;
  }
  function stripPHPTag(code2) {
    return code2.replace("<?php", "").replace("?>", "");
  }
}
function getUseNodes(nodes, useGroupNodes = []) {
  for (const node of nodes) {
    if (node.kind === "namespace") {
      const namespaceNode = node;
      getUseNodes(namespaceNode.children, useGroupNodes);
    }
    if (node.kind === "usegroup") {
      const useGroupNode = node;
      useGroupNodes.push(useGroupNode);
    }
  }
  return useGroupNodes;
}
function flattenUseItems(items) {
  const flatItems = [];
  for (const item of items) {
    const name = item.name;
    let aliasName;
    let locStartLine;
    let locStartColumn;
    let locEndLine;
    let locEndColumn;
    if (item.alias) {
      aliasName = item.alias.name;
    } else {
      aliasName = null;
    }
    if (item.loc) {
      locStartLine = item.loc.start.line;
      locStartColumn = item.loc.start.column;
      locEndLine = item.loc.end.line;
      locEndColumn = item.loc.end.column;
    } else {
      locStartLine = 0;
      locStartColumn = 0;
      locEndLine = 0;
      locEndColumn = 0;
    }
    const flatItem = {
      name,
      aliasName,
      locStartLine,
      locStartColumn,
      locEndLine,
      locEndColumn
    };
    flatItems.push(flatItem);
  }
  return flatItems;
}

// src/actions/removeUnusedImports.ts
function activate5(context) {
  const documentSelector = [{ language: "php", scheme: "file" }];
  context.subscriptions.push(import_coc5.languages.registerCodeActionProvider(documentSelector, new RemoveUnusedImportsCodeActionProvider(), "intelephense"));
}
var RemoveUnusedImportsCodeActionProvider = class {
  async provideCodeActions(document, range, context) {
    const codeActions = [];
    if (document.languageId !== "php")
      return;
    const doc = import_coc5.workspace.getDocument(document.uri);
    if (this.wholeRange(doc, range) && context.diagnostics.length > 0) {
      if (!this.isContainTargetCodeInDiagnostics(context.diagnostics, 1003))
        return codeActions;
      const ast = getAst2(doc.getDocumentContent());
      if (!ast)
        return codeActions;
      const featureItems = [];
      const useNodes = getUseNodes(ast.children);
      for (const u of useNodes) {
        if (u.loc) {
          if (u.loc.start && u.loc.end) {
            for (const d of context.diagnostics) {
              if (d.code && typeof d.code === "number") {
                if (d.code === 1003) {
                  if (u.loc.start.line <= d.range.start.line + 1 && u.loc.end.line >= d.range.end.line + 1) {
                    const flatUseItems = flattenUseItems(u["items"]);
                    const diagSymbols = [];
                    let diagSymbol;
                    for (const useItem of flatUseItems) {
                      if (flatUseItems.length === 1 && d.range.start.line === u.loc.start.line - 1 && d.range.start.character === u.loc.start.column && d.range.end.line === u.loc.end.line - 1 && d.range.end.character === u.loc.end.column + 1) {
                        diagSymbol = useItem.name;
                      } else if (d.range.start.line === useItem.locStartLine - 1 && d.range.start.character === useItem.locStartColumn && d.range.end.line === useItem.locEndLine - 1 && d.range.end.character === useItem.locEndColumn) {
                        diagSymbol = useItem.name;
                      }
                    }
                    if (diagSymbol) {
                      diagSymbols.push(diagSymbol);
                    }
                    const item = {
                      name: u.name,
                      type: u.type,
                      rangeStartLine: d.range.start.line,
                      rangeStartCharacter: d.range.start.character,
                      rangeEndLine: d.range.end.line,
                      rangeEndCharacter: d.range.end.character,
                      locStartLine: u.loc.start.line,
                      locStartColumn: u.loc.start.column,
                      locEndLine: u.loc.end.line,
                      locEndColumn: u.loc.end.column,
                      items: flatUseItems,
                      diagSymbols
                    };
                    let existsSameLocItem = false;
                    featureItems.forEach((f) => {
                      if (f.locStartLine === item.locStartLine && f.locStartColumn === item.locStartColumn && f.locEndLine === item.locEndLine && f.locEndColumn === item.locEndColumn) {
                        existsSameLocItem = true;
                        if (diagSymbol)
                          f.diagSymbols.push(diagSymbol);
                      }
                    });
                    if (!existsSameLocItem) {
                      featureItems.push(item);
                    }
                  }
                }
              }
            }
          }
        }
      }
      const edits = [];
      for (const f of featureItems) {
        const edit = this.generateEdit(f, doc);
        if (edit) {
          edits.push(edit);
        }
      }
      if (edits.length > 0) {
        const action = {
          title: `Remove all unused imports for "use" statetment`,
          edit: {
            changes: {
              [doc.uri]: edits
            }
          }
        };
        codeActions.push(action);
      }
    }
    return codeActions;
  }
  isContainTargetCodeInDiagnostics(diagnostics, code) {
    for (const d of diagnostics) {
      if (d.source === "intelephense" && typeof d.code === "number") {
        if (d.code === code) {
          return true;
        }
      }
    }
    return false;
  }
  generateEdit(item, document) {
    let edit;
    if (item.rangeStartLine === 0)
      return;
    if (item.name === null && item.items.length === 1) {
      const prevStartLine = item.rangeStartLine - 1;
      const prevStartLineContent = document.getline(prevStartLine);
      const prevStartEndColumn = prevStartLineContent.length;
      edit = import_coc5.TextEdit.del(import_coc5.Range.create(import_coc5.Position.create(prevStartLine, prevStartEndColumn), import_coc5.Position.create(item.rangeEndLine, item.rangeEndCharacter)));
    } else if (item.name !== null && item.items.length === item.diagSymbols.length || item.name === null && item.items.length > 1 && item.items.length === item.diagSymbols.length) {
      const prevStartLine = item.locStartLine - 2;
      const prevStartLineContent = document.getline(prevStartLine);
      const prevStartEndColumn = prevStartLineContent.length;
      const endLine = item.locEndLine - 1;
      const endColmun = document.getline(endLine).length;
      edit = import_coc5.TextEdit.del(import_coc5.Range.create(import_coc5.Position.create(prevStartLine, prevStartEndColumn), import_coc5.Position.create(endLine, endColmun)));
    } else if (item.name === null && item.items.length > 1 && item.items.length !== item.diagSymbols.length) {
      const symbols = [];
      item.items.forEach((i) => {
        if (!item.diagSymbols.includes(i.name)) {
          if (i.aliasName) {
            symbols.push(`${i.name} as ${i.aliasName}`);
          } else {
            symbols.push(i.name);
          }
        }
      });
      const newTexts = [];
      if (item.type) {
        newTexts.push(`use ${item.type} ${symbols.join(", ")};`);
      } else {
        newTexts.push(`use ${symbols.join(", ")};`);
      }
      const startLine = item.locStartLine - 1;
      const startColumn = item.locStartColumn;
      const endLine = item.locEndLine - 1;
      const endColmun = document.getline(endLine).length;
      edit = import_coc5.TextEdit.replace(import_coc5.Range.create(import_coc5.Position.create(startLine, startColumn), import_coc5.Position.create(endLine, endColmun)), newTexts.join(""));
    } else if (item.name !== null && item.diagSymbols.length > 0 && item.items.length !== item.diagSymbols.length) {
      const symbols = [];
      item.items.forEach((i) => {
        if (!item.diagSymbols.includes(i.name)) {
          if (i.aliasName) {
            symbols.push(`${i.name} as ${i.aliasName}`);
          } else {
            symbols.push(i.name);
          }
        }
      });
      const newTexts = [];
      if (symbols.length === 1) {
        if (item.type) {
          newTexts.push(`use ${item.type} ${item.name}\\${symbols[0]};`);
        } else {
          newTexts.push(`use ${item.name}\\${symbols[0]};`);
        }
      } else {
        if (item.type) {
          newTexts.push(`use ${item.type} ${item.name}\\{${symbols.join(", ")}};`);
        } else {
          newTexts.push(`use ${item.name}\\{${symbols.join(", ")}};`);
        }
      }
      const startLine = item.locStartLine - 1;
      const startColumn = item.locStartColumn;
      const endLine = item.locEndLine - 1;
      const endColmun = document.getline(endLine).length;
      edit = import_coc5.TextEdit.replace(import_coc5.Range.create(import_coc5.Position.create(startLine, startColumn), import_coc5.Position.create(endLine, endColmun)), newTexts.join(""));
    }
    return edit;
  }
  wholeRange(doc, range) {
    const whole = import_coc5.Range.create(0, 0, doc.lineCount, 0);
    return whole.start.line === range.start.line && whole.start.character === range.start.character && whole.end.line === range.end.line && whole.end.character === whole.end.character;
  }
};

// src/commands/completeConstructor.ts
var import_coc6 = require("coc.nvim");

// src/parsers/completeConstructor.ts
var import_php_parser3 = __toESM(require_src());
var parserEngine3 = new import_php_parser3.Engine({
  parser: {
    extractDoc: true,
    php7: true,
    locations: true,
    suppressErrors: true
  },
  ast: {
    all_tokens: true,
    withPositions: true
  }
});
function getAst3(code) {
  try {
    return parserEngine3.parseEval(stripPHPTag(code));
  } catch (e) {
    return void 0;
  }
  function stripPHPTag(code2) {
    return code2.replace("<?php", "").replace("?>", "");
  }
}
function getClassesNodes2(nodes) {
  const classNodes = [];
  for (const node of nodes) {
    if (node.kind === "namespace") {
      const namespaceNode = node;
      return getClassesNodes2(namespaceNode.children);
    }
    if (node.kind === "class") {
      const classNode = node;
      classNodes.push(classNode);
    }
  }
  return classNodes;
}
function getPropertiesWithClassDetail2(nodes) {
  const propertiesWithClassDetail = [];
  const classNodes = getClassesNodes2(nodes);
  classNodes.forEach((classNode) => {
    const identiferNode = classNode.name;
    const className = identiferNode.name;
    const classStartLine = classNode.loc ? classNode.loc.start.line : 0;
    const classEndLine = classNode.loc ? classNode.loc.end.line : 0;
    classNode.body.forEach((declaration) => {
      const propertiesDetails = getProperties2(declaration);
      if (propertiesDetails) {
        propertiesDetails.forEach((p) => {
          propertiesWithClassDetail.push(__spreadValues({
            className,
            classStartLine,
            classEndLine
          }, p));
        });
      }
    });
  });
  return propertiesWithClassDetail;
}
function getProperties2(node) {
  const propertiesDetail = [];
  if (node.kind !== "propertystatement")
    return propertiesDetail;
  const propertyStatementNode = node;
  const parentNode = node;
  propertyStatementNode.properties.forEach((node2) => {
    if (node2.kind === "property") {
      const propertyNode = node2;
      const identifiierNode = propertyNode.name;
      const name = identifiierNode.name;
      const nullable = propertyNode.nullable;
      const startLine = propertyNode.loc ? propertyNode.loc.start.line : 0;
      const endLine = propertyNode.loc ? propertyNode.loc.end.line : 0;
      let type = null;
      let docVarType = null;
      const comments = [];
      if (propertyNode.type) {
        if (Array.isArray(propertyNode.type)) {
        } else {
          if (propertyNode.type.kind === "typereference") {
            const typereferenceNode = propertyNode.type;
            type = typereferenceNode.name;
          } else if (propertyNode.type.kind === "name") {
            const nameNode = propertyNode.type;
            type = nameNode.name;
          } else if (propertyNode.type.kind === "uniontype") {
            if ("types" in propertyNode.type) {
              const uniontypeTypesNode = propertyNode.type["types"];
              const items = [];
              uniontypeTypesNode.forEach((node3) => {
                items.push(node3.name);
              });
              type = items;
            }
          }
        }
      }
      if (parentNode.leadingComments) {
        const leadingComments = parentNode["leadingComments"];
        leadingComments.forEach((c) => {
          if (c.kind === "commentblock") {
            const commentNode = c;
            comments.push(commentNode.value);
          }
        });
        comments.forEach((comment) => {
          const splitComments = comment.split("\n");
          splitComments.forEach((c) => {
            const matchTypeDetail = matchTypeDetailFromVarTag(c, name);
            if (matchTypeDetail) {
              docVarType = matchTypeDetail == null ? void 0 : matchTypeDetail.value;
            }
          });
        });
      }
      const propertyDetail = {
        propertyName: name,
        propertyNullable: nullable,
        propertyType: type,
        propertyStartLine: startLine,
        propertyEndLine: endLine,
        propertyDocVarType: docVarType
      };
      propertiesDetail.push(propertyDetail);
    }
  });
  return propertiesDetail;
}
function getConstructorMethodNodeFromClassNode(classNode) {
  for (const declaration of classNode.body) {
    if (declaration.kind === "method") {
      const methodNode = declaration;
      const identifer = methodNode.name;
      if (identifer.name === "__construct") {
        return methodNode;
      }
    }
  }
}
function getConstructorPropertiesFromMethodNode(methodNode) {
  const propertiesDetails = [];
  if (methodNode.kind !== "method")
    return [];
  const identifer = methodNode.name;
  if (identifer.name !== "__construct")
    return;
  methodNode.arguments.forEach((parameter) => {
    if ("flags" in parameter) {
      const identifiierNode = parameter.name;
      const name = identifiierNode.name;
      const nullable = parameter.nullable;
      const startLine = parameter.loc ? parameter.loc.start.line : 0;
      const endLine = parameter.loc ? parameter.loc.end.line : 0;
      let type = null;
      if (parameter.type) {
        if (Array.isArray(parameter.type)) {
        } else {
          if (parameter.type.kind === "typereference") {
            const typereferenceNode = parameter.type;
            type = typereferenceNode.name;
          } else if (parameter.type.kind === "name") {
            const nameNode = parameter.type;
            type = nameNode.name;
          } else if (parameter.type.kind === "uniontype") {
            if ("types" in parameter.type) {
              const uniontypeTypesNode = parameter.type["types"];
              const items = [];
              uniontypeTypesNode.forEach((node) => {
                items.push(node.name);
              });
              type = items;
            }
          }
        }
      }
      const propertyDetail = {
        propertyName: name,
        propertyNullable: nullable,
        propertyStartLine: startLine,
        propertyEndLine: endLine,
        propertyType: type,
        propertyFlags: parameter["flags"],
        propertyDocVarType: null
      };
      propertiesDetails.push(propertyDetail);
    }
  });
  return propertiesDetails;
}

// src/commands/completeConstructor.ts
var COMPLETE_CONSTRUCTOR_INDENT_SPACE = 4;
function activate6(context) {
  context.subscriptions.push(import_coc6.commands.registerCommand("intelephense.completeConstructor", runCompleteConstructor()));
}
function runCompleteConstructor() {
  return async () => {
    const { document } = await import_coc6.workspace.getCurrentState();
    const doc = await import_coc6.workspace.openTextDocument(import_coc6.Uri.parse(document.uri).fsPath);
    const ast = getAst3(document.getText());
    if (!ast)
      return;
    const classNodes = getClassesNodes2(ast.children);
    if (!classNodes.length || classNodes.length > 1) {
      import_coc6.window.showErrorMessage("Class not found or there are multiple classes");
      return;
    }
    const constructor = getConstructorMethodNodeFromClassNode(classNodes[0]);
    if (!constructor)
      return;
    if (!constructor.loc)
      return;
    if (!constructor.body)
      return;
    if (!constructor.body.loc)
      return;
    const constructorPropertiesItems = getConstructorPropertiesFromMethodNode(constructor);
    if (!constructorPropertiesItems)
      return;
    const indentSpace = " ".repeat(COMPLETE_CONSTRUCTOR_INDENT_SPACE);
    const newPropContents = [];
    const newBodyContents = [];
    const properties = getPropertiesWithClassDetail2(classNodes);
    const propertyNames = properties.map((p) => p.propertyName);
    const constructorBodyContents = document.getText(import_coc6.Range.create(import_coc6.Position.create(constructor.body.loc.start.line - 1, constructor.body.loc.start.column), import_coc6.Position.create(constructor.body.loc.end.line - 1, constructor.body.loc.end.column)));
    const constructorBodyLines = constructorBodyContents.split("\n");
    constructorPropertiesItems.forEach((cp3) => {
      if (cp3.propertyFlags === 0) {
        if (!propertyNames.includes(cp3.propertyName)) {
          newPropContents.push(`private`);
          if (cp3.propertyType) {
            newPropContents.push(` ${cp3.propertyNullable ? "?" : ""}${cp3.propertyType} `);
          } else {
            newPropContents.push(` `);
          }
          newPropContents.push(`$${cp3.propertyName};`);
          newPropContents.push(`

${indentSpace}`);
        }
        let existsLine = false;
        for (const line of constructorBodyLines) {
          const trimLine = line.trim();
          if (trimLine.startsWith("#") || trimLine.startsWith("//"))
            continue;
          const pattern = `\\$this->${cp3.propertyName}\\s+=\\s+\\$${cp3.propertyName};`;
          const regex = new RegExp(pattern);
          if (regex.test(trimLine))
            existsLine = true;
        }
        if (!existsLine) {
          newBodyContents.push(`
${indentSpace}${indentSpace}$this->${cp3.propertyName} = $${cp3.propertyName};`);
        }
      }
    });
    const edits = [];
    if (newPropContents) {
      edits.push(import_coc6.TextEdit.insert(import_coc6.Position.create(constructor.loc.start.line - 1, constructor.loc.start.column), newPropContents.join("")));
    }
    if (newBodyContents) {
      edits.push(import_coc6.TextEdit.insert(import_coc6.Position.create(constructor.body.loc.start.line - 1, constructor.body.loc.start.column + 1), newBodyContents.join("")));
    }
    if (edits) {
      await doc.applyEdits(edits);
    }
  };
}

// src/commands/composer.ts
var import_coc7 = require("coc.nvim");
var import_child_process = __toESM(require("child_process"));
var import_fs = __toESM(require("fs"));
var import_path = __toESM(require("path"));
var terminal;
function activate7(context) {
  context.subscriptions.push(import_coc7.commands.registerCommand("intelephense.composer.runCommand", runComposerCommandCommand()), import_coc7.commands.registerCommand("intelephense.composer.runCommandPlus", runComposerCommandPlusCommand()), import_coc7.commands.registerCommand("intelephense.composer.runScriptsCommand", runComposerScriptsCommand()));
}
async function getComposerPath() {
  let cmdPath = "";
  const composerPath = import_coc7.workspace.getConfiguration("intelephense").get("composer.path", "composer");
  if (await existsComposer(composerPath)) {
    cmdPath = composerPath;
  }
  return cmdPath;
}
async function existsComposer(composerPath) {
  return new Promise((resolve) => {
    import_child_process.default.exec(`${composerPath} --version`, (err, stdout, stderr) => {
      if (stdout.length > 0) {
        resolve(true);
      } else {
        resolve(false);
      }
    });
  });
}
function existsComposerJson() {
  let exists = false;
  const composerJsonPath = import_path.default.join(import_coc7.workspace.root, "composer.json");
  if (import_fs.default.existsSync(composerJsonPath)) {
    exists = true;
  }
  return exists;
}
async function runComposer(composerPath, args) {
  if (!composerPath) {
    import_coc7.window.showErrorMessage(`composer command not found!`);
    return;
  }
  if (terminal) {
    if (terminal.bufnr) {
      await import_coc7.workspace.nvim.command(`bd! ${terminal.bufnr}`);
    }
    terminal.dispose();
    terminal = void 0;
  }
  terminal = await import_coc7.window.createTerminal({ name: "composer", cwd: import_coc7.workspace.root });
  terminal.sendText(`${composerPath} ${args.join(" ")}`);
  const enableSplitRight = import_coc7.workspace.getConfiguration("intelephense").get("composer.enableSplitRight", false);
  if (enableSplitRight)
    terminal.hide();
  await import_coc7.workspace.nvim.command("stopinsert");
  if (enableSplitRight) {
    await import_coc7.workspace.nvim.command(`vert bel sb ${terminal.bufnr}`);
    await import_coc7.workspace.nvim.command(`wincmd p`);
  }
}
function runComposerCommandCommand() {
  return async () => {
    const composerPath = await getComposerPath();
    const args = [];
    const runCommandList = import_coc7.workspace.getConfiguration("intelephense").get("composer.runCommandList", []);
    if (runCommandList.length === 0) {
      import_coc7.window.showErrorMessage(`runCommandList is empty`);
      return;
    }
    const choiceNumber = await import_coc7.window.showQuickpick(runCommandList);
    if (choiceNumber !== -1) {
      args.push(runCommandList[choiceNumber]);
      runComposer(composerPath, args);
    }
  };
}
function runComposerCommandPlusCommand() {
  return async () => {
    const composerPath = await getComposerPath();
    const args = [];
    const runCommandPlusList = import_coc7.workspace.getConfiguration("intelephense").get("composer.runCommandPlusList", []);
    if (runCommandPlusList.length === 0) {
      import_coc7.window.showErrorMessage(`runCommandPlusList is empty`);
      return;
    }
    const choiceNumber = await import_coc7.window.showQuickpick(runCommandPlusList);
    if (choiceNumber !== -1) {
      const input = await import_coc7.window.requestInput(`composer ${runCommandPlusList[choiceNumber]}`);
      if (input) {
        args.push(runCommandPlusList[choiceNumber]);
        args.push(input);
        runComposer(composerPath, args);
      }
    }
  };
}
function runComposerScriptsCommand() {
  return async () => {
    const composerPath = await getComposerPath();
    const args = [];
    if (!existsComposerJson()) {
      import_coc7.window.showErrorMessage(`composer.json not found!`);
      return;
    }
    const composerJson = JSON.parse(import_fs.default.readFileSync(import_path.default.join(import_coc7.workspace.root, "composer.json"), "utf8"));
    const scriptsList = [];
    Object.keys(composerJson).map((key) => {
      if (key === "scripts") {
        const scriptsObj = composerJson[key];
        Object.keys(scriptsObj).map((key2) => {
          if (!key2.startsWith("pre-") && !key2.startsWith("post-")) {
            scriptsList.push(key2);
          }
        });
      }
    });
    if (scriptsList.length >= 1) {
      const choiceNumber = await import_coc7.window.showQuickpick(scriptsList);
      if (choiceNumber !== -1) {
        args.push("run-script");
        args.push(scriptsList[choiceNumber]);
        runComposer(composerPath, args);
      }
    } else {
      import_coc7.window.showWarningMessage(`scripts not found. events (pre-, post-) are excluded by default`);
      return;
    }
  };
}

// src/commands/fixClassName.ts
var import_coc8 = require("coc.nvim");
var import_path2 = __toESM(require("path"));

// src/parsers/fixClassName.ts
var import_php_parser4 = __toESM(require_src());
var parserEngine4 = new import_php_parser4.Engine({
  parser: {
    extractDoc: true,
    php7: true,
    locations: true,
    suppressErrors: true
  },
  ast: {
    all_tokens: true,
    withPositions: true
  }
});
function getAst4(code) {
  try {
    return parserEngine4.parseEval(stripPHPTag(code));
  } catch (e) {
    return void 0;
  }
  function stripPHPTag(code2) {
    return code2.replace("<?php", "").replace("?>", "");
  }
}
function getClassesNodes3(nodes) {
  const classNodes = [];
  for (const node of nodes) {
    if (node.kind === "namespace") {
      const namespaceNode = node;
      return getClassesNodes3(namespaceNode.children);
    }
    if (node.kind === "class") {
      const classNode = node;
      classNodes.push(classNode);
    }
  }
  return classNodes;
}
function getClassNameIdentifer(classNode) {
  if (classNode.kind !== "class")
    return;
  return classNode.name;
}

// src/commands/fixClassName.ts
function activate8(context) {
  context.subscriptions.push(import_coc8.commands.registerCommand("intelephense.fixClassName", runFixClassName()));
}
function runFixClassName() {
  return async () => {
    const { document } = await import_coc8.workspace.getCurrentState();
    const classNameByFilePath = import_path2.default.basename(import_coc8.Uri.parse(document.uri).fsPath, ".php");
    const ast = getAst4(document.getText());
    if (!ast)
      return;
    const classNodes = getClassesNodes3(ast.children);
    if (!classNodes.length || classNodes.length > 1) {
      import_coc8.window.showErrorMessage("Class not found or there are multiple classes");
      return;
    }
    const classNameIdentifier = getClassNameIdentifer(classNodes[0]);
    if (!classNameIdentifier) {
      import_coc8.window.showErrorMessage("Failed to parse class");
      return;
    }
    if (!classNameIdentifier.loc) {
      import_coc8.window.showErrorMessage("No location in class name");
      return;
    }
    const doc = await import_coc8.workspace.openTextDocument(import_coc8.Uri.parse(document.uri).fsPath);
    const edits = [
      import_coc8.TextEdit.replace(import_coc8.Range.create(import_coc8.Position.create(classNameIdentifier.loc.start.line - 1, classNameIdentifier.loc.start.column), import_coc8.Position.create(classNameIdentifier.loc.end.line - 1, classNameIdentifier.loc.end.column)), classNameByFilePath)
    ];
    await doc.applyEdits(edits);
  };
}

// src/commands/fixNamespace.ts
var import_coc9 = require("coc.nvim");

// src/parsers/fixNamespace.ts
var import_php_parser5 = __toESM(require_src());
var parserEngine5 = new import_php_parser5.Engine({
  parser: {
    extractDoc: true,
    php7: true,
    locations: true,
    suppressErrors: true
  },
  ast: {
    all_tokens: true,
    withPositions: true
  }
});
function getAst5(code) {
  try {
    return parserEngine5.parseEval(stripPHPTag(code));
  } catch (e) {
    return void 0;
  }
  function stripPHPTag(code2) {
    return code2.replace("<?php", "").replace("?>", "");
  }
}
function getNamespaceNode(nodes) {
  for (const node of nodes) {
    if (node.kind === "namespace") {
      const namespaceNode = node;
      return namespaceNode;
    }
  }
}
function getNamespaceLocation(namespace) {
  if (namespace.kind !== "namespace")
    return;
  if (namespace.loc) {
    return namespace.loc;
  }
}

// src/commands/fixNamespace.ts
var import_fs2 = __toESM(require("fs"));
var import_path3 = __toESM(require("path"));
function activate9(context) {
  context.subscriptions.push(import_coc9.commands.registerCommand("intelephense.fixNamespace", runFixNamespace()));
}
function runFixNamespace() {
  return async () => {
    const { document } = await import_coc9.workspace.getCurrentState();
    const composerJsonPath = import_path3.default.join(import_coc9.workspace.root, "composer.json");
    let composerJsonContent = null;
    try {
      composerJsonContent = JSON.parse(import_fs2.default.readFileSync(composerJsonPath, "utf8"));
    } catch (error) {
      composerJsonContent = null;
    }
    if (!composerJsonContent) {
      import_coc9.window.showErrorMessage(`composer.json could not be loaded`);
      return;
    }
    const projectNamespaces = getProjectNamespacesFromComposerJson(composerJsonContent);
    const workspaceUriPath = import_coc9.Uri.parse(import_coc9.workspace.root).toString();
    const fileUriPath = document.uri;
    const relativeFilePath = fileUriPath.replace(workspaceUriPath + "/", "");
    const newNamespace = getFileNamespace(projectNamespaces, relativeFilePath);
    if (!newNamespace) {
      import_coc9.window.showErrorMessage("Cannot find namespace to use for target file");
      return;
    }
    const ast = getAst5(document.getText());
    if (!ast)
      return;
    const currentFileNsNode = getNamespaceNode(ast.children);
    if (!currentFileNsNode) {
      import_coc9.window.showErrorMessage("namespace not found in target file");
      return;
    }
    const currentFileNsLoc = getNamespaceLocation(currentFileNsNode);
    if (!currentFileNsLoc) {
      import_coc9.window.showErrorMessage("Failed to parse namespace in target file");
      return;
    }
    const doc = await import_coc9.workspace.openTextDocument(import_coc9.Uri.parse(document.uri).fsPath);
    const declarationContent = doc.getline(currentFileNsLoc.start.line - 1);
    const declarationColumn = declarationContent.length;
    const edits = [
      import_coc9.TextEdit.replace(import_coc9.Range.create(import_coc9.Position.create(currentFileNsLoc.start.line - 1, currentFileNsLoc.start.column), import_coc9.Position.create(currentFileNsLoc.start.line - 1, declarationColumn)), `namespace ${newNamespace};`)
    ];
    await doc.applyEdits(edits);
  };
}
function getProjectNamespacesFromComposerJson(composerJsonContent) {
  const projectNamespaces = [];
  if (composerJsonContent.autoload) {
    if ("psr-4" in composerJsonContent.autoload) {
      for (const [k, v] of Object.entries(composerJsonContent.autoload["psr-4"])) {
        projectNamespaces.push({
          [k]: v
        });
      }
    }
  }
  if (composerJsonContent["autoload-dev"]) {
    if ("psr-4" in composerJsonContent["autoload-dev"]) {
      for (const [k, v] of Object.entries(composerJsonContent["autoload-dev"]["psr-4"])) {
        projectNamespaces.push({
          [k]: v
        });
      }
    }
  }
  return projectNamespaces;
}
function getFileNamespace(namespaces, relativeFilePath) {
  const fileName = relativeFilePath.split("/").slice(-1)[0];
  for (const namespace of namespaces) {
    for (const k of Object.keys(namespace)) {
      if (relativeFilePath.startsWith(namespace[k])) {
        const fileNamespace = relativeFilePath.replace(namespace[k], k).replace(/\//g, "\\").replace(fileName, "").replace(/\\$/, "");
        return fileNamespace;
      }
    }
  }
}

// src/commands/pest.ts
var import_coc10 = require("coc.nvim");
var import_path4 = __toESM(require("path"));
var import_fs3 = __toESM(require("fs"));

// src/parsers/pest.ts
var import_php_parser6 = __toESM(require_src());
var parserEngine6 = new import_php_parser6.Engine({
  parser: {
    extractDoc: true,
    php7: true,
    locations: true,
    suppressErrors: true
  },
  ast: {
    all_tokens: true,
    withPositions: true
  }
});
function getAst6(code) {
  try {
    return parserEngine6.parseEval(stripPHPTag(code));
  } catch (e) {
    return void 0;
  }
  function stripPHPTag(code2) {
    return code2.replace("<?php", "").replace("?>", "");
  }
}
async function getMethods2(nodes) {
  const methodDetails = [];
  nodes.forEach((node) => {
    if ("children" in node) {
      const subNode = node["children"];
      subNode.forEach((node2) => {
        if (node2.kind === "class") {
          if ("body" in node2) {
            const subNode2 = node2["body"];
            subNode2.forEach((node3) => {
              const methodDetail = getMethodDetailFromNode(node3);
              if (methodDetail) {
                methodDetails.push(methodDetail);
              }
            });
          }
        }
      });
    } else if (node.kind === "class") {
      if ("body" in node) {
        const subNode = node["body"];
        subNode.forEach((node2) => {
          const methodDetail = getMethodDetailFromNode(node2);
          if (methodDetail) {
            methodDetails.push(methodDetail);
          }
        });
      }
    }
  });
  return methodDetails;
}
function getMethodDetailFromNode(node) {
  if (node.kind === "method") {
    if ("loc" in node) {
      const name = node["name"]["name"];
      const startLine = node["loc"] ? node["loc"]["start"]["line"] : 0;
      const endLine = node["loc"] ? node["loc"]["end"]["line"] : 0;
      const comments = [];
      if ("leadingComments" in node) {
        const leadingComments = node["leadingComments"];
        leadingComments.forEach((n) => {
          comments.push(n.value);
        });
      }
      const methodDetail = {
        name,
        startLine,
        endLine,
        comments
      };
      return methodDetail;
    }
  }
}
function getTestMethods(methods) {
  const testMethods = [];
  methods.forEach((m) => {
    let exists = false;
    if (m.name) {
      if (m.name.startsWith("test")) {
        exists = true;
      }
    }
    if (m.comments) {
      m.comments.forEach((c) => {
        if (c.includes("@test")) {
          exists = true;
        }
      });
    }
    if (exists) {
      testMethods.push(m);
    }
  });
  return testMethods;
}
function getTestName(methods, position) {
  let testName = "";
  methods.forEach((m) => {
    if (position.line + 1 >= m.startLine && position.line + 1 <= m.endLine) {
      const name = m.name;
      let isTestAnotation = false;
      if (m.comments) {
        m.comments.forEach((c) => {
          if (c.includes("@test")) {
            isTestAnotation = true;
          }
        });
      }
      if (name.startsWith("test") || isTestAnotation) {
        testName = name;
      }
    }
  });
  return testName;
}
async function getPestTestDetail(nodes) {
  const pestTestDetails = [];
  try {
    nodes.forEach((node) => {
      if (node.kind === "namespace") {
        const subNode = node["children"];
        subNode.forEach((node2) => {
          if (node2.kind === "expressionstatement") {
            if ("expression" in node2) {
              const expression = node2["expression"];
              if (expression.kind === "call") {
                const call = expression;
                if ("loc" in call && call.arguments) {
                  if (call.what.kind === "name") {
                    if (call.what.name === "test" || call.what.name === "it") {
                      const startLine = call.loc ? call.loc.start.line : 0;
                      const endLine = call.loc ? call.loc.end.line : 0;
                      let name = "";
                      name = call.arguments[0].kind === "string" ? call.arguments[0]["value"] : "";
                      name = call.what.name === "it" ? "it " + name : name;
                      pestTestDetails.push({
                        name,
                        startLine,
                        endLine
                      });
                    }
                  } else if (call.what.kind === "propertylookup") {
                    if (call.what["what"]["what"]["what"]) {
                      if (call.what["what"]["what"]["what"]["kind"] === "call") {
                        const subCall = call.what["what"]["what"]["what"];
                        if (subCall.what.name === "test" || subCall.what.name === "it") {
                          const startLine = call.loc ? call.loc.start.line : 0;
                          const endLine = call.loc ? call.loc.end.line : 0;
                          let name = "";
                          name = subCall.arguments[0].kind === "string" ? subCall.arguments[0]["value"] : "";
                          name = subCall.what.name === "it" ? "it " + name : name;
                          pestTestDetails.push({
                            name,
                            startLine,
                            endLine
                          });
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        });
      } else if (node.kind === "expressionstatement") {
        if ("expression" in node) {
          const expression = node["expression"];
          if (expression.kind === "call") {
            const call = expression;
            if ("loc" in call && call.arguments) {
              if (call.what.kind === "name") {
                if (call.what.name === "test" || call.what.name === "it") {
                  const startLine = call.loc ? call.loc.start.line : 0;
                  const endLine = call.loc ? call.loc.end.line : 0;
                  let name = "";
                  name = call.arguments[0].kind === "string" ? call.arguments[0]["value"] : "";
                  name = call.what.name === "it" ? "it " + name : name;
                  pestTestDetails.push({
                    name,
                    startLine,
                    endLine
                  });
                }
              } else if (call.what.kind === "propertylookup") {
                if (call.what["what"]["what"]["what"]) {
                  if (call.what["what"]["what"]["what"]["kind"] === "call") {
                    const subCall = call.what["what"]["what"]["what"];
                    if (subCall.what.name === "test" || subCall.what.name === "it") {
                      const startLine = call.loc ? call.loc.start.line : 0;
                      const endLine = call.loc ? call.loc.end.line : 0;
                      let name = "";
                      name = subCall.arguments[0].kind === "string" ? subCall.arguments[0]["value"] : "";
                      name = subCall.what.name === "it" ? "it " + name : name;
                      pestTestDetails.push({
                        name,
                        startLine,
                        endLine
                      });
                    }
                  }
                }
              }
            }
          }
        }
      }
    });
  } catch (e) {
  }
  return pestTestDetails;
}
function getTestNameFromPestTestDetails(pestTestDetails, position) {
  let testName = "";
  pestTestDetails.forEach((m) => {
    if (position.line + 1 >= m.startLine && position.line + 1 <= m.endLine) {
      const name = m.name;
      testName = name;
    }
  });
  return testName;
}

// src/commands/pest.ts
var terminal2;
function activate10(context) {
  context.subscriptions.push(import_coc10.commands.registerCommand("intelephense.pest.projectTest", pestProjectTestCommand()), import_coc10.commands.registerCommand("intelephense.pest.fileTest", pestFileTestCommand()), import_coc10.commands.registerCommand("intelephense.pest.singleTest", pestSingleTestCommand()));
}
function getPestPath() {
  let cmdPath = "";
  const pestPath = import_coc10.workspace.getConfiguration("intelephense").get("pest.path");
  const vendorPestPath = import_path4.default.join(import_coc10.workspace.root, "vendor", "bin", "pest");
  if (pestPath && import_fs3.default.existsSync(pestPath)) {
    cmdPath = pestPath;
  } else if (import_fs3.default.existsSync(vendorPestPath)) {
    cmdPath = import_path4.default.join(import_coc10.workspace.root, "vendor", "bin", "pest");
  }
  return cmdPath;
}
async function runPest(filePath, testName) {
  const pestBin = getPestPath();
  const pestDoNotCacheResult = import_coc10.workspace.getConfiguration("intelephense").get("pest.doNotCacheResult", true);
  if (pestBin) {
    if (terminal2) {
      if (terminal2.bufnr) {
        await import_coc10.workspace.nvim.command(`bd! ${terminal2.bufnr}`);
      }
      terminal2.dispose();
      terminal2 = void 0;
    }
    terminal2 = await import_coc10.window.createTerminal({ name: "pest", cwd: import_coc10.workspace.root });
    const args = [];
    if (pestDoNotCacheResult)
      args.push("--do-not-cache-result");
    if (testName && filePath) {
      args.push("--filter");
      args.push(`'::${testName}$'`);
      args.push(`${filePath}`);
      terminal2.sendText(`${pestBin} ${args.join(" ")}`);
    } else if (filePath) {
      args.push(`${filePath}`);
      terminal2.sendText(`${pestBin} ${args.join(" ")}`);
    } else {
      if (args.length > 0) {
        terminal2.sendText(`${pestBin} ${args.join(" ")}`);
      } else {
        terminal2.sendText(`${pestBin}`);
      }
    }
    const enableSplitRight = import_coc10.workspace.getConfiguration("intelephense").get("pest.enableSplitRight", false);
    if (enableSplitRight)
      terminal2.hide();
    await import_coc10.workspace.nvim.command("stopinsert");
    if (enableSplitRight) {
      await import_coc10.workspace.nvim.command(`vert bel sb ${terminal2.bufnr}`);
      await import_coc10.workspace.nvim.command(`wincmd p`);
    }
  } else {
    return import_coc10.window.showErrorMessage("pest not found!");
  }
}
function pestProjectTestCommand() {
  return async () => {
    const { document } = await import_coc10.workspace.getCurrentState();
    const filePath = import_coc10.Uri.parse(document.uri).fsPath;
    if (document.languageId !== "php" || !filePath.endsWith("Test.php")) {
      return import_coc10.window.showErrorMessage("This file is not a PHP test file!");
    }
    runPest();
  };
}
function pestFileTestCommand() {
  return async () => {
    const { document } = await import_coc10.workspace.getCurrentState();
    const filePath = import_coc10.Uri.parse(document.uri).fsPath;
    if (document.languageId !== "php" || !filePath.endsWith("Test.php")) {
      return import_coc10.window.showErrorMessage("This file is not a PHP test file!");
    }
    runPest(filePath);
  };
}
function pestSingleTestCommand() {
  return async () => {
    const { document, position } = await import_coc10.workspace.getCurrentState();
    const filePath = import_coc10.Uri.parse(document.uri).fsPath;
    if (document.languageId !== "php" || !filePath.endsWith("Test.php")) {
      return import_coc10.window.showErrorMessage("This file is not a PHP test file!");
    }
    const ast = getAst6(document.getText());
    if (!ast)
      return;
    let testName = "";
    const pestTestDetails = await getPestTestDetail(ast.children);
    const pestTestName = getTestNameFromPestTestDetails(pestTestDetails, position);
    if (pestTestName) {
      testName = pestTestName;
    } else {
      const methods = await getMethods2(ast.children);
      const methodTestName = getTestName(methods, position);
      if (methodTestName)
        testName = methodTestName;
    }
    if (testName) {
      runPest(filePath, testName);
    } else {
      import_coc10.window.showErrorMessage(`Test not found`);
    }
  };
}

// src/commands/phpunit.ts
var import_coc11 = require("coc.nvim");
var import_path5 = __toESM(require("path"));
var import_fs4 = __toESM(require("fs"));

// src/parsers/phpunit.ts
var import_php_parser7 = __toESM(require_src());
var parserEngine7 = new import_php_parser7.Engine({
  parser: {
    extractDoc: true,
    php7: true,
    locations: true,
    suppressErrors: true
  },
  ast: {
    all_tokens: true,
    withPositions: true
  }
});
function getAst7(code) {
  try {
    return parserEngine7.parseEval(stripPHPTag(code));
  } catch (e) {
    return void 0;
  }
  function stripPHPTag(code2) {
    return code2.replace("<?php", "").replace("?>", "");
  }
}
async function getMethods3(nodes) {
  const methodDetails = [];
  nodes.forEach((node) => {
    if ("children" in node) {
      const subNode = node["children"];
      subNode.forEach((node2) => {
        if (node2.kind === "class") {
          if ("body" in node2) {
            const subNode2 = node2["body"];
            subNode2.forEach((node3) => {
              const methodDetail = getMethodDetailFromNode2(node3);
              if (methodDetail) {
                methodDetails.push(methodDetail);
              }
            });
          }
        }
      });
    } else if (node.kind === "class") {
      if ("body" in node) {
        const subNode = node["body"];
        subNode.forEach((node2) => {
          const methodDetail = getMethodDetailFromNode2(node2);
          if (methodDetail) {
            methodDetails.push(methodDetail);
          }
        });
      }
    }
  });
  return methodDetails;
}
function getMethodDetailFromNode2(node) {
  if (node.kind === "method") {
    if ("loc" in node) {
      const name = node["name"]["name"];
      const startLine = node["loc"] ? node["loc"]["start"]["line"] : 0;
      const endLine = node["loc"] ? node["loc"]["end"]["line"] : 0;
      const comments = [];
      if ("leadingComments" in node) {
        const leadingComments = node["leadingComments"];
        leadingComments.forEach((n) => {
          comments.push(n.value);
        });
      }
      const methodDetail = {
        name,
        startLine,
        endLine,
        comments
      };
      return methodDetail;
    }
  }
}
function getTestMethods2(methods) {
  const testMethods = [];
  methods.forEach((m) => {
    let exists = false;
    if (m.name) {
      if (m.name.startsWith("test")) {
        exists = true;
      }
    }
    if (m.comments) {
      m.comments.forEach((c) => {
        if (c.includes("@test")) {
          exists = true;
        }
      });
    }
    if (exists) {
      testMethods.push(m);
    }
  });
  return testMethods;
}
function getTestName2(methods, position) {
  let testName = "";
  methods.forEach((m) => {
    if (position.line + 1 >= m.startLine && position.line + 1 <= m.endLine) {
      const name = m.name;
      let isTestAnotation = false;
      if (m.comments) {
        m.comments.forEach((c) => {
          if (c.includes("@test")) {
            isTestAnotation = true;
          }
        });
      }
      if (name.startsWith("test") || isTestAnotation) {
        testName = name;
      }
    }
  });
  return testName;
}

// src/commands/phpunit.ts
var terminal3;
function activate11(context) {
  context.subscriptions.push(import_coc11.commands.registerCommand("intelephense.phpunit.projectTest", phpunitProjectTestCommand()), import_coc11.commands.registerCommand("intelephense.phpunit.fileTest", phpunitFileTestCommand()), import_coc11.commands.registerCommand("intelephense.phpunit.singleTest", phpunitSingleTestCommand()));
}
function getPhpUnitPath() {
  let cmdPath = "";
  const phpUnitPath = import_coc11.workspace.getConfiguration("intelephense").get("phpunit.path");
  const vendorPhpUnitPath = import_path5.default.join(import_coc11.workspace.root, "vendor", "bin", "phpunit");
  if (phpUnitPath && import_fs4.default.existsSync(phpUnitPath)) {
    cmdPath = phpUnitPath;
  } else if (import_fs4.default.existsSync(vendorPhpUnitPath)) {
    cmdPath = import_path5.default.join(import_coc11.workspace.root, "vendor", "bin", "phpunit");
  }
  return cmdPath;
}
async function runPhpUnit(filePath, testName) {
  const phpunitBin = getPhpUnitPath();
  const phpunitColors = import_coc11.workspace.getConfiguration("intelephense").get("phpunit.colors", false);
  const phpunitDebug = import_coc11.workspace.getConfiguration("intelephense").get("phpunit.debug", false);
  if (phpunitBin) {
    if (terminal3) {
      if (terminal3.bufnr) {
        await import_coc11.workspace.nvim.command(`bd! ${terminal3.bufnr}`);
      }
      terminal3.dispose();
      terminal3 = void 0;
    }
    terminal3 = await import_coc11.window.createTerminal({ name: "phpunit", cwd: import_coc11.workspace.root });
    const args = [];
    if (phpunitColors)
      args.push("--colors");
    if (phpunitDebug)
      args.push("--debug");
    if (testName && filePath) {
      args.push("--filter");
      args.push(`'::${testName}$'`);
      args.push(`${filePath}`);
      terminal3.sendText(`${phpunitBin} ${args.join(" ")}`);
    } else if (filePath) {
      args.push(`${filePath}`);
      terminal3.sendText(`${phpunitBin} ${args.join(" ")}`);
    } else {
      terminal3.sendText(`${phpunitBin}`);
    }
    const enableSplitRight = import_coc11.workspace.getConfiguration("intelephense").get("phpunit.enableSplitRight", false);
    if (enableSplitRight)
      terminal3.hide();
    await import_coc11.workspace.nvim.command("stopinsert");
    if (enableSplitRight) {
      await import_coc11.workspace.nvim.command(`vert bel sb ${terminal3.bufnr}`);
      await import_coc11.workspace.nvim.command(`wincmd p`);
    }
  } else {
    return import_coc11.window.showErrorMessage("phpunit not found!");
  }
}
function phpunitProjectTestCommand() {
  return async () => {
    const { document } = await import_coc11.workspace.getCurrentState();
    const filePath = import_coc11.Uri.parse(document.uri).fsPath;
    if (document.languageId !== "php" || !filePath.endsWith("Test.php")) {
      return import_coc11.window.showErrorMessage("This file is not a PHP test file!");
    }
    runPhpUnit();
  };
}
function phpunitFileTestCommand() {
  return async () => {
    const { document } = await import_coc11.workspace.getCurrentState();
    const filePath = import_coc11.Uri.parse(document.uri).fsPath;
    if (document.languageId !== "php" || !filePath.endsWith("Test.php")) {
      return import_coc11.window.showErrorMessage("This file is not a PHP test file!");
    }
    runPhpUnit(filePath);
  };
}
function phpunitSingleTestCommand() {
  return async () => {
    const { document, position } = await import_coc11.workspace.getCurrentState();
    const filePath = import_coc11.Uri.parse(document.uri).fsPath;
    if (document.languageId !== "php" || !filePath.endsWith("Test.php")) {
      return import_coc11.window.showErrorMessage("This file is not a PHP test file!");
    }
    const ast = getAst7(document.getText());
    if (!ast)
      return;
    const methods = await getMethods3(ast.children);
    const testName = getTestName2(methods, position);
    if (testName) {
      runPhpUnit(filePath, testName);
    } else {
      import_coc11.window.showErrorMessage(`Test not found`);
    }
  };
}

// src/commands/symfonyConsole.ts
var import_coc12 = require("coc.nvim");
var import_child_process2 = __toESM(require("child_process"));
var import_fs5 = __toESM(require("fs"));
var import_path6 = __toESM(require("path"));
var terminal4;
function activate12(context) {
  import_coc12.listManager.registerList(new SymfonyList(import_coc12.workspace.nvim));
  import_coc12.listManager.registerList(new ArtisanList(import_coc12.workspace.nvim));
  context.subscriptions.push(import_coc12.commands.registerCommand("intelephense.artisan.runCommand", () => {
    import_coc12.workspace.nvim.command(`CocList artisan`);
  }));
  context.subscriptions.push(import_coc12.commands.registerCommand("intelephense.symfony.runCommand", () => {
    import_coc12.workspace.nvim.command(`CocList symfony`);
  }));
}
async function getSymfonyConsolePath(entryPoint) {
  let cmdPath = "";
  const symfonyPath = import_path6.default.join(import_coc12.workspace.root, entryPoint);
  if (import_fs5.default.existsSync(symfonyPath)) {
    cmdPath = symfonyPath;
  }
  return cmdPath;
}
async function getSymfonyConsoleListCommandsJson(symfonyConsolePath) {
  return new Promise((resolve) => {
    import_child_process2.default.exec(`${symfonyConsolePath} list --format json`, (err, stdout, stderr) => {
      if (err || stderr)
        resolve([]);
      if (stdout.length > 0) {
        try {
          const symfonyConsoleListJson = JSON.parse(stdout);
          const names = symfonyConsoleListJson.commands.map((c) => c.name);
          resolve(names);
        } catch (e) {
          resolve([]);
        }
      } else {
        resolve([]);
      }
    });
  });
}
async function runSymfonyConsole(commandName, entryPoint, baseCommandName) {
  const symfonyConsolePath = await getSymfonyConsolePath(entryPoint);
  if (!symfonyConsolePath) {
    return;
  }
  let input = "";
  const isInput = await import_coc12.window.showPrompt(`"${commandName}" | Add args & options?`);
  if (isInput) {
    input = await import_coc12.window.requestInput(`${commandName}`);
    if (!input) {
      const isExec = await import_coc12.window.showPrompt(`Input is empty, can I run it?`);
      if (!isExec)
        return;
    }
  }
  const args = [];
  args.push(symfonyConsolePath);
  args.push(commandName);
  if (input)
    args.push(input);
  if (terminal4) {
    if (terminal4.bufnr) {
      await import_coc12.workspace.nvim.command(`bd! ${terminal4.bufnr}`);
    }
    terminal4.dispose();
    terminal4 = void 0;
  }
  terminal4 = await import_coc12.window.createTerminal({ name: baseCommandName, cwd: import_coc12.workspace.root });
  terminal4.sendText(`php ${args.join(" ")}`);
  const enableSplitRight = import_coc12.workspace.getConfiguration("intelephense").get(baseCommandName + ".enableSplitRight", false);
  if (enableSplitRight)
    terminal4.hide();
  await import_coc12.workspace.nvim.command("stopinsert");
  if (enableSplitRight) {
    await import_coc12.workspace.nvim.command(`vert bel sb ${terminal4.bufnr}`);
    await import_coc12.workspace.nvim.command(`wincmd p`);
  }
}
var SymfonyConsoleList = class extends import_coc12.BasicList {
  constructor(nvim) {
    super(nvim);
    this.name = "symfony_console";
    this.description = "symfony_console for coc-intelephense";
    this.defaultAction = "execute";
    this.actions = [];
    this.entryPoint = "path/to/sf_console";
    this.addAction("execute", (item) => {
      runSymfonyConsole(item.label, this.entryPoint, this.name);
    });
  }
  async loadItems(context) {
    const listItems = [];
    const symfonyConsolePath = await getSymfonyConsolePath(this.entryPoint);
    if (!symfonyConsolePath) {
      return listItems;
    }
    const commands11 = await getSymfonyConsoleListCommandsJson(symfonyConsolePath);
    commands11.forEach((c) => listItems.push({ label: c }));
    return listItems;
  }
};
var ArtisanList = class extends SymfonyConsoleList {
  constructor() {
    super(...arguments);
    this.name = "artisan";
    this.description = "artisan for coc-intelephense";
    this.entryPoint = "artisan";
  }
};
var SymfonyList = class extends SymfonyConsoleList {
  constructor() {
    super(...arguments);
    this.name = "symfony";
    this.description = "symfony for coc-intelephense";
    this.entryPoint = "bin/console";
  }
};

// src/completions/autoCloseDocCommentDoSugesst.ts
var import_coc13 = require("coc.nvim");
function activate13(context) {
  if (import_coc13.workspace.getConfiguration("intelephense").get("client.autoCloseDocCommentDoSuggest", true)) {
    import_coc13.workspace.onDidChangeTextDocument((e) => {
      setTimeout(() => {
        if (!e.textDocument.uri.endsWith(".php"))
          return;
        if (!e.contentChanges[0])
          return;
        if (e.contentChanges[0].text === "\n")
          return;
        if (e.contentChanges[0].range.start.line !== e.contentChanges[0].range.end.line)
          return;
        let nextLine = "";
        try {
          nextLine = e.originalLines[e.contentChanges[0].range.start.line + 1].trim();
        } catch (e2) {
        }
        let currentLine = "";
        try {
          currentLine = e.originalLines[e.contentChanges[0].range.start.line].trim();
        } catch (e2) {
        }
        if (currentLine.endsWith("*/") || nextLine.endsWith("*/"))
          return;
        if (e.contentChanges[0].text === "*" && currentLine === "/*" || e.contentChanges[0].text === "**" && currentLine === "/") {
          let addRangeCharacter = 0;
          if (e.contentChanges[0].text === "*") {
            addRangeCharacter = 1;
          } else if (e.contentChanges[0].text === "**") {
            addRangeCharacter = 2;
          }
          import_coc13.snippetManager.insertSnippet("${0} */", true, import_coc13.Range.create(import_coc13.Position.create(e.contentChanges[0].range.start.line, e.contentChanges[0].range.start.character + addRangeCharacter), import_coc13.Position.create(e.contentChanges[0].range.start.line, e.contentChanges[0].range.start.character + addRangeCharacter)));
          import_coc13.commands.executeCommand("editor.action.triggerSuggest");
        }
      }, 50);
    }, null, context.subscriptions);
  }
}

// src/completions/scaffold.ts
var import_coc14 = require("coc.nvim");
var import_fs6 = __toESM(require("fs"));
var import_path7 = __toESM(require("path"));
function activate14(context) {
  if (!import_coc14.workspace.getConfiguration("intelephense").get("client.disableScaffoldCompletion", false)) {
    context.subscriptions.push(import_coc14.languages.registerCompletionItemProvider("intelephense-scaffold", "intelephense", ["php"], new ScaffoldCompletionProvider()));
  }
}
var ScaffoldCompletionProvider = class {
  async getScaffoldCompletions(document) {
    const scaffoldCompletionItems = [];
    const composerJsonPath = import_path7.default.join(import_coc14.workspace.root, "composer.json");
    let composerJsonContent = null;
    try {
      composerJsonContent = JSON.parse(import_fs6.default.readFileSync(composerJsonPath, "utf8"));
    } catch (error) {
      composerJsonContent = null;
    }
    const fileName = document.uri.split("/").slice(-1)[0].replace(".php", "");
    let namespace = "";
    if (composerJsonContent) {
      const projectNamespaces = this.getProjectNamespacesFromComposerJson(composerJsonContent);
      const workspaceUriPath = import_coc14.Uri.parse(import_coc14.workspace.root).toString();
      const fileUriPath = document.uri;
      const relativeFilePath = fileUriPath.replace(workspaceUriPath + "/", "");
      const fileNamespace = this.getFileNamespace(projectNamespaces, relativeFilePath);
      if (fileNamespace)
        namespace = fileNamespace;
    }
    const phpObjectTypes = ["class", "interface", "trait", "enum", "test"];
    phpObjectTypes.forEach((p) => {
      const contents = [];
      contents.push(`<?php
`);
      contents.push(`
`);
      contents.push(`declare(strict_types=1);
`);
      contents.push(`
`);
      if (namespace) {
        contents.push(`namespace ${namespace};
`);
        contents.push(`
`);
      }
      if (p === "test") {
        contents.push(`use PHPUnit\\Framework\\TestCase;
`);
        contents.push(`
`);
        contents.push(`class ${fileName} extends TestCase
`);
        contents.push(`{
`);
        contents.push(`	\${0:// ...code}
`);
        contents.push(`}
`);
      } else {
        contents.push(`${p} ${fileName}
`);
        contents.push(`{
`);
        contents.push(`	\${0:// ...code}
`);
        contents.push(`}
`);
      }
      scaffoldCompletionItems.push({
        label: `${p}_scaffold`,
        kind: import_coc14.CompletionItemKind.Snippet,
        detail: `${p} scaffold completion`,
        documentation: { kind: "markdown", value: "```php\n" + contents.join("") + "```" },
        insertTextFormat: import_coc14.InsertTextFormat.Snippet,
        data: {
          originalInsertText: contents.join("")
        }
      });
    });
    return scaffoldCompletionItems;
  }
  getProjectNamespacesFromComposerJson(composerJsonContent) {
    const projectNamespaces = [];
    try {
      if ("psr-4" in composerJsonContent.autoload) {
        for (const [k, v] of Object.entries(composerJsonContent.autoload["psr-4"])) {
          projectNamespaces.push({
            [k]: v
          });
        }
      }
      if ("psr-4" in composerJsonContent["autoload-dev"]) {
        for (const [k, v] of Object.entries(composerJsonContent["autoload-dev"]["psr-4"])) {
          projectNamespaces.push({
            [k]: v
          });
        }
      }
    } catch (e) {
    }
    return projectNamespaces;
  }
  getFileNamespace(namespaces, relativeFilePath) {
    const fileName = relativeFilePath.split("/").slice(-1)[0];
    for (const namespace of namespaces) {
      for (const k of Object.keys(namespace)) {
        if (relativeFilePath.startsWith(namespace[k])) {
          const fileNamespace = relativeFilePath.replace(namespace[k], k).replace(/\//g, "\\").replace(fileName, "").replace(/\\$/, "");
          return fileNamespace;
        }
      }
    }
  }
  async provideCompletionItems(document, position, token, context) {
    const completionItems = [];
    if (position.line !== 0)
      return completionItems;
    const doc = import_coc14.workspace.getDocument(document.uri);
    if (!doc)
      return [];
    const completions = await this.getScaffoldCompletions(document);
    completionItems.push(...completions);
    return completionItems;
  }
  async resolveCompletionItem(item) {
    if (item.kind === import_coc14.CompletionItemKind.Snippet) {
      if (item.data) {
        const dataEntry = item.data;
        item.insertText = dataEntry.originalInsertText;
      }
    }
    return item;
  }
};

// src/completions/snippets.ts
var import_coc15 = require("coc.nvim");
var import_fs7 = __toESM(require("fs"));
var import_path8 = __toESM(require("path"));
function activate15(context) {
  if (!import_coc15.workspace.getConfiguration("intelephense").get("client.disableSnippetsCompletion", false)) {
    context.subscriptions.push(import_coc15.languages.registerCompletionItemProvider("intelephense-snippets", "intelephense", ["php"], new SnippetsCompletionProvider(context), [], 99));
  }
}
var SnippetsCompletionProvider = class {
  constructor(context) {
    this._context = context;
    this.snippetsFilePath = import_path8.default.join(this._context.extensionPath, "data", "snippets", "php.code-snippets");
    this.excludeSnippetsKeys = import_coc15.workspace.getConfiguration("intelephense").get("client.snippetsCompletionExclude", []);
  }
  async getSnippetsCompletionItems(snippetsFilePath) {
    const snippetsCompletionList = [];
    if (import_fs7.default.existsSync(snippetsFilePath)) {
      const snippetsJsonText = import_fs7.default.readFileSync(snippetsFilePath, "utf8");
      const snippetsJson = JSON.parse(snippetsJsonText);
      if (snippetsJson) {
        Object.keys(snippetsJson).map((key) => {
          if (this.excludeSnippetsKeys.includes(snippetsJson[key].prefix))
            return;
          let snippetsText;
          const body = snippetsJson[key].body;
          if (body instanceof Array) {
            snippetsText = body.join("\n");
          } else {
            snippetsText = body;
          }
          snippetsCompletionList.push({
            label: snippetsJson[key].prefix,
            kind: import_coc15.CompletionItemKind.Snippet,
            filterText: snippetsJson[key].prefix,
            detail: snippetsJson[key].description,
            documentation: { kind: "markdown", value: "```php\n<?php\n" + snippetsText + "\n```" },
            insertTextFormat: import_coc15.InsertTextFormat.Snippet,
            data: snippetsText
          });
        });
      }
    }
    return snippetsCompletionList;
  }
  async provideCompletionItems(document, position, token, context) {
    const doc = import_coc15.workspace.getDocument(document.uri);
    if (!doc)
      return [];
    const wordRange = doc.getWordRangeAtPosition(import_coc15.Position.create(position.line, position.character - 1), `>:"'`);
    if (!wordRange)
      return [];
    const text = document.getText(wordRange) || "";
    if (!text)
      return [];
    if (text.match(/[>:"']/))
      return [];
    const completionList = this.getSnippetsCompletionItems(this.snippetsFilePath);
    return completionList;
  }
  async resolveCompletionItem(item) {
    if (item.kind === import_coc15.CompletionItemKind.Snippet) {
      item.insertText = item.data;
    }
    return item;
  }
};

// src/inlayHints/inlineParameters.ts
var import_coc16 = require("coc.nvim");

// src/parsers/inlineParameters.ts
var import_php_parser8 = __toESM(require_src());
var parserEngine8 = new import_php_parser8.Engine({
  parser: {
    extractDoc: true,
    php7: true,
    locations: true,
    suppressErrors: true
  },
  ast: {
    all_tokens: true,
    withPositions: true
  }
});
function getAst8(code) {
  try {
    return parserEngine8.parseEval(stripPHPTag(code));
  } catch (e) {
    return void 0;
  }
  function stripPHPTag(code2) {
    return code2.replace("<?php", "").replace("?>", "");
  }
}
function crawlAstToCallAndNewNode(ast, functionCalls = []) {
  const canAcceptArguments = ast.kind && (ast.kind === "call" || ast.kind === "new");
  const hasArguments = ast.arguments && ast.arguments.length > 0;
  if (canAcceptArguments && hasArguments) {
    functionCalls.push(ast);
  }
  for (const [, value] of Object.entries(ast)) {
    if (value instanceof Object) {
      functionCalls = crawlAstToCallAndNewNode(value, functionCalls);
    }
  }
  return functionCalls;
}
function getParametersFromFuncs(expression) {
  const parameters = [];
  if (!expression.arguments)
    return;
  expression.arguments.forEach((argument, key) => {
    var _a;
    if (!expression.what || !expression.what["offset"] && !expression.what.loc) {
      return;
    }
    const expressionLoc = expression.what["offset"] ? expression.what["offset"]["loc"]["start"] : (_a = expression.what.loc) == null ? void 0 : _a.end;
    const parameterPosition = {
      namedValue: void 0,
      expression: {
        start: {
          line: expressionLoc.line,
          character: expressionLoc.column
        },
        end: {
          line: -1,
          character: -1
        }
      },
      key,
      start: {
        line: argument.loc.start.line,
        character: argument.loc.start.column
      },
      end: {
        line: argument.loc.end.line,
        character: argument.loc.end.column
      }
    };
    parameters.push(parameterPosition);
  });
  return parameters;
}

// src/inlayHints/inlineParameters.ts
async function activate16(context, client) {
  if (!import_coc16.workspace.getConfiguration("intelephense").get("client.disableInlayHints", true)) {
    await client.onReady();
    const documentSelector = [{ language: "php", scheme: "file" }];
    context.subscriptions.push(import_coc16.languages.registerInlayHintsProvider(documentSelector, new InlineParametersInlayHintsProvider(context, client)));
  }
}
var InlineParametersInlayHintsProvider = class {
  constructor(context, client) {
    this.context = context;
    this.client = client;
  }
  async provideInlayHints(document, range, token) {
    const inlayHints = [];
    const code = document.getText();
    const ast = getAst8(code);
    if (!ast)
      return [];
    const functionParmeters = [];
    const functionCalls = crawlAstToCallAndNewNode(ast.children);
    functionCalls.forEach((expression) => {
      const functionParmeter = getParametersFromFuncs(expression);
      if (functionParmeter) {
        functionParmeters.push(functionParmeter);
      }
    });
    for (const languageParameters of functionParmeters) {
      if (languageParameters === void 0)
        continue;
      let parameters;
      try {
        parameters = await this.getParameterNames(document, languageParameters);
      } catch (error) {
        continue;
      }
      for (let index = 0; index < languageParameters.length; index++) {
        try {
          const parameter = languageParameters[index];
          let parameterName = parameters[index].name;
          const parameterDefinition = parameters[index].definition;
          if (!parameterName)
            continue;
          const position = import_coc16.Position.create(parameter.end.line - 1, parameter.end.character);
          if (index === 0) {
            parameterName = ": " + parameterName;
          }
          const inlayHintLabelPart = [
            {
              value: parameterName
            }
          ];
          const tooltipValue = {
            kind: "markdown",
            value: parameterDefinition
          };
          const inlayHint = {
            label: inlayHintLabelPart,
            position,
            tooltip: tooltipValue,
            paddingLeft: true
          };
          inlayHints.push(inlayHint);
        } catch (error) {
          continue;
        }
      }
    }
    return inlayHints;
  }
  async getParameterNames(document, languageParameters) {
    const firstParameter = languageParameters[0];
    let parameters = [];
    const position = import_coc16.Position.create(firstParameter.expression.start.line - 1, firstParameter.expression.start.character);
    const params = {
      textDocument: { uri: document.uri },
      position
    };
    const description = await this.client.sendRequest("textDocument/hover", params);
    const definition = description.contents;
    if (description) {
      try {
        const regex = /(?<=@param)[^.]*?((?:\.{3})?\$[\w]+).*?[\r\n|\n] ?(.*?)[\r\n|\n](?:_@param|_@return)/gs;
        if (!definition.value.includes("```"))
          return parameters;
        const splitDefinition = definition.value.split("__");
        const firstDefinition = [splitDefinition[1], splitDefinition[2]].join("__");
        parameters = definition ? [...firstDefinition.matchAll(regex)] : [];
      } catch (error) {
      }
    }
    if (!parameters)
      return Promise.reject();
    const parameterDetails = parameters.map((parameterInformation) => {
      const name = parameterInformation[1];
      const definition2 = parameterInformation[2];
      const parameter = {
        name: this.getConfigShowDollarSign() ? name : name.replace("$", ""),
        definition: definition2
      };
      return parameter;
    });
    return parameterDetails;
  }
  getConfigShowDollarSign() {
    return import_coc16.workspace.getConfiguration("intelephense").get("inlineParameters.showDollarSign", false);
  }
};

// src/lenses/pest.ts
var import_coc17 = require("coc.nvim");
function activate17(context) {
  if (!import_coc17.workspace.getConfiguration("intelephense").get("client.disableCodeLens", false)) {
    const useCodelensProvider = import_coc17.workspace.getConfiguration("intelephense").get("client.codelensProvider", "phpunit");
    if (useCodelensProvider === "pest") {
      context.subscriptions.push(import_coc17.languages.registerCodeLensProvider([{ language: "php", scheme: "file" }], new PestCodeLensProvider()));
    }
  }
}
var PestCodeLensProvider = class {
  async provideCodeLenses(document, token) {
    const filePath = import_coc17.Uri.parse(document.uri).fsPath;
    if (document.languageId !== "php" || !filePath.endsWith("Test.php")) {
      return [];
    }
    const codeLensTitle = import_coc17.workspace.getConfiguration("intelephense").get("pest.codeLensTitle", ">> [RUN Pest]");
    const codeLenses = [];
    if (import_coc17.events.insertMode)
      return codeLenses;
    try {
      const ast = getAst6(document.getText());
      if (!ast)
        return;
      const methods = await getMethods2(ast.children);
      const testMethods = getTestMethods(methods);
      testMethods.forEach((m) => {
        if (m.startLine && m.endLine) {
          const lens = {
            range: import_coc17.Range.create(import_coc17.Position.create(m.startLine - 1, 0), import_coc17.Position.create(m.endLine, 0)),
            command: {
              title: codeLensTitle,
              command: "intelephense.pest.singleTest"
            }
          };
          codeLenses.push(lens);
        }
      });
    } catch (e) {
    }
    try {
      const ast = getAst6(document.getText());
      if (!ast)
        return;
      const pestTestDetails = await getPestTestDetail(ast.children);
      pestTestDetails.forEach((m) => {
        if (m.startLine && m.endLine) {
          const lens = {
            range: import_coc17.Range.create(import_coc17.Position.create(m.startLine - 1, 0), import_coc17.Position.create(m.endLine, 0)),
            command: {
              title: codeLensTitle,
              command: "intelephense.pest.singleTest"
            }
          };
          codeLenses.push(lens);
        }
      });
    } catch (e) {
    }
    if (codeLenses.length === 0) {
      codeLenses.push({
        range: import_coc17.Range.create(import_coc17.Position.create(0, 0), import_coc17.Position.create(0, 0))
      });
    }
    return codeLenses;
  }
};

// src/lenses/phpunit.ts
var import_coc18 = require("coc.nvim");
function activate18(context) {
  if (!import_coc18.workspace.getConfiguration("intelephense").get("client.disableCodeLens", false)) {
    const useCodelensProvider = import_coc18.workspace.getConfiguration("intelephense").get("client.codelensProvider", "phpunit");
    if (useCodelensProvider === "phpunit") {
      context.subscriptions.push(import_coc18.languages.registerCodeLensProvider([{ language: "php", scheme: "file" }], new PHPUnitCodeLensProvider()));
    }
  }
}
var PHPUnitCodeLensProvider = class {
  async provideCodeLenses(document, token) {
    const filePath = import_coc18.Uri.parse(document.uri).fsPath;
    if (document.languageId !== "php" || !filePath.endsWith("Test.php")) {
      return [];
    }
    const codeLensTitle = import_coc18.workspace.getConfiguration("intelephense").get("phpunit.codeLensTitle", ">> [RUN PHPUnit]");
    const codeLenses = [];
    if (import_coc18.events.insertMode)
      return codeLenses;
    try {
      const ast = getAst7(document.getText());
      if (!ast)
        return;
      const methods = await getMethods3(ast.children);
      const testMethods = getTestMethods2(methods);
      testMethods.forEach((m) => {
        if (m.startLine && m.endLine) {
          const lens = {
            range: import_coc18.Range.create(import_coc18.Position.create(m.startLine - 1, 0), import_coc18.Position.create(m.endLine, 0)),
            command: {
              title: codeLensTitle,
              command: "intelephense.phpunit.singleTest"
            }
          };
          codeLenses.push(lens);
        }
      });
    } catch (e) {
    }
    if (codeLenses.length === 0) {
      codeLenses.push({
        range: import_coc18.Range.create(import_coc18.Position.create(0, 0), import_coc18.Position.create(0, 0))
      });
    }
    return codeLenses;
  }
};

// src/index.ts
var PHP_LANGUAGE_ID = "php";
var INDEXING_STARTED_NOTIFICATION = new import_coc19.NotificationType("indexingStarted");
var INDEXING_ENDED_NOTIFICATION = new import_coc19.NotificationType("indexingEnded");
var CANCEL_INDEXING_REQUEST = new import_coc19.RequestType("cancelIndexing");
var INDEX_WORKSPACE_CMD_NAME = "intelephense.index.workspace";
var CANCEL_INDEXING_CMD_NAME = "intelephense.cancel.indexing";
var extensionContext;
var clientDisposable;
var languageClient;
async function activate19(context) {
  extensionContext = context;
  const extConfig = import_coc19.workspace.getConfiguration("intelephense");
  const isEnable = extConfig.get("enable", true);
  if (!isEnable)
    return;
  if (!import_coc19.workspace.getConfiguration("intelephense").get("client.disableAddIskeyword", false)) {
    const { document } = await import_coc19.workspace.getCurrentState();
    if (document.languageId === "php") {
      try {
        await import_coc19.workspace.nvim.command("setlocal iskeyword+=$");
        import_coc19.workspace.registerAutocmd({
          event: "FileType",
          pattern: "php",
          request: true,
          callback: async () => {
            await import_coc19.workspace.nvim.command("setlocal iskeyword+=$");
          }
        });
      } catch {
      }
    }
  }
  const module2 = context.asAbsolutePath("node_modules/intelephense");
  if (!import_fs8.default.existsSync(module2)) {
    import_coc19.window.showErrorMessage(`intelephense module doesn't exist, please reinstall coc-intelephense"`);
    return;
  }
  const clearCache = true;
  languageClient = createClient(context, clearCache);
  context.subscriptions.push(import_coc19.commands.registerCommand(INDEX_WORKSPACE_CMD_NAME, indexWorkspace), import_coc19.commands.registerCommand(CANCEL_INDEXING_CMD_NAME, cancelIndexing));
  clientDisposable = languageClient.start();
  activate13(context);
  activate14(context);
  activate15(context);
  activate7(context);
  activate12(context);
  activate11(context);
  activate10(context);
  activate8(context);
  activate9(context);
  activate6(context);
  activate18(context);
  activate17(context);
  activate(context);
  activate4(context);
  activate3(context);
  activate2(context);
  activate5(context);
}
function createClient(context, clearCache) {
  const intelephenseConfig = import_coc19.workspace.getConfiguration("intelephense");
  const runtime = intelephenseConfig.get("runtime");
  const memory = Math.floor(Number(intelephenseConfig.get("maxMemory")));
  const licenceKey = intelephenseConfig.get("licenceKey");
  let module2 = intelephenseConfig.get("path");
  if (module2) {
    module2 = import_coc19.workspace.expand(module2);
    if (!import_fs8.default.existsSync(module2)) {
      module2 = void 0;
    }
  }
  if (!module2) {
    module2 = context.asAbsolutePath("node_modules/intelephense");
  }
  const debugOptions = {
    execArgv: ["--nolazy", "--inspect=6039", "--trace-warnings", "--preserve-symlinks"],
    detached: true
  };
  const serverOptions = {
    run: { module: module2, transport: import_coc19.TransportKind.ipc },
    debug: { module: module2, transport: import_coc19.TransportKind.ipc, options: debugOptions }
  };
  if (runtime) {
    serverOptions.run.runtime = runtime;
    serverOptions.debug.runtime = runtime;
  }
  if (memory && memory >= 256) {
    const maxOldSpaceSize = "--max-old-space-size=" + memory.toString();
    serverOptions.run.options = { execArgv: [maxOldSpaceSize] };
    if (serverOptions.debug.options) {
      if (serverOptions.debug.options.execArgv) {
        serverOptions.debug.options.execArgv.push(maxOldSpaceSize);
      }
    }
  }
  const clientOptions = {
    documentSelector: [
      { language: PHP_LANGUAGE_ID, scheme: "file" },
      { language: PHP_LANGUAGE_ID, scheme: "untitled" }
    ],
    initializationOptions: {
      globalStoragePath: context.storagePath,
      storagePath: context.storagePath,
      clearCache,
      licenceKey
    },
    disabledFeatures: getLanguageClientDisabledFeatures(),
    middleware: {
      provideDefinition: async (document, position, token, next) => {
        if (getConfigServerDisableDefinition())
          return;
        return await next(document, position, token);
      },
      handleDiagnostics: getConfigDiagnosticsIgnoreErrorFeature() ? handleDiagnostics : void 0
    }
  };
  const languageClient2 = new import_coc19.LanguageClient("intelephense", "intelephense", serverOptions, clientOptions);
  languageClient2.onReady().then(() => {
    registerNotificationListeners(context);
  });
  return languageClient2;
}
function indexWorkspace() {
  if (!languageClient) {
    return;
  }
  languageClient.stop().then(() => {
    clientDisposable.dispose();
    languageClient = createClient(extensionContext, true);
    clientDisposable = languageClient.start();
  });
}
function cancelIndexing() {
  languageClient.sendRequest(CANCEL_INDEXING_REQUEST.method);
  import_coc19.window.showWarningMessage("intelephense indexing has been canceled!");
}
function registerNotificationListeners(context) {
  const intelephenseConfig = import_coc19.workspace.getConfiguration("intelephense");
  const progressEnable = intelephenseConfig.get("progress.enable");
  let resolveIndexingPromise;
  if (progressEnable) {
    languageClient.onNotification(INDEXING_STARTED_NOTIFICATION.method, () => {
      displayInitIndexProgress(new Promise((resolve, reject) => {
        resolveIndexingPromise = () => {
          resolve();
        };
      }));
    });
    languageClient.onNotification(INDEXING_ENDED_NOTIFICATION.method, () => {
      if (resolveIndexingPromise) {
        resolveIndexingPromise();
      }
      activate16(context, languageClient);
    });
  } else {
    languageClient.onNotification(INDEXING_STARTED_NOTIFICATION.method, () => {
      import_coc19.window.showInformationMessage("intelephense indexing ...");
    });
    languageClient.onNotification(INDEXING_ENDED_NOTIFICATION.method, () => {
      if (resolveIndexingPromise) {
        resolveIndexingPromise();
      }
      activate16(context, languageClient);
      import_coc19.window.showInformationMessage("intelephense running!");
    });
  }
}
async function displayInitIndexProgress(promise) {
  return import_coc19.window.withProgress({
    title: "intelephense indexing ...",
    cancellable: true
  }, (progress, token) => {
    token.onCancellationRequested(() => {
      cancelIndexing();
    });
    return promise;
  });
}
function handleDiagnostics(uri, diagnostics, next) {
  const doc = import_coc19.workspace.getDocument(uri);
  next(uri, diagnostics.filter((d) => {
    const curLine = doc.getline(d.range.start.line);
    return curLine.indexOf("@intelephense-ignore-line") === -1;
  }).filter((d) => {
    const len = doc.getLines().length;
    const prevLine = len > 1 ? doc.getline(d.range.start.line - 1) : "";
    return prevLine.indexOf("@intelephense-ignore-next-line") === -1;
  }));
}
function getLanguageClientDisabledFeatures() {
  const r = [];
  if (getConfigServerDisableCompletion())
    r.push("completion");
  return r;
}
function getConfigServerDisableCompletion() {
  return import_coc19.workspace.getConfiguration("intelephense").get("server.disableCompletion", false);
}
function getConfigServerDisableDefinition() {
  return import_coc19.workspace.getConfiguration("intelephense").get("server.disableDefinition", false);
}
function getConfigDiagnosticsIgnoreErrorFeature() {
  return import_coc19.workspace.getConfiguration("intelephense").get("client.diagnosticsIgnoreErrorFeature", false);
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate
});
